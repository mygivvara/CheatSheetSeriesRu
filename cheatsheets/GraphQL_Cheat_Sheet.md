# Шпаргалка по GraphQL

## Введение

[GraphQL](https://graphql.org) — это язык запросов с открытым исходным кодом, первоначально разработанный Facebook, который можно использовать для создания API в качестве альтернативы REST и SOAP. С момента своего появления в 2012 году GraphQL приобрел популярность благодаря гибкости, которую он предлагает разработчикам API и клиентам. Существует множество серверов и клиентов GraphQL, реализованных на различных языках. [Многие компании](https://foundation.graphql.org/) используют GraphQL, включая GitHub, Credit Karma, Intuit и PayPal.

Эта шпаргалка предоставляет рекомендации по различным аспектам работы с GraphQL:

- Применяйте надлежащие проверки [валидации ввода](Input_Validation_Cheat_Sheet.md) ко всем входящим данным.
- Дорогие запросы могут привести к [атакам типа Denial of Service (DoS)](Denial_of_Service_Cheat_Sheet.md), поэтому добавляйте проверки, чтобы ограничить или предотвратить слишком дорогие запросы.
- Убедитесь, что API имеет надлежащие проверки [контроля доступа](Access_Control_Cheat_Sheet.md).
- Отключите небезопасные настройки по умолчанию (например, избыточные ошибки, интроспекция, GraphiQL и т.д.).

## Общие атаки

- [Инъекция](https://github.com/OWASP/API-Security/blob/master/2019/en/src/0xa8-injection.md) — это обычно включает, но не ограничивается:
    - [SQL](https://owasp.org/www-community/attacks/SQL_Injection) и [NoSQL](https://www.netsparker.com/blog/web-security/what-is-nosql-injection/) инъекции
    - [Инъекция команд ОС](https://owasp.org/www-community/attacks/Command_Injection)
    - [SSRF](https://portswigger.net/web-security/ssrf) и [CRLF](https://owasp.org/www-community/vulnerabilities/CRLF_Injection) [инъекция](https://www.acunetix.com/websitesecurity/crlf-injection/)/[Смещение запросов](https://portswigger.net/web-security/request-smuggling)
- [DoS](https://owasp.org/www-community/attacks/Denial_of_Service) ([Denial of Service](https://www.cloudflare.com/learning/ddos/glossary/denial-of-service/))
- Злоупотребление нарушенным авторизацией: либо [неправильный](https://github.com/OWASP/API-Security/blob/master/2019/en/src/0xa1-broken-object-level-authorization.md), либо [избыточный](https://github.com/OWASP/API-Security/blob/master/2019/en/src/0xa3-excessive-data-exposure.md) доступ, включая [IDOR](https://portswigger.net/web-security/access-control/idor)
- Атаки с использованием пакетной обработки, метод брутфорса, специфичный для GraphQL
- Злоупотребление небезопасными настройками по умолчанию

## Лучшие практики и рекомендации

### Валидация ввода

Добавление строгой валидации ввода может помочь предотвратить инъекции и DoS. Основной принцип GraphQL заключается в том, что пользователь предоставляет один или несколько идентификаторов, а сервер получает данные, делая HTTP-запросы, запросы к БД или другие вызовы с использованием указанных идентификаторов. Это означает, что пользовательский ввод будет включен в HTTP-запросы, запросы к БД или другие запросы/вызовы, что предоставляет возможность для инъекций, которые могут привести к различным атакам или DoS.

Смотрите чек-листы OWASP по [валидации ввода](Input_Validation_Cheat_Sheet.md) и общей [предотвращению инъекций](Injection_Prevention_Cheat_Sheet.md) для получения полных рекомендаций по выполнению валидации ввода и предотвращению инъекций.

#### Общие практики

Проверяйте все входящие данные, чтобы допускать только допустимые значения (т.е. список разрешенных значений).

- Используйте конкретные типы данных GraphQL, такие как [скаляры](https://graphql.org/learn/schema/#scalar-types) или [перечисления](https://graphql.org/learn/schema/#enumeration-types). Напишите пользовательские [валидаторы](https://graphql.org/learn/validation/) для более сложных проверок. Также могут пригодиться [пользовательские скаляры](https://itnext.io/custom-scalars-in-graphql-9c26f43133f3).
- Определяйте [схемы для ввода мутаций](https://graphql.org/learn/schema/#input-types).
- [Список разрешенных символов](Input_Validation_Cheat_Sheet.md#allow-list-vs-block-list) — не используйте черный список.
    - Чем строже список разрешенных символов, тем лучше. Хорошей отправной точкой часто является разрешение только буквенно-цифровых, не юникодных символов, так как это предотвращает многие атаки.
- Для правильной обработки юникодного ввода используйте [единую внутреннюю кодировку символов](Input_Validation_Cheat_Sheet.md#validating-free-form-unicode-text).
- Корректно [отклоняйте недопустимый ввод](Error_Handling_Cheat_Sheet.md), стараясь не раскрывать избыточную информацию о том, как работает API и его валидация.

#### Предотвращение инъекций

При обработке ввода, который предназначен для передачи другому интерпретатору (например, SQL/NoSQL/ORM, ОС, LDAP, XML):

- Всегда выбирайте библиотеки/модули/пакеты, предлагающие безопасные API, такие как параметризованные запросы.
    - Убедитесь, что вы следуете документации, чтобы правильно использовать инструмент.
    - Использование ORMs и ODMs является хорошим вариантом, но они должны использоваться правильно, чтобы избежать уязвимостей, таких как [ORM-инъекция](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/07-Input_Validation_Testing/05.7-Testing_for_ORM_Injection).
- Если такие инструменты недоступны, всегда выполняйте экранирование/кодирование входных данных в соответствии с лучшими практиками целевого интерпретатора.
    - Выберите хорошо документированную и активно поддерживаемую библиотеку экранирования/кодирования. Многие языки и фреймворки имеют эту функциональность встроенной.

Для получения дополнительной информации смотрите следующие страницы:

- [Предотвращение SQL-инъекций](SQL_Injection_Prevention_Cheat_Sheet.md)
- [Предотвращение NoSQL-инъекций](https://www.netsparker.com/blog/web-security/what-is-nosql-injection/)
- [Предотвращение LDAP-инъекций](LDAP_Injection_Prevention_Cheat_Sheet.md)
- [Предотвращение инъекций команд ОС](OS_Command_Injection_Defense_Cheat_Sheet.md)
- [XML-безопасность](XML_Security_Cheat_Sheet.md) и [Предотвращение XXE-инъекций](XML_External_Entity_Prevention_Cheat_Sheet.md)

#### Валидация процессов

При использовании пользовательского ввода, даже если он очищен и/или проверен, его не следует использовать для определенных целей, которые могут дать пользователю контроль над потоком данных. Например, не делайте HTTP/ресурсный запрос к хосту, который указывает пользователь (если нет абсолютной необходимости в бизнесе).

### Предотвращение DoS

DoS — это атака на доступность и стабильность API, которая может сделать его медленным, неотзывчивым или полностью недоступным. Этот чек-лист описывает несколько методов ограничения возможности атаки DoS на уровне приложения и других слоев технологического стека. Также есть чек-лист, посвященный теме [DoS](Denial_of_Service_Cheat_Sheet.md).

Вот рекомендации, специфичные для GraphQL, для ограничения потенциальных DoS-атак:

- Добавьте ограничение глубины для входящих запросов.
- Добавьте ограничение объема для входящих запросов.
- Добавьте [пагинацию](https://graphql.org/learn/pagination/) для ограничения объема данных, которые могут быть возвращены в одном ответе.
- Установите разумные тайм-ауты на уровне приложения, инфраструктуры или на обоих уровнях.
- Рассмотрите возможность анализа стоимости запросов и внедрения максимального допустимого значения стоимости для каждого запроса.
- Применяйте ограничение частоты запросов по IP или пользователю (или обоим), чтобы предотвратить базовые атаки DoS.
- Реализуйте [технику пакетной обработки и кэширования](https://graphql.org/learn/best-practices/#server-side-batching-caching) на стороне сервера (для этого можно использовать [DataLoader](https://github.com/facebook/dataloader)).

#### Ограничение запросов (Глубина и Количество)

В GraphQL каждый запрос имеет глубину (например, вложенные объекты), и каждый объект, запрашиваемый в запросе, может иметь указанное количество (например, 99999999 объектов). По умолчанию эти параметры могут быть неограниченными, что может привести к DoS-атакам. Вы должны установить ограничения на глубину и количество, чтобы предотвратить DoS, но это обычно требует небольшой кастомной реализации, так как GraphQL не поддерживает это по умолчанию. Смотрите [эту](https://www.apollographql.com/blog/securing-your-graphql-api-from-malicious-queries-16130a324a6b) и [эту](https://www.howtographql.com/advanced/4-security/) страницы для получения дополнительной информации о таких атаках и способах добавления ограничений по глубине и количеству. Также может помочь добавление [пагинации](https://graphql.org/learn/pagination/).

APIs, использующие graphql-java, могут использовать встроенную [MaxQueryDepthInstrumentation](https://github.com/graphql-java/graphql-java/blob/master/src/main/java/graphql/analysis/MaxQueryDepthInstrumentation.java) для ограничения глубины. APIs, использующие JavaScript, могут использовать [graphql-depth-limit](https://www.npmjs.com/package/graphql-depth-limit) для реализации ограничения глубины и [graphql-input-number](https://github.com/joonhocho/graphql-input-number) для ограничения количества.

Пример GraphQL-запроса с глубиной N:

```javascript
query evil {            # Глубина: 0
  album(id: 42) {       # Глубина: 1
    songs {             # Глубина: 2
      album {           # Глубина: 3
        ...             # Глубина: ...
        album {id: N}   # Глубина: N
      }
    }
  }
}
```

Пример GraphQL-запроса, запрашивающего 99999999 объектов:

```javascript
query {
  author(id: "abc") {
    posts(first: 99999999) {
      title
    }
  }
}
```

#### Тайм-ауты

Добавление тайм-аутов может быть простым способом ограничения количества ресурсов, которые может потреблять один запрос. Но тайм-ауты не всегда эффективны, так как они могут не активироваться до того, как вредоносный запрос уже потребует чрезмерное количество ресурсов. Требования к тайм-аутам будут различаться в зависимости от API и механизма извлечения данных; не существует универсального значения тайм-аута, которое подходило бы всем.

На уровне приложения тайм-ауты могут быть добавлены для запросов и функций резолверов. Этот вариант обычно более эффективен, так как запрос/разрешение может быть остановлено, как только будет достигнут тайм-аут. GraphQL по умолчанию не поддерживает тайм-ауты запросов, поэтому требуется написание кастомного кода. Смотрите [этот пост в блоге](https://medium.com/workflowgen/graphql-query-timeout-and-complexity-management-fab4d7315d8d) для получения дополнительной информации о использовании тайм-аутов с GraphQL или два приведенных ниже примера.

### Примеры Тайм-аутов

**Пример Тайм-аута в JavaScript**

Фрагмент кода из [этого ответа на SO](https://stackoverflow.com/a/53277955/1200388):

```javascript
request.incrementResolverCount = function () {
    var runTime = Date.now() - startTime;
    if (runTime > 10000) {  // тайм-аут 10 секунд
      if (request.logTimeoutError) {
        logger('ERROR', `Запрос ${request.uuid} превысил тайм-аут выполнения запроса`);
      }
      request.logTimeoutError = false;
      throw 'Время выполнения запроса истекло. Разрешение поля прервано';
    }
    this.resolverCount++;
};
```

**Пример Тайм-аута в Java с использованием [Instrumentation](https://www.graphql-java.com/documentation/instrumentation)**

```java
public class TimeoutInstrumentation extends SimpleInstrumentation {
    @Override
    public DataFetcher<?> instrumentDataFetcher(
            DataFetcher<?> dataFetcher, InstrumentationFieldFetchParameters parameters
    ) {
        return environment ->
            Observable.fromCallable(() -> dataFetcher.get(environment))
                .subscribeOn(Schedulers.computation())
                .timeout(10, TimeUnit.SECONDS)  // тайм-аут 10 секунд
                .blockingFirst();
    }
}
```

**Тайм-ауты на Уровне Инфраструктуры**

Другой вариант добавления тайм-аута, который обычно проще, — это добавление тайм-аута на HTTP сервере ([Apache/httpd](https://httpd.apache.org/docs/2.4/mod/core.html#timeout), [nginx](http://nginx.org/en/docs/http/ngx_http_core_module.html#send_timeout)), обратном прокси или балансировщике нагрузки. Однако тайм-ауты на уровне инфраструктуры часто неточные и могут быть легче обойдены, чем тайм-ауты на уровне приложения.

### Анализ Стоимости Запросов

Анализ стоимости запросов включает в себя назначение стоимости на разрешение полей или типов в входящих запросах, чтобы сервер мог отклонять запросы, которые стоят слишком дорого в исполнении или потребляют слишком много ресурсов. Это не легко реализовать и может не всегда быть необходимым, но это самый тщательный подход к предотвращению DoS. Для получения более подробной информации об реализации этого контроля, смотрите "Анализ Стоимости Запросов" в [этой статье блога](https://www.apollographql.com/blog/securing-your-graphql-api-from-malicious-queries-16130a324a6b).

Apollo рекомендует:

> **Прежде чем тратить много времени на реализацию анализа стоимости запросов, убедитесь, что он вам действительно нужен.** Попробуйте перегрузить или замедлить ваше тестовое API с помощью вредоносного запроса и посмотрите, насколько это возможно — возможно, ваше API не имеет таких вложенных связей, или, возможно, оно может нормально обрабатывать запросы на тысячи записей за раз и не нуждается в анализе стоимости запросов!

APIs, использующие graphql-java, могут использовать встроенную [MaxQueryComplexityInstrumentation](https://github.com/graphql-java/graphql-java/blob/master/src/main/java/graphql/analysis/MaxQueryComplexityInstrumentation.java) для обеспечения максимальной сложности запроса. APIs, использующие JavaScript, могут использовать [graphql-cost-analysis](https://github.com/pa-bru/graphql-cost-analysis) или [graphql-validation-complexity](https://github.com/4Catalyzer/graphql-validation-complexity) для обеспечения максимальной стоимости запроса.

### Ограничение Частоты Запросов

Применение ограничения частоты запросов на основе IP или пользователя (для анонимного и неавторизованного доступа) может помочь ограничить способность одного пользователя спамить запросами сервис и воздействовать на производительность. В идеале это можно сделать с помощью WAF, API шлюза или веб-сервера ([Nginx](https://www.nginx.com/blog/rate-limiting-nginx/), [Apache](https://httpd.apache.org/docs/2.4/mod/mod_ratelimit.html)/[HTTPD](https://github.com/jzdziarski/mod_evasive)), чтобы уменьшить усилия по добавлению ограничения частоты.

Или вы можете усложнить задачу с помощью троттлинга и реализовать его в вашем коде (непросто). Смотрите "Троттлинг" [здесь](https://www.howtographql.com/advanced/4-security/) для получения дополнительной информации о конкретных ограничениях частоты для GraphQL.

### Сбор и Кеширование на Стороне Сервера

Для повышения эффективности API GraphQL и снижения его потребления ресурсов можно использовать [технику сбора и кеширования](https://graphql.org/learn/best-practices/#server-side-batching-caching), чтобы предотвратить дублирование запросов на одни и те же данные в короткий промежуток времени. Инструмент Facebook [DataLoader](https://github.com/facebook/dataloader) является одним из способов реализации этого.

### Управление Ресурсами Системы

Неправильное ограничение объема ресурсов, которые ваше API может использовать (_например_, CPU или память), может нарушить его отзывчивость и доступность, оставив его уязвимым для DoS-атак. Некоторые ограничения могут быть выполнены на уровне операционной системы.

В Linux можно использовать комбинацию [Control Groups (cgroups)](https://en.wikipedia.org/wiki/Cgroups), [User Limits (ulimits)](https://linuxhint.com/linux_ulimit_command/) и [Linux Containers (LXC)](https://linuxcontainers.org/lxc/security/).

Однако платформы контейнеризации, как правило, значительно упрощают эту задачу. См. раздел об ограничении ресурсов в [Docker Security Cheat Sheet](Docker_Security_Cheat_Sheet.md#rule-7-limit-resources-memory-cpu-file-descriptors-processes-restarts) для получения информации о том, как предотвратить DoS при использовании контейнеров.

### Контроль Доступа

Для обеспечения правильного контроля доступа в API GraphQL выполните следующее:

- Всегда проверяйте, что запрашивающий пользователь авторизован для просмотра или изменения данных, которые они запрашивают. Это можно сделать с помощью [RBAC](Access_Control_Cheat_Sheet.md#role-based-access-control-rbac) или других механизмов контроля доступа.
    - Это предотвратит проблемы [IDOR](Insecure_Direct_Object_Reference_Prevention_Cheat_Sheet.md), включая как [BOLA](https://github.com/OWASP/API-Security/blob/master/2019/en/src/0xa1-broken-object-level-authorization.md), так и [BFLA](https://github.com/OWASP/API-Security/blob/master/2019/en/src/0xa5-broken-function-level-authorization.md).
- Применяйте проверки авторизации как на краях, так и на узлах (смотрите пример [отчета о баге](https://hackerone.com/reports/489146), где на узлах не было проверок авторизации, хотя на краях были).
- Используйте [Интерфейсы](https://graphql.org/learn/schema/#interfaces) и [Объединения](https://graphql.org/learn/schema/#union-types) для создания структурированных, иерархических типов данных, которые можно использовать для возврата большего или меньшего количества свойств объекта в зависимости от разрешений запрашивающего.
- [Resolvers](https://graphql.org/learn/execution/#root-fields-resolvers) запросов и мутаций могут использоваться для выполнения проверки контроля доступа, возможно, с использованием некоторого middleware RBAC.
- [Отключите запросы инвентаризации](https://lab.wallarm.com/why-and-how-to-disable-introspection-query-for-graphql-apis/) на уровне системы в любых производственных или общедоступных средах.
- Отключите [GraphiQL](https://github.com/graphql/graphiql) и другие подобные инструменты исследования схем в производственных или общедоступных средах.

### Общий Доступ к Данные

Часто запросы GraphQL содержат один или несколько идентификаторов объектов для получения или изменения их. Например, запрос к определенной картине может включать ID, который на самом деле является первичным ключом в базе данных для этой картины. Как и в любом запросе, сервер должен проверить, что вызывающий пользователь имеет доступ к объекту, который он запрашивает. Однако иногда разработчики ошибаются, полагая, что наличие ID объекта означает, что вызывающий пользователь должен иметь доступ. Неспособность проверить доступ пользователя в этом случае называется [Broken Object Level Authentication](https://github.com/OWASP/API-Security/blob/master/2019/en/src/0xa1-broken-object-level-authorization.md), также известным как [IDOR](Insecure_Direct_Object_Reference_Prevention_Cheat_Sheet.md).

API GraphQL может поддерживать доступ к объектам по их ID, даже если это не предусмотрено. Иногда в запросе могут быть поля `node` или `nodes`, или и то, и другое, и они могут использоваться для доступа к объектам напрямую по `ID`. Вы можете проверить, есть ли в вашей схеме такие поля, выполнив следующую команду в командной строке (предполагая, что `schema.json` содержит вашу схему GraphQL): `cat schema.json | jq ".data.__schema.types[] | select(.name==\"Query\") | .fields[] | .name" | grep node`. Удаление этих полей из схемы должно отключить функциональность, но всегда применяйте надлежащие проверки авторизации, чтобы убедиться, что вызывающий пользователь имеет доступ к запрашиваемому объекту.

### Доступ к Запросам (Получение Данных)

В рамках API GraphQL будут различные поля данных, которые могут быть возвращены. Нужно учитывать, хотите ли вы предоставить разные уровни доступа к этим полям. Например, вы можете захотеть, чтобы только определенные потребители могли получать определенные поля данных, а не разрешать всем потребителям получать все доступные поля. Это можно сделать, добавив проверку в код, чтобы убедиться, что запрашивающий пользователь может читать поле, которое он пытается получить.

### Доступ к Мутациям (Манипуляция Данными)

GraphQL поддерживает мутации, то есть манипуляцию данными, помимо наиболее распространенного использования для получения данных. Если API реализует/разрешает мутации, могут потребоваться меры контроля доступа, чтобы ограничить, какие потребители могут изменять данные через API. Настройки, требующие контроля доступа к мутациям, будут включать API, где предполагается только чтение для запрашивающих пользователей или где только определенные стороны должны иметь возможность изменять определенные поля.

### Атаки Сборки Запросов

GraphQL поддерживает сборку запросов, также известную как [batching запросов](https://www.apollographql.com/blog/query-batching-in-apollo-63acfd859862/). Это позволяет отправителям собирать несколько запросов или собирать запросы на несколько экземпляров объектов в одном сетевом вызове, что позволяет проводить так называемую [атаку на сборку](https://lab.wallarm.com/graphql-batching-attack/). Это форма атаки грубой силы, специфичная для GraphQL, которая обычно позволяет проводить более быстрые и менее заметные эксплойты. Вот самый распространенный способ сборки запросов:

```javascript
[
  {
    query: < query 0 >,
    variables: < variables for query 0 >,
  },
  {
    query: < query 1 >,
    variables: < variables for query 1 >,
  },
  {
    query: < query n >
    variables: < variables for query n >,
  }
]
```

Вот пример запроса единого собранного вызова GraphQL, запрашивающего несколько разных экземпляров объекта `droid`:

```javascript
query {
  droid(id: "2000") {
    name
  }
  second:droid(id: "2001") {
    name
  }
  third:droid(id: "2002") {
    name
  }
}
```

В этом случае это можно использовать для перечисления каждого возможного объекта `droid`, хранящегося на сервере, за очень небольшое количество сетевых запросов, в отличие от стандартного REST API, где запрашивающему пользователю нужно отправить отдельный сетевой запрос для каждого разных ID `droid`, который он хочет запросить. Этот тип атаки может привести к следующим проблемам:

- Атаки DoS на уровне приложения - большое количество запросов или запросов объектов в одном сетевом вызове может вызвать зависание базы данных или исчерпание других доступных ресурсов (_например_, память, CPU, вспомогательные сервисы).
- Перечисление объектов на сервере, таких как пользователи, электронные адреса и идентификаторы пользователей.
- Брутфорс паролей, кодов двухфакторной аутентификации (OTP), токенов сессии или других чувствительных значений.
- WAF, RASP, IDS/IPS, SIEM или другие средства безопасности, скорее всего, не обнаружат эти атаки, поскольку они выглядят как один единственный запрос, а не как большое количество сетевого трафика.
- Эта атака, вероятно, обойдет существующие ограничения частоты в таких инструментах, как Nginx или другие прокси/шлюзы, поскольку они ориентируются на количество запросов.

### Уменьшение Атак Сборки Запросов

Для смягчения этого типа атаки следует установить ограничения на входящие запросы на уровне кода, чтобы их можно было применять к каждому запросу. Существуют три основных варианта:

- Добавление ограничения скорости запросов объектов в коде
- Запрет сборки для чувствительных объектов
- Ограничение количества запросов, которые могут выполняться одновременно

Один из вариантов — создать ограничение на уровне кода по количеству объектов, которые вызывающие пользователи могут запросить. Это означает, что бэкенд будет отслеживать, сколько различных экземпляров объектов запросил вызывающий пользователь, и заблокирует его после запроса слишком большого количества объектов, даже если запросы объектов сгруппированы в одном сетевом вызове. Это имитирует ограничение скорости на уровне сети, которое выполнит WAF или другой инструмент.

Другой вариант — предотвратить сборку для чувствительных объектов, которые вы не хотите, чтобы их можно было атаковать методом грубой силы, таких как имена пользователей, электронные адреса, пароли, OTP, токены сессии и т. д. Таким образом, злоумышленник будет вынужден атаковать API, как REST API, и выполнять отдельный сетевой запрос для каждого экземпляра объекта. Это не поддерживается нативно, поэтому потребует создания кастомного решения. Однако, когда этот контроль введен, другие стандартные меры контроля будут нормально функционировать для предотвращения любой атаки методом грубой силы.

Ограничение количества операций, которые можно сгруппировать и выполнить одновременно, — еще один вариант для смягчения атак GraphQL сборки запросов, ведущих к DoS. Это не является панацеей и должно использоваться в сочетании с другими методами.

### Безопасные Конфигурации

По умолчанию большинство реализаций GraphQL имеют некоторые небезопасные конфигурации по умолчанию, которые следует изменить:

- Не возвращайте чрезмерное количество сообщений об ошибках (_например_, отключите трассировки стека и режим отладки).
- Отключите или ограничьте Introspection и GraphiQL в зависимости от ваших потребностей.
- Предложение неправильно набранных полей, если introspection отключен.

#### Introspection + GraphiQL

GraphQL часто поставляется по умолчанию с включенной introspection и/или GraphiQL и не требует аутентификации. Это позволяет потребителю вашего API узнать все о вашем API, схемах, мутациях, устаревших полях и иногда о нежелательных "частных полях".

Это может быть преднамеренная конфигурация, если ваш API предназначен для использования внешними клиентами, но может быть проблемой, если API предназначен только для внутреннего использования. Хотя безопасность через скрытие не рекомендуется, может быть полезно рассмотреть возможность удаления Introspection, чтобы избежать утечек информации.

Если ваш API публично используется, вы можете рассмотреть возможность отключения Introspection для неаутентифицированных или неавторизованных пользователей.

Для внутреннего API наиболее простой подход — просто отключить introspection по всему системе. Смотрите [эту страницу](https://lab.wallarm.com/why-and-how-to-disable-introspection-query-for-graphql-apis/) или проконсультируйтесь с документацией вашей реализации GraphQL, чтобы узнать, как полностью отключить introspection. Если ваша реализация не поддерживает отключение introspection нативно или если вы хотите разрешить некоторым пользователям/ролям иметь этот доступ, вы можете создать фильтр в вашем сервисе, чтобы разрешить доступ к introspection только для одобренных потребителей.

Имейте в виду, что даже если introspection отключен, злоумышленники все равно могут угадывать поля, используя метод грубой силы. Более того, GraphQL имеет встроенную функцию для возвращения подсказки, когда имя поля, предоставленное запрашивающим пользователем, похоже (но неверно) на существующее поле (_например_, запрос содержит `usr`, а ответ предложит `Возможно, вы имели в виду "user?"`). Вы должны рассмотреть возможность отключения этой функции, если вы отключили introspection, чтобы уменьшить уровень раскрытия, но не все реализации GraphQL поддерживают это. [Shapeshifter](https://github.com/szski/shapeshifter) — это инструмент, который [должен быть в состоянии сделать это](https://www.youtube.com/watch?v=NPDp7GHmMa0&t=2580).

### Отключение Introspection и GraphiQL

**Java**

Для отключения introspection в Java вы можете использовать следующий код:

```java
GraphQLSchema schema = GraphQLSchema.newSchema()
    .query(StarWarsSchema.queryType)
    .fieldVisibility(NoIntrospectionGraphqlFieldVisibility.NO_INTROSPECTION_FIELD_VISIBILITY)
    .build();
```

**JavaScript**

Для отключения introspection и GraphiQL в JavaScript используйте следующий код:

```javascript
app.use('/graphql', graphqlHTTP({
  schema: MySessionAwareGraphQLSchema,
  validationRules: [NoIntrospection],
  graphiql: process.env.NODE_ENV === 'development',
}));
```

### Не Возвращайте Чрезмерные Ошибки

В GraphQL API в продакшене не следует возвращать трассировки стека или находиться в режиме отладки. Это специфично для реализации, но использование middleware является популярным способом лучшего контроля над ошибками, которые возвращает сервер. 

Для [отключения чрезмерных ошибок](https://www.apollographql.com/docs/apollo-server/data/errors/) с Apollo Server, можно передать параметр `debug: false` конструктору Apollo Server или установить переменную окружения `NODE_ENV` в значение 'production' или 'test'. Если вы хотите записывать трассировки стека внутренне, но не возвращать их пользователю, см. [здесь](https://www.apollographql.com/docs/apollo-server/data/errors/#masking-and-logging-errors) для получения информации о том, как скрыть и записывать ошибки, чтобы они были доступны разработчикам, но не вызывающим API.

### Другие Ресурсы

**Инструменты**

- [InQL Scanner](https://github.com/doyensec/inql) - Скanner безопасности для GraphQL. Особенно полезен для автоматического создания запросов и мутаций на основе данной схемы и последующего их сканирования.
- [GraphiQL](https://github.com/graphql/graphiql) - Инструмент для исследования схем/объектов.
- [GraphQL Voyager](https://github.com/APIs-guru/graphql-voyager) - Инструмент для исследования схем/объектов.

**Практики Безопасности GraphQL и Документация**

- [Защита GraphQL API от угроз безопасности - блог пост](https://medium.com/swlh/protecting-your-graphql-api-from-security-vulnerabilities-e8afdfa6fbe4)
- [https://nordicapis.com/security-points-to-consider-before-implementing-graphql/](https://nordicapis.com/security-points-to-consider-before-implementing-graphql/)
- [Ограничение использования ресурсов для предотвращения DoS (тайм-ауты, троттлинг, управление сложностью, ограничение глубины и т. д.)](https://developer.github.com/v4/guides/resource-limitations/)
- [Перспективы безопасности GraphQL](https://www.abhaybhargav.com/from-the-trenches-diy-security-perspectives-of-graphql/)
- [Безопасность GraphQL с точки зрения разработчика](https://planes.studio/blog/how-to-survive-a-penetration-test-as-a-graph-ql-developer)

**Дополнительная Информация о Атаках на GraphQL**

- [Некоторые распространенные атаки на GraphQL + мышление злоумышленников](https://blog.doyensec.com/2018/05/17/graphql-security-overview.html)
- [Обход разрешений путем подмены параметров](https://labs.detectify.com/2018/03/14/graphql-abuse/)
- [Запись о баунти-баге на GraphQL](https://medium.com/bugbountywriteup/graphql-voyager-as-a-tool-for-security-testing-86d3c634bcd9)
- [Доклад по безопасности об эксплуатации GraphQL](https://www.youtube.com/watch?v=NPDp7GHmMa0)
- [Реальные](https://vulners.com/myhack58/MYHACK58:62201994269) [мировые](https://www.pentestpartners.com/security-blog/pwning-wordpress-graphql/) [атаки](https://hackerone.com/reports/419883) [на](https://vulners.com/hackerone/H1:435066) [GraphQL](https://www.jonbottarini.com/2018/01/02/abusing-internal-api-to-achieve-idor-in-new-relic/) [в](https://about.gitlab.com/blog/2019/07/03/security-release-gitlab-12-dot-0-dot-3-released/#authorization-issues-in-graphql) прошлом
- [Примеры атак на GraphQL](https://raz0r.name/articles/looting-graphql-endpoints-for-fun-and-profit/)
