# Шпаргалка по валидации ввода

## Введение

Эта статья посвящена предоставлению ясных, простых и действенных рекомендаций по обеспечению функциональности проверки ввода в ваших приложениях.

## Цели проверки ввода

Проверка ввода выполняется для того, чтобы обеспечить поступление только корректно сформированных данных в рабочий процесс информационной системы, предотвращая сохранение некорректных данных в базе данных и сбои в работе различных компонентов. Проверка ввода должна происходить как можно раньше в потоке данных, желательно сразу после получения данных от внешней стороны.

Данные из всех потенциально ненадежных источников должны подвергаться проверке ввода, включая не только веб-клиентов, доступных через интернет, но и бэкэнд-потоки через экстранеки, от [поставщиков, партнеров, поставщиков или регуляторов](https://badcyber.com/several-polish-banks-hacked-information-stolen-by-unknown-attackers/), каждый из которых может быть скомпрометирован и начать отправлять некорректные данные.

Проверка ввода не должна использоваться как *основной* метод предотвращения [XSS](Cross_Site_Scripting_Prevention_Cheat_Sheet.md), [SQL-инъекций](SQL_Injection_Prevention_Cheat_Sheet.md) и других атак, которые рассматриваются в соответствующих [шпаргалках](https://cheatsheetseries.owasp.org/), но может значительно помочь в снижении их воздействия при правильной реализации.

## Стратегии проверки ввода

Проверка ввода должна применяться как на синтаксическом, так и на семантическом уровнях:

- **Синтаксическая** проверка должна обеспечивать корректность синтаксиса структурированных полей (например, ИНН, дата, символ валюты).
- **Семантическая** проверка должна обеспечивать правильность их *значений* в конкретном бизнес-контексте (например, дата начала до даты окончания, цена в ожидаемом диапазоне).

Всегда рекомендуется предотвращать атаки как можно раньше в процессе обработки запроса пользователя (атаки). Проверка ввода может использоваться для обнаружения несанкционированного ввода до его обработки приложением.

## Реализация проверки ввода

Проверка ввода может быть реализована с использованием любой программной техники, которая позволяет эффективно обеспечивать синтаксическую и семантическую корректность, например:

- Валидаторы типов данных, доступные в фреймворках веб-приложений (например, [Django Validators](https://docs.djangoproject.com/en/1.11/ref/validators/), [Apache Commons Validators](https://commons.apache.org/proper/commons-validator/apidocs/org/apache/commons/validator/package-summary.html#doc.Usage.validator) и т.д.).
- Проверка соответствия [JSON Schema](http://json-schema.org/) и [XML Schema (XSD)](https://www.w3schools.com/xml/schema_intro.asp) для ввода в этих форматах.
- Преобразование типов (например, `Integer.parseInt()` в Java, `int()` в Python) с строгой обработкой исключений.
- Проверка диапазона минимальных и максимальных значений для числовых параметров и дат, проверка минимальной и максимальной длины строк.
- Массив разрешенных значений для небольших наборов строковых параметров (например, дни недели).
- Регулярные выражения для любых других структурированных данных, охватывающие всю строку ввода `(^...$)` и **не** использующие подстановочный знак "любой символ" (например, `.` или `\S`).

### Allowlist vs Denylist

Обычная ошибка заключается в использовании denylist (черного списка) для попытки обнаружения потенциально опасных символов и шаблонов, таких как апостроф `'`, строка `1=1` или тег `<script>`. Однако это крайне неэффективный подход, так как злоумышленник легко может обойти такие фильтры.

Кроме того, такие фильтры часто блокируют допустимый ввод, например `O'Brian`, где символ `'` абсолютно легален. Для получения дополнительной информации об обходе фильтров XSS см. [этую страницу вики](https://owasp.org/www-community/xss-filter-evasion-cheatsheet).

Проверка по allowlist (белому списку) подходит для всех полей ввода, предоставленных пользователем. Проверка по allowlist включает в себя определение точно того, что ДОПУСКАЕТСЯ, и, по определению, все остальное не допускается.

Если это хорошо структурированные данные, такие как даты, номера социального страхования, почтовые индексы, адреса электронной почты и т.д., то разработчик должен быть в состоянии определить очень строгий шаблон проверки, обычно основанный на регулярных выражениях, для проверки такого ввода.

Если поле ввода выбирается из фиксированного набора опций, например, выпадающий список или радиокнопки, то ввод должен точно соответствовать одному из значений, предложенных пользователю.

### Проверка произвольного текста Unicode

Произвольный текст, особенно с символами Unicode, воспринимается как трудный для проверки из-за относительно большого пространства символов, которые нужно разрешить.

Также произвольный текстовый ввод подчеркивает важность правильного кодирования вывода с учетом контекста и ясно демонстрирует, что проверка ввода **не является** основной защитой от Cross-Site Scripting. Если ваши пользователи хотят ввести апостроф `'` или знак меньше `<` в поле комментария, у них могут быть абсолютно легитимные причины для этого, и задача приложения — правильно обработать это на протяжении всего жизненного цикла данных.

Основные методы проверки ввода для произвольного текстового ввода должны включать:

- **Нормализация:** Убедитесь, что используется каноническое кодирование по всему тексту и нет недопустимых символов.
- **Allowlisting категории символов:** Unicode позволяет перечислять категории, такие как "десятичные цифры" или "буквы", которые охватывают не только латинский алфавит, но и различные другие скрипты, используемые по всему миру (например, арабский, кириллицу, китайские иероглифы и т.д.).
- **Allowlisting отдельных символов:** Если вы позволяете буквы и иероглифы в именах и также хотите разрешить апостроф `'` для ирландских имен, но не хотите разрешать всю категорию пунктуации.

Ссылки:

- [Проверка ввода произвольного текста Unicode в Python](https://web.archive.org/web/20170717174432/https://ipsec.pl/python/2017/input-validation-free-form-unicode-text-python.html/)
- [UAX 31: Синтаксис идентификаторов и шаблонов Unicode](https://unicode.org/reports/tr31/)
- [UAX 15: Формы нормализации Unicode](https://www.unicode.org/reports/tr15/)
- [UAX 24: Свойство скрипта Unicode](https://unicode.org/reports/tr24/)

### Регулярные выражения (Regex)

Разработка регулярных выражений может быть сложной задачей и выходит за рамки этого чек-листа.

Существует множество ресурсов в интернете, которые могут помочь в написании регулярных выражений, включая [этот сайт](https://www.regular-expressions.info/) и [Репозиторий регулярных выражений OWASP](https://owasp.org/www-community/OWASP_Validation_Regex_Repository).

При проектировании регулярных выражений будьте внимательны к [атакам Denial of Service (ReDoS) на регулярные выражения](https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS). Эти атаки могут заставить программу, использующую плохо спроектированное регулярное выражение, работать очень медленно и потреблять ресурсы процессора длительное время.

В общем, проверка ввода должна:

- Применяться ко всем входным данным как минимум.
- Определять допустимый набор символов.
- Определять минимальную и максимальную длину данных (например, `{1,25}`).

## Примеры регулярных выражений для Allow List

Проверка почтового индекса США (5 цифр плюс необязательные -4)

```text
^\d{5}(-\d{4})?$
```

Проверка выбора штата США из выпадающего списка

```text
^(AA|AE|AP|AL|AK|AS|AZ|AR|CA|CO|CT|DE|DC|FM|FL|GA|GU|
HI|ID|IL|IN|IA|KS|KY|LA|ME|MH|MD|MA|MI|MN|MS|MO|MT|NE|
NV|NH|NJ|NM|NY|NC|ND|MP|OH|OK|OR|PW|PA|PR|RI|SC|SD|TN|
TX|UT|VT|VI|VA|WA|WV|WI|WY)$
```

**Пример использования Regex в Java:**

Пример проверки параметра "zip" с использованием регулярного выражения.

```java
private static final Pattern zipPattern = Pattern.compile("^\d{5}(-\d{4})?$");

public void doPost(HttpServletRequest request, HttpServletResponse response) {
  try {
      String zipCode = request.getParameter("zip");
      if (!zipPattern.matcher(zipCode).matches()) {
          throw new YourValidationException("Неверный формат почтового индекса.");
      }
      // Продолжайте обработку после проверки
  } catch (YourValidationException e) {
      response.sendError(response.SC_BAD_REQUEST, e.getMessage());
  }
}
```

Некоторые валидаторы Allowlist также уже предопределены в различных открытых исходных пакетах, которые вы можете использовать. Например:

- [Apache Commons Validator](http://commons.apache.org/proper/commons-validator/)

## Валидация на стороне клиента и на стороне сервера

Валидация ввода **должна** быть реализована на стороне сервера перед обработкой данных функциями приложения, так как валидация ввода на стороне клиента, выполненная на основе JavaScript, может быть обойдена атакующим, который отключает JavaScript или использует веб-прокси. Рекомендуется использовать как валидацию на стороне клиента для удобства пользователя, так и валидацию на стороне сервера для безопасности, используя каждую из них для их соответствующих целей.

## Валидация богатого пользовательского контента

Очень трудно валидировать богатый контент, отправляемый пользователем. Для получения дополнительной информации см. раздел о XSS на [Чек-лист по очистке HTML-разметки с использованием специализированной библиотеки](Cross_Site_Scripting_Prevention_Cheat_Sheet.md).

## Предотвращение XSS и Политика безопасности контента

Все данные, контролируемые пользователем, должны быть закодированы при возвращении на HTML-странице, чтобы предотвратить выполнение вредоносных данных (например, XSS). Например, `<script>` будет возвращен как `&lt;script&gt;`.

Тип кодирования специфичен для контекста страницы, где вставляются данные, контролируемые пользователем. Например, HTML-сущностное кодирование подходит для данных, размещенных в теле HTML. Однако данные пользователя, размещенные в скрипте, потребуют специфического для JavaScript кодирования вывода.

Подробную информацию о предотвращении XSS можно найти здесь: [OWASP Чек-лист по предотвращению XSS](Cross_Site_Scripting_Prevention_Cheat_Sheet.md).

## Валидация загрузки файлов

Многие веб-сайты позволяют пользователям загружать файлы, такие как фотографии профиля и другие. Этот раздел поможет обеспечить безопасное использование этой функции.

Проверьте [Чек-лист по загрузке файлов](File_Upload_Cheat_Sheet.md).

### Проверка загрузки

- Используйте валидацию ввода, чтобы убедиться, что загружаемое имя файла имеет ожидаемое расширение.
- Убедитесь, что загружаемый файл не превышает заданный максимальный размер файла.
- Если сайт поддерживает загрузку ZIP-файлов, выполните проверку перед распаковкой файла. Проверка включает целевой путь, уровень сжатия, оценочный размер после распаковки.

### Хранение загруженных файлов

- Используйте новое имя файла для хранения на ОС. Не используйте текст, контролируемый пользователем, для этого имени файла или для временного имени файла.
- Когда файл загружается на веб-сайт, рекомендуется переименовать файл на хранилище. Например, загружаемое имя файла *test.JPG* можно переименовать в *JAI1287uaisdjhf.JPG* с помощью случайного имени файла. Цель этого — предотвратить риски прямого доступа к файлу и неясные имена файлов, чтобы обойти фильтр, такие как `test.jpg;.asp` или `/../../../../../test.jpg`.
- Загруженные файлы должны быть проанализированы на наличие вредоносного содержимого (антивирус, статический анализ и т. д.).
- Путь к файлу не должен указываться со стороны клиента. Он определяется на стороне сервера.

### Публичное размещение загруженного контента

- Убедитесь, что загруженные изображения обслуживаются с правильным типом контента (например, image/jpeg, application/x-xpinstall).

### Остерегайтесь определенных типов файлов

Функция загрузки должна использовать подход с allowlist, чтобы разрешить только определенные типы файлов и расширения. Однако важно учитывать следующие типы файлов, которые, если их разрешить, могут привести к уязвимостям безопасности:

- **crossdomain.xml** / **clientaccesspolicy.xml:** позволяют загрузку данных между доменами в Flash, Java и Silverlight. Если это разрешено на сайтах с аутентификацией, это может позволить кражу данных между доменами и атаки CSRF. Обратите внимание, что это может быть довольно сложным в зависимости от конкретной версии плагина, поэтому лучше просто запретить файлы с именем "crossdomain.xml" или "clientaccesspolicy.xml".
- **.htaccess** и **.htpasswd:** предоставляют параметры конфигурации сервера для каждой директории и не должны разрешаться. См. [документацию HTACCESS](http://en.wikipedia.org/wiki/Htaccess).
- Веб-исполняемые скрипты, такие как `aspx, asp, css, swf, xhtml, rhtml, shtml, jsp, js, pl, php, cgi`, рекомендуется не разрешать.

### Проверка загрузки изображений

- Используйте библиотеки переписывания изображений для проверки их валидности и удаления лишнего контента.
- Установите расширение сохраненного изображения в соответствии с действительным расширением изображения на основе определенного типа контента изображения из обработки изображений (например, не доверяйте только заголовку из загрузки).
- Убедитесь, что определенный тип контента изображения находится в списке допустимых типов изображений (jpg, png и т. д.).

## Валидация адреса электронной почты

### Синтаксическая валидация

Формат адресов электронной почты определяется [RFC 5321](https://tools.ietf.org/html/rfc5321#section-4.1.2) и значительно сложнее, чем большинство людей предполагают. Например, следующие адреса считаются допустимыми:

- `"><script>alert(1);</script>"@example.org`
- `user+subaddress@example.org`
- `user@[IPv6:2001:db8::1]`
- `" "@example.org`

Правильный анализ адресов электронной почты на корректность с помощью регулярных выражений очень сложен, хотя есть ряд [доступных документов по regex](https://datatracker.ietf.org/doc/html/draft-seantek-mail-regexen-03#rfc.section.3).

Самое большое предостережение заключается в том, что хотя RFC определяет очень гибкий формат для адресов электронной почты, большинство реальных реализаций (таких как почтовые серверы) используют гораздо более ограниченный формат адреса, что означает, что они будут отклонять адреса, которые *технически* являются корректными. Хотя они могут быть технически правильными, такие адреса мало полезны, если ваше приложение не сможет отправить на них электронные письма.

Таким образом, лучший способ валидации адресов электронной почты — это выполнить базовую начальную валидацию, а затем передать адрес почтовому серверу и поймать исключение, если он его отклонит. Это означает, что приложение может быть уверено, что его почтовый сервер может отправлять электронные письма на любые принятые адреса. Начальная валидация может быть простой, как:

- Адрес электронной почты содержит две части, разделенные символом `@`.
- Адрес электронной почты не содержит опасных символов (таких как обратные кавычки, одинарные или двойные кавычки, или нулевые байты).
    - Какие именно символы являются опасными, будет зависеть от того, как адрес будет использоваться (выводится на страницу, вставляется в базу данных и т. д.).
- Часть домена содержит только буквы, цифры, дефисы (`-`) и точки (`.`).
- Адрес электронной почты имеет разумную длину:
    - Локальная часть (до `@`) не должна превышать 63 символов.
    - Общая длина не должна превышать 254 символа.

### Семантическая валидация

Семантическая валидация направлена на определение правильности и легитимности адреса электронной почты. Наиболее распространенный способ сделать это — отправить пользователю письмо и потребовать, чтобы он кликнул по ссылке в письме или ввел код, который был отправлен ему. Это предоставляет базовый уровень уверенности в том, что:

- Адрес электронной почты корректен.
- Приложение может успешно отправлять на него электронные письма.
- Пользователь имеет доступ к почтовому ящику.

Ссылки, отправляемые пользователям для подтверждения прав на адрес, должны содержать токен, который:

- Длиной не менее 32 символов.
- Сгенерирован с использованием [безопасного источника случайности](Cryptographic_Storage_Cheat_Sheet.md#secure-random-number-generation).
- Используется один раз.
- Ограничен по времени (например, истекает через восемь часов).

После проверки прав на адрес электронной почты пользователю следует пройти аутентификацию в приложении через обычный механизм.

#### Одноразовые адреса электронной почты

В некоторых случаях пользователи могут не захотеть предоставлять свой настоящий адрес электронной почты при регистрации в приложении и вместо этого предоставить одноразовый адрес электронной почты. Эти адреса являются общедоступными и не требуют от пользователя аутентификации, обычно они используются для сокращения количества спама, получаемого на основной адрес электронной почты пользователя.

Блокировка одноразовых адресов электронной почты почти невозможна, так как существует множество сайтов, предлагающих такие услуги, и каждый день создаются новые домены. Существует несколько общедоступных списков и коммерческих списков известных одноразовых доменов, но они всегда будут неполными.

Если эти списки используются для блокировки одноразовых адресов электронной почты, пользователю следует предоставить сообщение, объясняющее причину блокировки (хотя он, вероятно, просто найдет другого поставщика одноразовых адресов, а не предоставит свой настоящий адрес).

Если необходимо заблокировать одноразовые адреса электронной почты, то регистрации следует разрешать только от специально разрешенных провайдеров электронной почты. Однако, если это включает в себя публичные провайдеры, такие как Google или Yahoo, пользователи могут просто зарегистрировать свой собственный одноразовый адрес у них.

#### Подадресация

Подадресация позволяет пользователю указать *тег* в локальной части адреса электронной почты (до знака `@`), который будет игнорироваться почтовым сервером. Например, если домен `example.org` поддерживает подадресацию, то следующие адреса электронной почты эквивалентны:

- `user@example.org`
- `user+site1@example.org`
- `user+site2@example.org`

Многие почтовые провайдеры (например, Microsoft Exchange) не поддерживают подадресацию. Наиболее заметный провайдер, который это делает, — Gmail, хотя есть и многие другие.

Некоторые пользователи будут использовать разные *теги* для каждого сайта, на котором они регистрируются, чтобы, если они начнут получать спам на один из подадресов, они могли определить, какой сайт утек или продал их адрес электронной почты.

Поскольку это может позволить пользователям регистрировать несколько аккаунтов с одним адресом электронной почты, некоторые сайты могут пожелать заблокировать подадресацию, удаляя все между знаками `+` и `@`. Это обычно не рекомендуется, так как это предполагает, что владелец сайта либо не осведомлен о подадресации, либо хочет предотвратить идентификацию их при утечке или продаже адресов электронной почты. Кроме того, это можно легко обойти, используя [одноразовые адреса электронной почты](#disposable-email-addresses) или просто регистрируя несколько учетных записей электронной почты у доверенного провайдера.

## Источники

- [OWASP Top 10 Proactive Controls 2024: C3: Validate all Input & Handle Exceptions](https://owasp.org/www-project-proactive-controls/v4/en/c3-validate-all-input)
- [CWE-20 Improper Input Validation](https://cwe.mitre.org/data/definitions/20.html)
- [OWASP Top 10 2021: A03:2021-Injection](https://owasp.org/Top10/A03_2021-Injection/)
- [Snyk: Improper Input Validation](https://learn.snyk.io/lesson/improper-input-validation/)
