# Шпаргалка по предотвращению подделки межсайтовых запросов

## Введение

Атака [Cross-Site Request Forgery (CSRF)](https://owasp.org/www-community/attacks/csrf) происходит, когда вредоносный веб-сайт, электронная почта, блог, мгновенное сообщение или программа обманывают веб-браузер аутентифицированного пользователя, заставляя его выполнить нежелательное действие на доверенном сайте. Если целевой пользователь аутентифицирован на сайте, незащищенные целевые сайты не могут отличить законные авторизованные запросы от поддельных аутентифицированных запросов.

Поскольку запросы браузера автоматически включают все cookies, включая сессионные, эта атака работает, если не используется надлежащая авторизация, то есть механизм "вызов-ответ" целевого сайта не проверяет личность и полномочия запрашивающего. По сути, CSRF-атаки заставляют целевую систему выполнять заданные злоумышленником функции через браузер жертвы без ее ведома (обычно до момента совершения несанкционированных действий).

Однако успешные CSRF-атаки могут использовать только возможности, открытые уязвимым приложением, и привилегии пользователя. В зависимости от учетных данных пользователя злоумышленник может перевести средства, изменить пароль, совершить несанкционированную покупку, повысить привилегии целевой учетной записи или выполнить любое действие, разрешенное пользователю.

В общем, для защиты от CSRF следует придерживаться следующих принципов:

**ВАЖНО: Помните, что межсайтовый скриптинг (XSS) может победить все методы защиты от CSRF!**

- **Подробное руководство по предотвращению XSS-атак см. в OWASP [XSS Prevention Cheat Sheet](Cross_Site_Scripting_Prevention_Cheat_Sheet.md)**.
- **Сначала проверьте, есть ли в вашем фреймворке [встроенная защита от CSRF](#используйте-встроенные-или-существующие-реализации-CSRF-для-защиты-от-CSRF), и используйте ее**.
- **Если фреймворк не имеет встроенной CSRF-защиты, добавьте [CSRF-токены](#защита-на-основе-токенов) ко всем запросам, изменяющим состояние (запросы, вызывающие действия на сайте), и проверьте их на бэкенде**.
- **Государственное программное обеспечение должно использовать шаблон [синхронизатора токенов](#synchronizer-token-pattern)**.
- **Бесплатные программы должны использовать [двойные файлы cookie](#alternative-using-a-double-submit-cookie-pattern)**.
- **Если сайт, управляемый API, не может использовать теги `<form>`, рассмотрите возможность [использования пользовательских заголовков запроса] (#employing-custom-request-headers-for-ajaxapi)**.
- **Воспользуйтесь хотя бы одним средством защиты из раздела [Defense in Depth Mitigations](#defense-in-depth-techniques)**.
- **[SameSite Cookie Attribute](#атрибут-cookie-SameSite) можно использовать для сессионных cookie**, но будьте осторожны и НЕ устанавливайте cookie специально для домена. Это действие создает уязвимость в безопасности, поскольку все поддомены этого домена будут совместно использовать cookie, и это особенно важно, если поддомен имеет CNAME для доменов, не находящихся под вашим контролем.
- **Рассмотрите возможность внедрения [защиты на основе взаимодействия с пользователем](#user-interaction-based-csrf-defense) для высокочувствительных операций**.
- **Рассмотрите [проверку происхождения с помощью стандартных заголовков](#verifying-origin-with-standard-headers)**.
- **Не используйте GET-запросы для операций изменения состояния**.
- **Если по какой-то причине вы это сделаете, защитите эти ресурсы от CSRF**.

## Защита на основе токенов

Шаблон [токенов синхронизатора](#Шаблон-токенов-синхронизатора) - один из самых популярных и рекомендуемых методов борьбы с CSRF.

### Используйте встроенные или существующие реализации CSRF для защиты от CSRF

Поскольку защита от синхронизации токенов встроена во многие фреймворки, узнайте, есть ли в вашем фреймворке защита от CSRF по умолчанию, прежде чем создавать собственную систему генерации токенов. Например, .NET может использовать [встроенную защиту](https://docs.microsoft.com/en-us/aspnet/core/security/anti-request-forgery?view=aspnetcore-2.1) для добавления токенов к CSRF-уязвимым ресурсам. Если вы решите использовать эту защиту, .NET возложит на вас ответственность за правильную настройку (например, управление ключами и токенами).

### Шаблон токенов синхронизатора

CSRF-токены должны генерироваться на стороне сервера и только один раз за сессию пользователя или каждый запрос. Поскольку временной диапазон, в течение которого злоумышленник может воспользоваться украденными токенами, минимален для токенов на каждый запрос, они более безопасны, чем токены на каждую сессию. Однако использование токенов для каждого запроса может привести к проблемам с удобством использования.

Например, возможности браузера по нажатию кнопки "Назад" могут быть затруднены маркером для каждого запроса, поскольку предыдущая страница может содержать маркер, который уже недействителен. В этом случае взаимодействие с предыдущей страницей приведет к ложному срабатыванию CSRF на стороне сервера. Если реализация токена для каждой сессии происходит после первоначальной генерации токена, его значение сохраняется в сессии и используется для каждого последующего запроса до тех пор, пока сессия не истечет.

Когда клиент отправляет запрос, серверный компонент должен проверить наличие и действительность токена в запросе и сравнить его с токеном, найденным в пользовательской сессии. Запрос должен быть отклонен, если токен не был найден в запросе или предоставленное значение не совпадает со значением в пользовательской сессии. Также следует рассмотреть дополнительные действия, такие как регистрация события как потенциальной CSRF-атаки.

CSRF-токены должны быть:

- Уникальны для каждой сессии пользователя.
- Секретны
- Непредсказуемы (большое случайное значение, сгенерированное [безопасным методом](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#rule---use-cryptographically-secure-pseudo-random-number-generators-csprng)).

CSRF-токены предотвращают CSRF, поскольку без CSRF-токена злоумышленник не может создавать корректные запросы к внутреннему серверу.

#### Передача CSRF-токенов в синхронизированных шаблонах

Токен CSRF может быть передан клиенту как часть полезной нагрузки ответа, например HTML- или JSON-ответа, затем он может быть передан обратно на сервер как скрытое поле при отправке формы или через AJAX-запрос как значение пользовательского заголовка или часть полезной нагрузки JSON. Токен CSRF не должен передаваться в cookie для синхронизированных шаблонов. Токен CSRF не должен попадать в журналы сервера или в URL. GET-запросы могут потенциально передавать токены CSRF в несколько мест, таких как история браузера, файлы журналов, сетевые утилиты, которые регистрируют первую строку HTTP-запроса, и заголовки Referer, если защищенный сайт ссылается на внешний сайт.

Например:

```html
<form action="/transfer.do" method="post">.
<input type="hidden" name="CSRFToken" value="OWY4NmQwODE4ODRjN2Q2NTlhMmZlYWEwYzU1YWQwMTVhM2JmNGYxYjJiMGI4MjJJZDE1ZDZMGYwMGEwOA==">.
[...]
</form>
```

Поскольку запросы с пользовательскими заголовками автоматически подчиняются политике same-origin, вставлять CSRF-токен в пользовательский заголовок HTTP-запроса с помощью JavaScript более безопасно, чем добавлять CSRF-токен в параметр формы скрытого поля.

### АЛЬТЕРНАТИВА: Использование шаблона cookie с двойной отправкой

Если хранить состояние CSRF-токена на сервере проблематично, вы можете использовать альтернативную технику, известную как шаблон Double Submit Cookie. Эта техника проста в реализации и не имеет состояния. Существуют различные способы реализации этой техники, наиболее часто используемым вариантом является паттерн _naive_.

#### Подписанные файлы cookie с двойной передачей (РЕКОМЕНДУЕТСЯ)

Наиболее безопасной реализацией шаблона Double Submit Cookie является _Signed Double-Submit Cookie_, который использует секретный ключ, известный только серверу. Это гарантирует, что злоумышленник не сможет создать и внедрить свой собственный, известный ему CSRF-токен в аутентифицированную сессию жертвы. Токены системы должны быть защищены путем хэширования или шифрования.

Мы настоятельно рекомендуем использовать алгоритм аутентификации сообщений на основе хэша (HMAC), поскольку он требует меньше вычислительных затрат, чем шифрование и расшифровка куки. Также следует связать маркер CSRF с текущей сессией пользователя, чтобы еще больше повысить безопасность.

##### Использование HMAC CSRF-токенов

Для генерации HMAC CSRF-токенов (со значением пользователя, зависящим от сессии) система должна иметь:

- **Зависимое от сеанса значение, которое меняется при каждом сеансе входа**. Это значение должно быть действительно только в течение всего сеанса аутентификации пользователя. Избегайте использования статических значений, таких как email или ID пользователя, так как они небезопасны ([1](https://stackoverflow.com/a/8656417) | [2](https://stackoverflow.com/a/30539335) | [3](https://security.stackexchange.com/a/22936)). Стоит отметить, что слишком частое обновление CSRF-токена, например, при каждом запросе, - это заблуждение, предполагающее, что это добавляет существенную безопасность, а на самом деле вредит пользовательскому опыту ([1](https://security.stackexchange.com/a/22936)). Например, вы можете выбрать одно из следующих значений, зависящих от сессии:
    - Идентификатор сессии на стороне сервера (например, [PHP](https://www.php.net/manual/en/function.session-start.php) или [ASP.NET](<https://learn.microsoft.com/en-us/previous-versions/aspnet/ms178581(v=vs.100)>)).
    - Случайное значение (например, UUID) в JWT, которое меняется каждый раз, когда создается JWT.
- **Секретный криптографический ключ** Не путать со случайным значением из наивной реализации. Это значение используется для генерации хэша HMAC. В идеале хранить этот ключ следует так, как описано на странице [Cryptographic Storage page](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#key-storage).
- **Случайное значение для защиты от коллизий**. Генерируйте случайное значение (предпочтительно криптографически случайное), чтобы последовательные вызовы в течение одной секунды не приводили к одинаковому хэшу ([1](https://github.com/data-govt-nz/ckanext-security/issues/23#issuecomment-479752531)).

**Нужно ли включать временные метки в CSRF-токены для определения срока действия?

Это распространенное заблуждение - включать временные метки в качестве значения для определения времени истечения срока действия CSRF-токена. Токен CSRF не является маркером доступа. Они используются для проверки подлинности запросов в течение сессии, используя информацию о сессии. При новой сессии должен генерироваться новый токен ([1](https://stackoverflow.com/a/30539335)).

##### Псевдокод для реализации HMAC CSRF-токенов

Ниже приведен пример в псевдокоде, демонстрирующий описанные выше шаги реализации:

```code
// Соберите значения
secret = readEnvironmentVariable("CSRF_SECRET") // секретный ключ HMAC
sessionID = session.sessionID // Текущая аутентифицированная сессия пользователя
randomValue = cryptographic.randomValue() // Криптографическая случайная величина

// Создание CSRF-токена
message = sessionID + "!" + randomValue // полезная нагрузка сообщения HMAC
hmac = hmac("SHA256", secret, message) // Генерируем хэш HMAC
csrfToken = hmac + "." + message // Объедините HMAC-хэш с сообщением, чтобы сгенерировать токен. Открытое сообщение необходимо для последующей аутентификации по его HMAC-хэшу

// Храните токен CSRF в файле cookie
response.setCookie("csrf_token=" + csrfToken + "; Secure") // Установка Cookie без флага HttpOnly
```

### Naive Double-Submit Cookie (Рекомендуется)

Метод _Naive Double-Submit Cookie_ - это масштабируемая и простая в реализации техника, которая использует криптографически сильное случайное значение в качестве cookie и параметра запроса (еще до аутентификации пользователя). Затем сервер проверяет, совпадают ли значение cookie и значение запроса. Сайт должен требовать, чтобы каждый запрос на транзакцию от пользователя включал это случайное значение в качестве скрытого значения формы или внутри заголовка запроса. Если значение совпадает на стороне сервера, сервер принимает его как легитимный запрос, а если нет, то отклоняет запрос.

Поскольку злоумышленник не может получить доступ к значению cookie во время межсайтового запроса, он не может включить соответствующее значение в скрытое значение формы или в качестве параметра/заголовка запроса.

Хотя метод Naive Double-Submit Cookie является хорошим начальным шагом в борьбе с CSRF, он все еще остается уязвимым для некоторых атак. [Этот ресурс](https://owasp.org/www-chapter-london/assets/slides/David_Johansson-Double_Defeat_of_Double-Submit_Cookie.pdf) предоставляет более подробную информацию о некоторых уязвимостях. Таким образом, мы настоятельно рекомендуем использовать шаблон _Подписанный файл cookie с двойной отправкой_.

## Запрет простых запросов

Когда тег `<form>` используется для отправки данных, он отправляет ["простой" запрос](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple_requests), который браузеры не определяют как "подлежащий предварительной проверке". Такие "простые" запросы создают риск CSRF, поскольку браузеры позволяют отправлять их в любое место происхождения. Если ваше приложение использует теги `<form>` для отправки данных в любом месте клиента, вам все равно придется защищать их с помощью альтернативных подходов, описанных в этом документе, таких как токены.

> **Предупреждение:**
Если ошибка в браузере позволит использовать пользовательские HTTP-заголовки или не обеспечит предварительную подсветку для нестандартных типов контента, это может поставить под угрозу вашу безопасность. Хотя это и маловероятно, следует учесть это в своей модели угроз. Реализация CSRF-токенов добавляет дополнительный уровень защиты и дает разработчикам больше контроля над безопасностью приложения.

### Запрет простых типов контента

Чтобы запрос считался простым, он должен иметь один из следующих типов содержимого - `application/x-www-form-urlencoded`, `multipart/form-data` или `text/plain`.  Многие современные веб-приложения используют JSON API, поэтому, естественно, требуют CORS, однако они могут принимать `text/plain`, который будет уязвим для CSRF. Поэтому простым средством защиты является запрет сервером или API этих простых типов содержимого.

### Использование пользовательских заголовков запросов для AJAX API

Для предотвращения подделки данных формы используются токен синхронизации и cookie двойной отправки, но их реализация может быть сложной и ухудшать удобство использования. Многие современные веб-приложения не используют теги `<form>` для отправки данных. Удобный способ защиты, который особенно хорошо подходит для AJAX или конечных точек API, - это использование **заголовка пользовательского запроса**. При таком подходе токен не нужен.

В этом шаблоне клиент добавляет пользовательский заголовок к запросам, требующим защиты от CSRF. Заголовок может представлять собой любую произвольную пару ключ-значение, если он не конфликтует с существующими заголовками.

```
X-YOURSITE-CSRF-PROTECTION=1
```

При обработке запроса API проверяет наличие этого заголовка. Если заголовок не существует, бэкэнд отклоняет запрос как потенциальную подделку. Такой подход имеет несколько преимуществ:

- Изменения пользовательского интерфейса не требуются
- Для отслеживания токенов не вводится состояние сервера

Эта защита основана на механизме CORS preflight, который отправляет запрос `OPTIONS` для проверки соответствия CORS на сервере назначения. Все современные браузеры обозначают запросы с пользовательскими заголовками как "подлежащие префлайту". Когда API проверяет наличие пользовательского заголовка, вы знаете, что запрос должен быть предварительно засвечен, если он пришел от браузера.

#### Пользовательские заголовки и CORS

По умолчанию куки не устанавливаются на кросс-оригинальные запросы (CORS). Чтобы включить cookies в API, нужно установить `Access-Control-Allow-Credentials=true`. Браузер отклонит любой ответ, содержащий `Access-Control-Allow-Origin=*`, если учетные данные разрешены. Чтобы разрешить CORS-запросы, но защитить их от CSRF, вам нужно убедиться, что сервер разрешает только несколько избранных источников, которые вы точно контролируете с помощью заголовка `Access-Control-Allow-Origin`. Любой кросс-оригинальный запрос с разрешенного домена сможет установить пользовательские заголовки.

Например, вы можете настроить свой бэкэнд на разрешение CORS с cookies от `http://www.yoursite.com` и `http://mobile.yoursite.com`, так что единственными возможными ответами префлайта будут:

```
Access-Control-Allow-Origin=http://mobile.yoursite.com
Access-Control-Allow-Credentials=true
```

или

```
Access-Control-Allow-Origin=http://www.yoursite.com
Access-Control-Allow-Credentials=true
```

Менее безопасной конфигурацией будет настройка внутреннего сервера на разрешение CORS со всех поддоменов вашего сайта с помощью регулярного выражения. Если злоумышленник сможет [захватить поддомен](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/02-Configuration_and_Deployment_Management_Testing/10-Test_for_Subdomain_Takeover) (что нередко случается с облачными сервисами), ваша конфигурация CORS позволит ему обойти ту же политику происхождения и подделать запрос с вашим пользовательским заголовком.

## Работа с CSRF-атаками со стороны клиента (ВАЖНО)

[Client-side CSRF](https://soheilkhodayari.github.io/same-site-wiki/docs/attacks/csrf.html#client-side-csrf) - это новый вариант CSRF-атак, при котором злоумышленник обманывает JavaScript-код на стороне клиента, чтобы отправить поддельный HTTP-запрос на уязвимый целевой сайт, манипулируя входными параметрами программы. Client-side CSRF возникает, когда JavaScript-программа использует контролируемые злоумышленником входные данные, такие как URL, для генерации асинхронных HTTP-запросов.

**Примечание:** Эти варианты CSRF особенно важны, поскольку они могут обойти некоторые из распространенных мер противодействия CSRF, такие как [защита на основе токенов](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#token-based-mitigation) и [SameSite cookies](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#samesite-cookie-attribute). Например, при использовании [маркеров синхронизации](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#synchronizer-token-pattern) или [пользовательских заголовков HTTP-запросов](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#use-of-custom-request-headers) программа JavaScript будет включать их в асинхронные запросы. Кроме того, веб-браузеры будут включать файлы cookie в контексты запросов, инициированных программами JavaScript, обходя [SameSite cookie policies](https://soheilkhodayari.github.io/same-site-wiki/docs/policies/overview.html).

**Client-Side vs. классический CSRF:** В классической модели CSRF наиболее уязвимым компонентом является программа на стороне сервера, так как она не может отличить, был ли входящий аутентифицированный запрос выполнен **намеренно**, что также известно как проблема запутавшегося заместителя. В модели клиентского CSRF наиболее уязвимым компонентом является JavaScript-программа на стороне клиента, поскольку злоумышленник может использовать ее для генерации произвольных асинхронных запросов, манипулируя конечной точкой запроса и/или ее параметрами. Клиентский CSRF связан с проблемой проверки ввода и вновь вводит недостаток "перепутанного заместителя", то есть серверная сторона снова не сможет отличить, был ли запрос выполнен намеренно или нет.

Подробнее об уязвимостях CSRF на стороне клиента см. разделы 2 и 5 этой [статьи](https://www.usenix.org/system/files/sec21-khodayari.pdf), главу [CSRF](https://soheilkhodayari.github.io/same-site-wiki/docs/attacks/csrf.html) в [SameSite wiki](https://soheilkhodayari.github.io/same-site-wiki), а также [этот пост](https://www.facebook.com/notes/facebook-bug-bounty/client-side-csrf/2056804174333798/) в [Meta Bug Bounty Program](https://www.facebook.com/whitehat).

### Пример CSRF на стороне клиента

Следующий фрагмент кода демонстрирует простой пример CSRF-уязвимости на стороне клиента.

```html
<script type="text/javascript">
    var csrf_token = document.querySelector("meta[name='csrf-token']").getAttribute("content");
    function ajaxLoad(){
        // обрабатываем хэш-фрагмент URL
        let hash_fragment = window.location.hash.slice(1);

        // фрагмент хэша должен иметь формат: /^(get|post);(.*)$/
        // например, https://site.com/index/#post;/profile
        if(hash_fragment.length > 0 && hash_fragment.indexOf(';') > 0 ){

            let params = hash_fragment.match(/^(get|post);(.*)$/);
            if(params && params.length){
                let request_method = params[1];
                let request_endpoint = params[3];

                fetch(request_endpoint, {
                    method: request_method,
                    headers: {
                        'XSRF-TOKEN': csrf_token,
                        // [...]
                    },
                    // [...]
                }).then(response => { /* [...] */ });
            }
        }
    }
    // запускаем асинхронный запрос при загрузке страницы
    window.onload = ajaxLoad();
 </script>
```

**Уязвимость:** В этом фрагменте программа при загрузке страницы вызывает функцию `ajaxLoad()`, которая отвечает за загрузку различных элементов веб-страницы. Функция считывает значение [хэш-фрагмента URL](https://developer.mozilla.org/en-US/docs/Web/API/Location/hash) (строка 4) и извлекает из него две части информации (т. е. метод запроса и конечную точку), чтобы сформировать асинхронный HTTP-запрос (строки 11-13). Уязвимость проявляется в строках 15-22, когда программа JavaScript использует фрагменты URL для получения конечной точки сервера для асинхронного HTTP-запроса (строка 15) и метода запроса. Однако оба входа могут контролироваться веб-злоумышленниками, которые могут выбрать нужное значение и создать вредоносный URL, содержащий полезную нагрузку атаки.

**Атака:** Обычно злоумышленники передают жертве вредоносный URL (с помощью таких элементов, как фишинговые письма), и поскольку вредоносный URL кажется принадлежащим честному, уважаемому (но уязвимому) сайту, пользователь часто нажимает на него. В качестве альтернативы злоумышленники могут создать атакующую страницу для злоупотребления API браузера (например, API [`window.open()`](https://developer.mozilla.org/en-US/docs/Web/API/Window/open)) и обмануть уязвимый JavaScript целевой страницы, чтобы отправить HTTP-запрос, что очень напоминает модель атаки классических CSRF-атак.

Другие примеры CSRF на стороне клиента см. в [этом посте](https://www.facebook.com/notes/facebook-bug-bounty/client-side-csrf/2056804174333798/) [Meta Bug Bounty Program](https://www.facebook.com/whitehat) и в [документе] USENIX Security (https://www.usenix.org/system/files/sec21-khodayari.pdf).

### Методы защиты от CSRF на стороне клиента

**Независимые запросы:** CSRF на стороне клиента может быть предотвращен, когда асинхронные запросы не могут быть сгенерированы через управляемые злоумышленником входы, такие как [URL](https://developer.mozilla.org/en-US/docs/Web/API/Window/location), [имя окна](https://developer.mozilla.org/en-US/docs/Web/API/Window/name), [referrer документа](https://developer.mozilla.org/en-US/docs/Web/API/Document/referrer), и [postMessages](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage), и это только несколько примеров.

**Валидация ввода:** Достижение полной изоляции между вводимыми данными и параметрами запроса не всегда возможно в зависимости от контекста и функциональности. В таких случаях необходимо реализовать проверки валидности ввода. Эти проверки должны строго оценивать формат и выбор значений параметров запроса и решать, могут ли они использоваться только в операциях, не изменяющих состояние (например, разрешать только GET-запросы и конечные точки, начинающиеся с предопределенного префикса).

**Предопределенные данные запроса:** Еще один метод снижения риска - хранить в коде JavaScript список предопределенных, безопасных данных запроса (например, комбинации конечных точек, методов запроса и других параметров, которые безопасны для воспроизведения). Затем программа может использовать параметр switch во фрагменте URL, чтобы решить, какую запись из списка должна использовать каждая функция JavaScript.

## Глубинная оборона

### Атрибут cookie SameSite

SameSite - это атрибут cookie (аналогичный HTTPOnly, Secure и т. д.), который предназначен для защиты от CSRF-атак. Он определен в [RFC6265bis](https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-02#section-5.3.7). Этот атрибут помогает браузеру решить, отправлять ли куки вместе с межсайтовыми запросами. Возможные значения для этого атрибута: `Lax`, `Strict` или `None`.

Значение Strict предотвращает отправку cookie браузером на целевой сайт во всех контекстах межсайтового просмотра, даже при переходе по обычной ссылке. Например, если на сайте, подобном GitHub, используется значение Strict, то пользователь GitHub, вошедший в систему и пытающийся перейти по ссылке на частный проект GitHub, размещенной на корпоративном форуме или в электронной почте, не сможет получить доступ к проекту, поскольку GitHub не получит сессионный cookie. Поскольку на сайте банка запрещено размещать ссылки на транзакционные страницы с внешних сайтов, флаг Strict будет наиболее подходящим для банков.

Если сайт хочет сохранить сеанс входа пользователя в систему после того, как он перешел по внешней ссылке, значение Lax в SameSite по умолчанию обеспечивает разумный баланс между безопасностью и удобством использования. Если в приведенном выше сценарии GitHub будет использовано значение Lax, то сессионный cookie будет разрешен при переходе по обычной ссылке с внешнего сайта и заблокирован при использовании методов запроса, подверженных CSRF, таких как POST. Только межсайтовые запросы, разрешенные в режиме Lax, имеют навигацию верхнего уровня и используют [безопасные](https://tools.ietf.org/html/rfc7231#section-4.2.1) методы HTTP.

Более подробную информацию о значениях `SameSite` можно найти в следующем [разделе](https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-02#section-5.3.7.1) из [rfc](https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-02).

Пример файлов cookie, использующих этот атрибут:

```
Set-Cookie: JSESSIONID=xxxxx; SameSite=Strict
Set-Cookie: JSESSIONID=xxxxx; SameSite=Lax
```

Все браузеры для настольных компьютеров и почти все мобильные браузеры теперь поддерживают атрибут `SameSite`. Чтобы отследить, какие браузеры его поддерживают, и узнать, как используется атрибут, обратитесь к следующему [сервису](https://caniuse.com/#feat=same-site-cookie-attribute). Обратите внимание, что Chrome [объявил](https://blog.chromium.org/2019/10/developers-get-ready-for-new.html), что начиная с Chrome 80 (который вышел в феврале 2020 года) будет по умолчанию помечать файлы cookie как `SameSite=Lax`, а Firefox и Edge планируют последовать этому примеру. Кроме того, флаг `Secure` будет обязателен для файлов cookie, помеченных как `SameSite=None`.

Важно отметить, что этот атрибут должен быть реализован как дополнительный уровень _защиты в глубину_. Этот атрибут защищает пользователя через браузеры, поддерживающие его, а также содержит 2 способа обойти его, как указано в следующем [разделе](https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-02#section-5.3.7.1). Этот атрибут не должен заменять CSRF-токен. Напротив, он должен сосуществовать с этим токеном для более надежной защиты пользователя.

### Использование стандартных заголовков для проверки происхождения

Этот метод защиты состоит из двух этапов, на обоих из которых рассматривается значение заголовка HTTP-запроса:

1. Определите происхождение запроса (source origin). Это можно сделать с помощью заголовков Origin или Referer.
2. Определение источника, к которому направляется запрос (целевой источник).

На стороне сервера мы проверяем, совпадают ли они оба. Если они совпадают, мы принимаем запрос как легитимный (то есть это запрос того же происхождения), а если не совпадают, мы отбрасываем запрос (то есть запрос пришел из кросс-домена). Надежность этих заголовков обусловлена тем, что их нельзя изменить программно, поскольку они попадают в список [forbidden headers](https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name), а это значит, что установить их может только браузер.

#### Идентификация происхождения источника (через заголовок Origin/Referer)

##### Проверка заголовка Origin

Если заголовок Origin присутствует, убедитесь, что его значение соответствует целевому происхождению. В отличие от referer, заголовок Origin будет присутствовать в HTTP-запросах, которые исходят от HTTPS URL.

##### Проверка заголовка Referer при отсутствии заголовка Origin

Если заголовок Origin отсутствует, убедитесь, что имя хоста в заголовке Referer соответствует целевому источнику. Этот метод борьбы с CSRF также часто используется для неаутентифицированных запросов, например, запросов, сделанных до установления состояния сессии, которое требуется для отслеживания маркера синхронизации.

В обоих случаях убедитесь, что проверка целевого происхождения является сильной. Например, если ваш сайт - `example.org`, убедитесь, что `example.org.attacker.com` не проходит проверку происхождения (т. е. сопоставляйте через трелинг / после происхождения, чтобы убедиться, что вы сопоставляете со всем происхождением).

Если ни один из этих заголовков не присутствует, вы можете либо принять, либо заблокировать запрос. Мы рекомендуем **блокировать**. В качестве альтернативы вы можете регистрировать все подобные случаи, отслеживать их использование/поведение, а затем начать блокировать запросы только после того, как вы получите достаточную уверенность.

#### Определение происхождения цели

Как правило, определить происхождение цели не всегда просто. Вы не всегда можете просто взять целевое происхождение (т. е. имя хоста и порт `#`) из URL в запросе, поскольку сервер приложений часто находится за одним или несколькими прокси-серверами. Это означает, что исходный URL может отличаться от того, который на самом деле получает сервер приложений. Однако если к вашему серверу приложений пользователи обращаются напрямую, то использование origin в URL будет вполне уместным, и все будет в порядке.

Если вы находитесь за прокси-сервером, есть несколько вариантов, которые следует рассмотреть.

- **Настройте свое приложение так, чтобы оно просто знало свое целевое происхождение:** Поскольку это ваше приложение, вы можете найти его целевое происхождение и установить это значение в какой-нибудь записи конфигурации сервера. Это будет наиболее безопасный подход, поскольку он определяется на стороне сервера, поэтому это доверенное значение. Однако это может быть проблематично поддерживать, если ваше приложение развернуто во многих местах, например, в dev, test, QA, production и, возможно, в нескольких экземплярах production. Установить правильное значение для каждой из этих ситуаций может быть непросто, но если вы можете сделать это с помощью какой-то центральной конфигурации и предоставить вашим экземплярам возможность получать значение из нее, это будет замечательно! (**Примечание:** Убедитесь, что централизованное хранилище конфигурации безопасно, потому что от него зависит большая часть вашей защиты от CSRF).
- **Используйте значение заголовка Host:** Если вы хотите, чтобы ваше приложение само находило цель, чтобы его не нужно было настраивать для каждого развернутого экземпляра, мы рекомендуем использовать семейство заголовков Host. Заголовок Host должен содержать целевое происхождение запроса. Но если ваш сервер приложений находится за прокси-сервером, значение заголовка Host, скорее всего, будет изменено прокси-сервером на целевое происхождение URL, находящегося за прокси-сервером, которое отличается от исходного URL. Это измененное происхождение заголовка Host не будет соответствовать происхождению источника в оригинальных заголовках Origin или Referer.
- **Используйте значение заголовка X-Forwarded-Host:** Чтобы избежать возможности того, что прокси изменит заголовок хоста, вы можете использовать другой заголовок X-Forwarded-Host, который будет содержать оригинальное значение заголовка Host, полученное прокси. Большинство прокси будут передавать оригинальное значение заголовка Host в заголовке X-Forwarded-Host. Поэтому значение в X-Forwarded-Host, скорее всего, будет значением целевого происхождения, которое вам нужно сравнить с исходным происхождением в заголовке Origin или Referer.

Использование этого значения заголовка для смягчения последствий будет работать правильно, если в запросах присутствуют заголовки origin или referrer. Хотя эти заголовки включаются в **большинстве** случаев, есть несколько случаев, когда они не включаются (большинство из них - по законным причинам, чтобы защитить конфиденциальность пользователей/подстроиться под экосистему браузеров).

**Случаи использования, когда X-Forward-Host не используется:**.

- В случаях, следующих за [302 redirect cross-origin](https://stackoverflow.com/questions/22397072/are-there-any-browsers-that-set-the-origin-header-to-null-for-privacy-sensitiv), Origin не включается в перенаправленный запрос, поскольку это может считаться конфиденциальной информацией, которую не следует отправлять в другой источник.
- Существуют некоторые [контексты конфиденциальности](https://wiki.mozilla.org/Security/Origin#Privacy-Sensitive_Contexts), в которых Origin имеет значение "null". Например, см. следующее [здесь](https://www.google.com/search?q=origin+header+sent+null+value+site%3Astackoverflow.com&oq=origin+header+sent+null+value+site%3Astackoverflow.com).
- Заголовок Origin включается во все запросы разного происхождения, но для запросов одинакового происхождения в большинстве браузеров он включается только в POST/DELETE/PUT **Примечание:** Хотя это и не идеально, многие разработчики используют GET-запросы для выполнения операций по изменению состояния.
- Заголовок referer не является исключением. Существует множество случаев, когда заголовок referrer опускается ([1](https://stackoverflow.com/questions/6880659/in-what-cases-will-http-referer-be-empty), [2](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referer), [3](https://en.wikipedia.org/wiki/HTTP_referer#Referer_hiding), [4](https://seclab.stanford.edu/websec/csrf/csrf.pdf) и [5](https://www.google.com/search?q=referrer+header+sent+null+value+site:stackoverflow.com)). Известно, что балансировщики нагрузки, прокси-серверы и встроенные сетевые устройства также удаляют заголовок referrer из-за соображений конфиденциальности при ведении журнала.

Обычно незначительный процент трафика подпадает под вышеуказанные категории ([1-2%](http://homakov.blogspot.com/2012/04/playing-with-referer-origin-disquscom.html)), и ни одно предприятие не захочет терять этот трафик. Одна из популярных техник, используемых в Интернете, чтобы сделать эту технику более удобной, - принимать запрос, если Origin/referrer соответствует настроенному вами списку доменов "ИЛИ" нулевое значение (примеры [здесь](http://homakov.blogspot.com/2012/04/playing-with-referer-origin-disquscom.html)). Нулевое значение предназначено для покрытия упомянутых выше крайних случаев, когда эти заголовки не отправляются. Обратите внимание, что злоумышленники могут использовать эту возможность, но люди предпочитают использовать эту технику в качестве меры глубокой защиты из-за небольших усилий, связанных с ее развертыванием.

#### Использование файлов cookie с префиксами хостов для определения происхождения.

В то время как атрибуты `SameSite` и `Secure`, упомянутые ранее, ограничивают отправку уже установленных cookies
а `HttpOnly` ограничивает чтение установленных cookie,
Злоумышленник все еще может попытаться внедрить или перезаписать защищенные cookies
(ср. с [session fixation attacks](http://www.acrossecurity.com/papers/session_fixation.pdf)).
Использование префиксов `Cookie Prefixes` для файлов cookie с токенами CSRF также расширяет защиту от этого вида атак.
Если файлы cookie имеют префикс `__Host-`, например, `Set-Cookie: __Host-token=RANDOM; path=/; Secure`, то каждый cookie:

- Не может быть (перезаписана) из другого поддомена и
- не может иметь атрибут `Domain`.
- Должен иметь путь `/`.
- Должны быть помечены как безопасные (т.е. не могут быть отправлены по незашифрованному HTTP).

Помимо префикса `__Host-`, производители браузеров также поддерживают более слабый префикс `__Secure-`.
Это ослабляет ограничения на перезапись доменов, т.е. они

- Может иметь атрибуты `Домен` и
- могут быть перезаписаны субдоменами.
- Может иметь `Путь`, отличный от `/`.

Этот смягченный вариант можно использовать в качестве альтернативы префиксу `__Host-` с "блокировкой домена",
если аутентифицированным пользователям придется посещать разные (под)домены.
Во всех остальных случаях рекомендуется использовать префикс `__Host-` в дополнение к атрибуту `SameSite`.

По состоянию на июль 2020 года префиксы cookie [поддерживаются всеми основными браузерами](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#Browser_compatibility).

Дополнительную информацию о префиксах cookie см. в [Mozilla Developer Network](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#Directives) и [IETF Draft](https://tools.ietf.org/html/draft-west-cookie-prefixes-05).

### Защита от CSRF на основе взаимодействия с пользователем

Хотя все приведенные здесь техники не требуют взаимодействия с пользователем, иногда проще или целесообразнее вовлечь его в транзакцию, чтобы предотвратить несанкционированные операции (подделку через CSRF или иным способом). Ниже приведены примеры техник, которые при правильной реализации могут выступать в качестве надежной защиты от CSRF.

- Механизмы повторной аутентификации
- Разовые жетоны

НЕ используйте CAPTCHA, поскольку она специально разработана для защиты от ботов. Возможно, и в некоторых реализациях CAPTCHA это все еще актуально, получить доказательство взаимодействия/присутствия человека из другой пользовательской сессии. Хотя это усложняет CSRF-эксплойт, но не защищает от него.

Хотя это очень сильные средства защиты от CSRF, они могут существенно повлиять на пользовательский опыт. Поэтому, как правило, они используются только для критически важных операций (таких как смена пароля, перевод денег и т. д.), наряду с другими средствами защиты, рассмотренными в этой шпаргалке.

## Возможные CSRF-уязвимости в формах входа в систему

Большинство разработчиков склонны игнорировать CSRF-уязвимости в формах входа в систему, поскольку полагают, что CSRF не применим в формах входа в систему, так как пользователь не аутентифицирован на этом этапе, однако это предположение не всегда верно. Уязвимости CSRF все еще могут возникать в формах входа в систему, где пользователь не аутентифицирован, но воздействие и риск будут другими.

Например, если злоумышленник использует CSRF, чтобы принять аутентифицированную личность жертвы на торговом сайте, используя учетную запись злоумышленника, а жертва затем вводит данные своей кредитной карты, злоумышленник может получить возможность приобрести товары, используя сохраненные данные карты жертвы. Более подробную информацию о CSRF для входа в систему и других рисках см. в разделе 3 [этого](https://seclab.stanford.edu/websec/csrf/csrf.pdf) документа.

CSRF при входе в систему можно предотвратить, создавая пре-сессии (сессии до аутентификации пользователя) и включая токены в форму входа. Для генерации токенов можно использовать любую из описанных выше техник. Помните, что предварительные сессии не могут быть переведены в реальные сессии после аутентификации пользователя - сессия должна быть уничтожена и создана новая, чтобы избежать [атак с фиксацией сессии](http://www.acrossecurity.com/papers/session_fixation.pdf). Эта техника описана в [Robust Defenses for Cross-Site Request Forgery section 4.1](https://seclab.stanford.edu/websec/csrf/csrf.pdf). Login CSRF также может быть предотвращен путем включения пользовательских заголовков запроса в AJAX-запрос, как описано [выше](#Использование-пользовательских-заголовков-запросов-для-AJAX-API).

## REFERENCE: Пример JEE-фильтра, демонстрирующего защиту от CSRF

Следующий [Веб-фильтр JEE](https://github.com/righettod/poc-csrf/blob/master/src/main/java/eu/righettod/poccsrf/filter/CSRFValidationFilter.java) представляет собой пример, иллюстрирующий некоторые концепции, описанные в этой шпаргалке. В нем реализованы следующие меры защиты без учета состояния (в [OWASP CSRFGuard](https://github.com/aramrami/OWASP-CSRFGuard) рассматривается подход с учетом состояния).

- Проверка одинакового происхождения с помощью стандартных заголовков
- Двойная отправка cookie
- Атрибут cookie SameSite

**Примите во внимание**, что это всего лишь эталонный пример и не является полным (например, в нем нет блока, направляющего поток управления при успешной проверке заголовков origin и referrer, а также нет проверки заголовка referrer на уровне порта/хоста/протокола). Разработчикам рекомендуется создавать свои полные средства защиты на основе этого эталонного примера. Разработчики также должны внедрить механизмы аутентификации и авторизации, прежде чем проверка на CSRF будет считаться эффективной.

Полный исходный текст находится [здесь](https://github.com/righettod/poc-csrf) и предоставляет запускаемый POC.

## JavaScript: Автоматическое включение CSRF-токенов в заголовок AJAX-запроса

Следующее руководство для JavaScript по умолчанию рассматривает методы **GET**, **HEAD** и **OPTIONS** как безопасные операции. Поэтому AJAX-вызовы методов **GET**, **HEAD** и **OPTIONS** не нужно дополнять заголовком CSRF-токена. Однако, если глаголы используются для выполнения операций изменения состояния, они также потребуют заголовка CSRF-токена (хотя это плохая практика, и ее следует избегать).

Методы **POST**, **PUT**, **PATCH** и **DELETE**, являющиеся глаголами, изменяющими состояние, должны иметь CSRF-токен, прикрепленный к запросу. Следующее руководство продемонстрирует, как создать переопределения в библиотеках JavaScript, чтобы маркеры CSRF автоматически включались в каждый AJAX-запрос для методов, изменяющих состояние, упомянутых выше.

### Хранение значения CSRF-токена в DOM

Токен CSRF может быть включен в тег `<meta>`, как показано ниже. Все последующие вызовы на странице могут извлекать CSRF-токен из этого тега `<meta>`. Он также может быть сохранен в переменной JavaScript или в любом месте DOM. Однако не рекомендуется хранить маркер КСОРФ в cookies или локальном хранилище браузера.

Следующий фрагмент кода можно использовать для включения CSRF-токена в тег `<meta>`:

```html
<meta name="csrf-token" content="{{ csrf_token() }}">.
```

Точный синтаксис заполнения атрибута content будет зависеть от языка программирования бэкенда вашего веб-приложения.

### Переопределение значений по умолчанию для установки пользовательского заголовка

Некоторые библиотеки JavaScript позволяют переопределить стандартные настройки, чтобы заголовок автоматически добавлялся ко всем AJAX-запросам.

#### XMLHttpRequest (нативный JavaScript)

Метод open() XMLHttpRequest может быть переопределен для установки заголовка `anti-csrf-token` при следующем вызове метода `open()`. Функция `csrfSafeMethod()`, определенная ниже, будет отфильтровывать безопасные HTTP-методы и добавлять заголовок только к небезопасным HTTP-методам.

Это можно сделать, как показано в следующем фрагменте кода:

```html
<script type="text/javascript">
    var csrf_token = document.querySelector("meta[name='csrf-token']").getAttribute("content");
    function csrfSafeMethod(method) {
        // эти методы HTTP не требуют защиты от CSRF
        return (/^(GET|HEAD|OPTIONS)$/.test(method));
    }
    var o = XMLHttpRequest.prototype.open;
    XMLHttpRequest.prototype.open = function(){
        var res = o.apply(this, arguments);
        var err = new error();
        if (!csrfSafeMethod(arguments[0])) {
            this.setRequestHeader('anti-csrf-token', csrf_token);
        }
        return res;
    };
 </script>
```

#### AngularJS

AngularJS позволяет задавать заголовки по умолчанию для HTTP-операций. Дополнительную документацию можно найти в документации AngularJS по [$httpProvider](https://docs.angularjs.org/api/ng/provider/$httpProvider#defaults).

```html
<script>
    var csrf_token = document.querySelector("meta[name='csrf-token']").getAttribute("content");

    var app = angular.module("app", []);

    app.config(['$httpProvider', function ($httpProvider) {
        $httpProvider.defaults.headers.post["anti-csrf-token"] = csrf_token;
        $httpProvider.defaults.headers.put["anti-csrf-token"] = csrf_token;
        $httpProvider.defaults.headers.patch["anti-csrf-token"] = csrf_token;
        // AngularJS по умолчанию не создает объект для методов DELETE и TRACE, его нужно создавать вручную.
        $httpProvider.defaults.headers.delete = {
            "Content-Type" : "application/json;charset=utf-8",
            "anti-csrf-token" : csrf_token
        };
        $httpProvider.defaults.headers.trace = {
            "Content-Type" : "application/json;charset=utf-8",
            "anti-csrf-token" : csrf_token
        };
      }]);
 </script>
```

Этот фрагмент кода был протестирован с AngularJS версии 1.7.7.

#### Axios

[Axios](https://github.com/axios/axios) позволяет нам устанавливать заголовки по умолчанию для действий POST, PUT, DELETE и PATCH.

```html
<script type="text/javascript">
    var csrf_token = document.querySelector("meta[name='csrf-token']").getAttribute("content");

    axios.defaults.headers.post['anti-csrf-token'] = csrf_token;
    axios.defaults.headers.put['anti-csrf-token'] = csrf_token;
    axios.defaults.headers.delete['anti-csrf-token'] = csrf_token;
    axios.defaults.headers.patch['anti-csrf-token'] = csrf_token;

    // Axios по умолчанию не создает объект для метода TRACE, его нужно создавать вручную.
    axios.defaults.headers.trace = {}
    axios.defaults.headers.trace['anti-csrf-token'] = csrf_token
</script>
```

Этот фрагмент кода был протестирован с Axios версии 0.18.0.

#### JQuery

JQuery предоставляет API под названием `$.ajaxSetup()`, который можно использовать для добавления заголовка `anti-csrf-token` в AJAX-запрос. Документацию по API для `$.ajaxSetup()` можно найти здесь. Функция `csrfSafeMethod()`, определенная ниже, будет отфильтровывать безопасные HTTP-методы и добавлять заголовок только к небезопасным HTTP-методам.

Вы можете настроить jQuery на автоматическое добавление токена во все заголовки запросов, воспользовавшись следующим фрагментом кода. Это обеспечит простую и удобную защиту от CSRF для ваших приложений, основанных на AJAX:

```html
<script type="text/javascript">
    var csrf_token = $('meta[name="csrf-token"]').attr('content');

    function csrfSafeMethod(method) {
        // эти методы HTTP не требуют защиты от CSRF
        return (/^(GET|HEAD|OPTIONS)$/.test(method));
    }

    $.ajaxSetup({
        beforeSend: function(xhr, settings) {
            if (!csrfSafeMethod(settings.type) && !this.crossDomain) {
                xhr.setRequestHeader("anti-csrf-token", csrf_token);
            }
        }
    });
</script>
```

Этот фрагмент кода был протестирован с jQuery версии 3.3.1.

## Ссылки в связанных шпаргалках

### CSRF

- [OWASP Cross-Site Request Forgery (CSRF)](https://owasp.org/www-community/attacks/csrf)
- [Академия веб-безопасности PortSwigger](https://portswigger.net/web-security/csrf)
- [Mozilla Web Security Cheat Sheet](https://infosec.mozilla.org/guidelines/web_security#csrf-prevention)
- [Общие заблуждения в предотвращении CSRF](https://medium.com/keylogged/common-csrf-prevention-misconceptions-67fd026d94a8)
- [Надежные средства защиты от CSRF](https://seclab.stanford.edu/websec/csrf/csrf.pdf)
- Для Java: OWASP [CSRF Guard](https://owasp.org/www-project-csrfguard/) или [Spring Security](https://docs.spring.io/spring-security/site/docs/5.5.x-SNAPSHOT/reference/html5/#csrf).
- Для PHP и Apache: [Проект CSRFProtector](https://github.com/OWASP/www-project-csrfprotector )
- Для AngularJS: [Защита от подделки межсайтовых запросов (XSRF)](https://docs.angularjs.org/api/ng/service/$http#cross-site-request-forgery-xsrf-protection)

