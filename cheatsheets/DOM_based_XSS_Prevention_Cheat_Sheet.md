# Шпаргалка по предотвращению XSS на основе DOM

## Введение

При рассмотрении XSS (Cross-Site Scripting, межсайтовый скриптинг) существуют три общепринятых формы [XSS](https://owasp.org/www-community/attacks/xss/):

- [Отражённые или Хранимые XSS](https://owasp.org/www-community/attacks/xss/#stored-and-reflected-xss-attacks)
- [XSS на основе DOM](https://owasp.org/www-community/attacks/DOM_Based_XSS).

[Шпаргалка по предотвращению XSS](Cross_Site_Scripting_Prevention_Cheat_Sheet.md) отлично справляется с отражёнными и хранимыми XSS. Эта шпаргалка охватывает XSS на основе DOM (Document Object Model) и является расширением (и предполагает понимание) [Шпаргалки по предотвращению XSS](Cross_Site_Scripting_Prevention_Cheat_Sheet.md).

Для понимания XSS на основе DOM необходимо увидеть фундаментальное различие между отражёнными и хранимыми XSS по сравнению с XSS на основе DOM. Основное различие заключается в том, где атака внедряется в приложение.

Отражённые и хранимые XSS являются проблемами инъекции на стороне сервера, тогда как XSS на основе DOM представляет собой проблему инъекции на стороне клиента (браузера).

Весь этот код исходит с сервера, что означает, что ответственность за его безопасность от XSS лежит на владельце приложения, независимо от типа уязвимости XSS. Кроме того, атаки XSS всегда **выполняются** в браузере.

Разница между отражёнными/хранимыми XSS заключается в том, где атака добавляется или внедряется в приложение. В случае отражённых/хранимых XSS атака внедряется в приложение во время обработки запросов на стороне сервера, где недоверенные входные данные динамически добавляются в HTML. Для XSS на основе DOM атака внедряется в приложение во время выполнения на стороне клиента напрямую.

Когда браузер рендерит HTML и другой сопутствующий контент, такой как CSS или JavaScript, он идентифицирует различные контексты рендеринга для различных типов входных данных и следует различным правилам для каждого контекста. Контекст рендеринга связан с разбором HTML-тегов и их атрибутов.

- HTML-парсер контекста рендеринга диктует, как данные представлены и расположены на странице, и может быть дополнительно разбит на стандартные контексты HTML, HTML-атрибутов, URL и CSS.
- Парсер JavaScript или VBScript контекста выполнения связан с разбором и выполнением скриптового кода. Каждый парсер имеет отдельные и специфичные семантики в том, как он может выполнять скриптовый код, что усложняет создание последовательных правил для смягчения уязвимостей в различных контекстах. Усложнение также связано с различиями в значении и обработке закодированных значений внутри каждого подсектора (HTML, HTML-атрибут, URL и CSS) в контексте выполнения.

Для целей этой статьи мы будем ссылаться на контексты HTML, HTML-атрибутов, URL и CSS как на подсекторы, поскольку каждый из этих контекстов может быть достигнут и установлен внутри контекста выполнения JavaScript.

В коде JavaScript основной контекст — это JavaScript, но с помощью соответствующих тегов и символов закрытия контекста атакующий может попытаться атаковать другие 4 контекста, используя эквивалентные методы JavaScript DOM.

Пример уязвимости, которая возникает в контексте JavaScript и подсекторе HTML:

```html
 <script>
 var x = '<%= taintedVar %>';
 var d = document.createElement('div');
 d.innerHTML = x;
 document.body.appendChild(d);
 </script>
```

Давайте рассмотрим отдельные подсекторы контекста выполнения по очереди.

## ПРАВИЛО \#1 - HTML-кодирование и затем JavaScript-кодирование перед вставкой недоверенных данных в подсектор HTML в контексте выполнения

Существует несколько методов и атрибутов, которые могут быть использованы для прямого рендеринга HTML-контента внутри JavaScript. Эти методы составляют подсектор HTML внутри контекста выполнения. Если этим методам предоставляются недоверенные входные данные, это может привести к уязвимости XSS. Например:

### Примеры опасных HTML-методов

#### Атрибуты

```javascript
 element.innerHTML = "<HTML> Теги и разметка";
 element.outerHTML = "<HTML> Теги и разметка";
```

#### Методы

```javascript
 document.write("<HTML> Теги и разметка");
 document.writeln("<HTML> Теги и разметка");
```

### Рекомендация

Чтобы сделать динамическое обновление HTML в DOM безопасным, рекомендуется:

 1. HTML-кодирование, и затем
 2. JavaScript-кодирование всех недоверенных входных данных, как показано в этих примерах:

```javascript
 var ESAPI = require('node-esapi');
 element.innerHTML = "<%=ESAPI.encoder().encodeForJavascript(ESAPI.encoder().encodeForHTML(untrustedData))%>";
 element.outerHTML = "<%=ESAPI.encoder().encodeForJavascript(ESAPI.encoder().encodeForHTML(untrustedData))%>";
```

```javascript
 var ESAPI = require('node-esapi');
 document.write("<%=ESAPI.encoder().encodeForJavascript(ESAPI.encoder().encodeForHTML(untrustedData))%>");
 document.writeln("<%=ESAPI.encoder().encodeForJavascript(ESAPI.encoder().encodeForHTML(untrustedData))%>");
```

## ПРАВИЛО \#2 - JavaScript-кодирование перед вставкой недоверенных данных в подсектор HTML-атрибута в контексте выполнения

HTML-атрибут *подсектор* внутри *контекста выполнения* отличается от стандартных правил кодирования. Это связано с тем, что правило HTML-атрибутного кодирования в рендеринг-контексте атрибута HTML необходимо для смягчения атак, которые пытаются выйти из HTML-атрибутов или добавить дополнительные атрибуты, что может привести к XSS.

Когда вы находитесь в контексте выполнения DOM, вам нужно только JavaScript-кодировать HTML-атрибуты, которые не выполняют код (атрибуты, кроме обработчиков событий, CSS и URL-атрибутов).

Например, общее правило заключается в HTML-атрибутном кодировании недоверенных данных (данные из базы данных, HTTP-запрос, пользователь, бэкэнд-система и т. д.), помещённых в HTML-атрибут. Это подходящий шаг при выводе данных в рендеринг-контексте, однако использование HTML-атрибутного кодирования в контексте выполнения нарушит отображение данных в приложении.

### БЕЗОПАСНЫЙ, но НЕКОРРЕКТНЫЙ пример

```javascript
 var ESAPI = require('node-esapi');
 var x = document.createElement("input");
 x.setAttribute("name", "company_name");
 // В следующей строке кода companyName представляет собой недоверенный ввод пользователя
 // ESAPI.encoder().encodeForHTMLAttribute() не требуется и вызывает двойное кодирование
 x.setAttribute("value", '<%=ESAPI.encoder().encodeForJavascript(ESAPI.encoder().encodeForHTMLAttribute(companyName))%>');
 var form1 = document.forms[0];
 form1.appendChild(x);
```

Проблема заключается в том, что если переменная `companyName` имеет значение "Johnson & Johnson", то в текстовом поле будет отображаться "Johnson &#x26;amp; Johnson". В данном случае следует использовать JavaScript-кодирование для предотвращения попыток злоумышленника завершить одинарные кавычки и вставить код, или избежать HTML-кодирования и открытия нового тега `<script>`.

### БЕЗОПАСНЫЙ и ФУНКЦИОНАЛЬНО КОРРЕКТНЫЙ пример

```javascript
 var ESAPI = require('node-esapi');
 var x = document.createElement("input");
 x.setAttribute("name", "company_name");
 x.setAttribute("value", '<%=ESAPI.encoder().encodeForJavascript(companyName)%>');
 var form1 = document.forms[0];
 form1.appendChild(x);
```

Важно отметить, что при установке HTML-атрибута, который не выполняет код, значение устанавливается напрямую в объектном атрибуте HTML-элемента, поэтому не возникает опасности инъекций.

## ПРАВИЛО №3 - Будьте осторожны при вставке недоверенных данных в обработчики событий и код JavaScript в контексте выполнения

Вставка динамических данных в код JavaScript особенно опасна, так как JavaScript-кодирование имеет разные семантики для закодированных данных по сравнению с другими видами кодирования. В многих случаях JavaScript-кодирование не предотвращает атаки в контексте выполнения. Например, JavaScript-кодированная строка выполнится, даже если она закодирована.

Поэтому основная рекомендация — **избегать включения недоверенных данных в этот контекст**. Если это необходимо, ниже приведены примеры, которые работают и не работают.

```javascript
var x = document.createElement("a");
x.href="#";
// В коде ниже закодированные данные (второй аргумент setAttribute) являются примером
// недоверенных данных, которые были правильно закодированы в JavaScript, но все равно выполняются.
x.setAttribute("onclick", "\u0061\u006c\u0065\u0072\u0074\u0028\u0032\u0032\u0029");
var y = document.createTextNode("Нажмите для теста");
x.appendChild(y);
document.body.appendChild(x);
```

Метод `setAttribute(name_string,value_string)` опасен, потому что он неявно приводит *value_string* к типу DOM-атрибута *name_string*.

В приведенном примере атрибутом является обработчик событий JavaScript, поэтому значение атрибута неявно преобразуется в JavaScript-код и выполняется. JavaScript-кодирование не предотвращает DOM-атаку XSS в этом случае.

Другие методы JavaScript, которые принимают код в виде строковых типов, будут иметь аналогичную проблему, как описано выше (например, `setTimeout`, `setInterval`, `new Function` и т.д.). Это резко контрастирует с JavaScript-кодированием в атрибуте обработчика событий тега HTML (HTML-парсер), где JavaScript-кодирование предотвращает XSS.

```html
<!-- НЕ работает -->
<a id="bb" href="#" onclick="\u0061\u006c\u0065\u0072\u0074\u0028\u0031\u0029"> Тестируйте меня</a>
```

Альтернативой использования `Element.setAttribute(...)` для установки атрибутов DOM является непосредственная установка атрибута. Прямая установка атрибутов обработчика событий позволяет JavaScript-кодированию предотвратить DOM-атаку XSS. Обратите внимание, что это всегда опасный дизайн — вставлять недоверенные данные напрямую в контекст выполнения команды.

```html
<a id="bb" href="#"> Тестируйте меня</a>
```

```javascript
// Следующее НЕ работает, так как обработчик событий устанавливается в строку.
// "alert(7)" закодирован в JavaScript.
document.getElementById("bb").onclick = "\u0061\u006c\u0065\u0072\u0074\u0028\u0037\u0029";

// Следующее НЕ работает, так как обработчик событий устанавливается в строку.
document.getElementById("bb").onmouseover = "testIt";

// Следующее НЕ работает из-за закодированных "(" и ")".
// "alert(77)" закодирован в JavaScript.
document.getElementById("bb").onmouseover = \u0061\u006c\u0065\u0072\u0074\u0028\u0037\u0037\u0029;

// Следующее НЕ работает из-за закодированной ";"
// "testIt;testIt" закодирован в JavaScript.
document.getElementById("bb").onmouseover = \u0074\u0065\u0073\u0074\u0049\u0074\u003b\u0074\u0065\u0073
                                            \u0074\u0049\u0074;

// Следующее РАБОТАЕТ, так как закодированное значение является допустимым именем переменной или ссылкой на функцию.
// "testIt" закодирован в JavaScript.
document.getElementById("bb").onmouseover = \u0074\u0065\u0073\u0074\u0049\u0074;

function testIt() {
   alert("Я был вызван.");
}
```

Есть и другие места в JavaScript, где JavaScript-кодирование принимается как допустимый исполняемый код.

```javascript
 for(var \u0062=0; \u0062 < 10; \u0062++){
     \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074
     .\u0077\u0072\u0069\u0074\u0065\u006c\u006e
     ("\u0048\u0065\u006c\u006c\u006f\u0020\u0057\u006f\u0072\u006c\u0064");
 }
 \u0077\u0069\u006e\u0064\u006f\u0077
 .\u0065\u0076\u0061\u006c
 \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074
 .\u0077\u0072\u0069\u0074\u0065(111111111);
```

или

```javascript
 var s = "\u0065\u0076\u0061\u006c";
 var t = "\u0061\u006c\u0065\u0072\u0074\u0028\u0031\u0031\u0029";
 window[s](t);
```

Так как JavaScript основан на международном стандарте (ECMAScript), JavaScript-кодирование позволяет поддерживать международные символы в конструкциях программирования и переменных, а также альтернативные строковые представления (экранированные строки).

Однако обратное верно для HTML-кодирования. HTML-теги четко определены и не поддерживают альтернативные представления одного и того же тега. Поэтому HTML-кодирование не может использоваться для создания альтернативных представлений тега `<a>`, например.

### Разоружающая природа HTML-кодирования

В общем случае HTML-кодирование служит для нейтрализации HTML-тегов, помещенных в контексты HTML и атрибутов HTML. Пример работающего кода (без HTML-кодирования):

```html
<a href="..." >
```

Пример с обычным кодированием (НЕ РАБОТАЕТ):

```html
&#x3c;a href=... &#x3e;
```

Пример с HTML-кодированием, подчеркивающий фундаментальное отличие от JavaScript-кодирования (НЕ РАБОТАЕТ):

```html
<&#x61; href=...>
```

Если бы HTML-кодирование следовало тем же принципам, что и JavaScript-кодирование, строка выше могла бы отобразить ссылку. Это различие делает JavaScript-кодирование менее эффективным средством борьбы с XSS.

## ПРАВИЛО №4 - JavaScript-кодирование перед вставкой недоверенных данных в CSS-атрибут в контексте выполнения

Обычно выполнение JavaScript из CSS-контекста требует либо передачи `javascript:attackCode()` методу CSS `url()`, либо вызова метода CSS `expression()`, передавая JavaScript-код для непосредственного выполнения.

По моему опыту, вызов функции `expression()` из контекста выполнения (JavaScript) был отключен. Чтобы предотвратить атаку через метод CSS `url()`, убедитесь, что вы кодируете URL, передаваемый в метод CSS `url()`.

```javascript
var ESAPI = require('node-esapi');
document.body.style.backgroundImage = "url(<%=ESAPI.encoder().encodeForJavascript(ESAPI.encoder().encodeForURL(companyName))%>)";
```

## ПРАВИЛО №5 - Кодирование URL, затем JavaScript-кодирование перед вставкой недоверенных данных в URL-атрибут в контексте выполнения

Логика, которая парсит URL-адреса в контексте выполнения и отображения, выглядит одинаково. Поэтому нет особых изменений в правилах кодирования для URL-атрибутов в контексте выполнения (DOM).

```javascript
var ESAPI = require('node-esapi');
var x = document.createElement("a");
x.setAttribute("href", '<%=ESAPI.encoder().encodeForJavascript(ESAPI.encoder().encodeForURL(userRelativePath))%>');
var y = document.createTextElement("Click Me To Test");
x.appendChild(y);
document.body.appendChild(x);
```

Если вы используете полностью квалифицированные URL-адреса, это сломает ссылки, так как двоеточие в протоколе (`http:` или `javascript:`) будет закодировано как URL, что предотвратит выполнение протоколов `http` и `javascript`.

## ПРАВИЛО №6 - Заполнение DOM с использованием безопасных JavaScript-функций или свойств

Самый безопасный способ заполнить DOM недоверенными данными — это использовать безопасное свойство назначения `textContent`.

Вот пример безопасного использования:

```html
<script>
element.textContent = untrustedData;  // не выполняет код
</script>
```

## ПРАВИЛО №7 - Исправление уязвимостей DOM XSS

Лучший способ исправить DOM XSS — это использовать правильный метод вывода (источник). Например, если вы хотите использовать пользовательский ввод для записи в элемент `div`, не используйте `innerHtml`, вместо этого используйте `innerText` или `textContent`. Это решит проблему и является правильным способом устранения уязвимостей DOM XSS.

**Использовать пользовательский ввод в опасных источниках, таких как eval, — это всегда плохая идея. В 99% случаев это признак плохой или ленивой практики программирования, так что просто не делайте этого вместо того, чтобы пытаться фильтровать ввод.**

Наконец, чтобы решить проблему в нашем исходном коде, вместо попыток правильно кодировать вывод (что сложно и может легко пойти не так), мы просто используем `element.textContent` для записи его в контент, как показано ниже:

```html
<b>Текущий URL:</b> <span id="contentholder"></span>
...
<script>
document.getElementById("contentholder").textContent = document.baseURI;
</script>
```

Это выполняет ту же задачу, но теперь код не уязвим для атак DOM XSS.

## Рекомендации по разработке безопасных приложений с использованием JavaScript

DOM XSS чрезвычайно сложно предотвратить из-за его широкой поверхности атаки и отсутствия стандартизации среди браузеров.

Ниже приведены рекомендации для разработчиков при разработке веб-приложений на основе JavaScript (Web 2.0), чтобы они могли избежать XSS.

### РЕКОМЕНДАЦИЯ №1 - Недоверенные данные должны рассматриваться только как текст для отображения

Избегайте обработки недоверенных данных как кода или разметки внутри JavaScript.

### РЕКОМЕНДАЦИЯ №2 - Всегда кодируйте JavaScript и заключайте недоверенные данные в кавычки при входе в приложение при создании шаблонного JavaScript

Всегда кодируйте JavaScript и заключайте недоверенные данные в кавычки при входе в приложение, как показано в следующем примере:

```javascript
var x = "<%= Encode.forJavaScript(untrustedData) %>";
```

### РЕКОМЕНДАЦИЯ №3 - Используйте `document.createElement("...")`, `element.setAttribute("...","value")`, `element.appendChild(...)` и подобные методы для создания динамических интерфейсов

`document.createElement("...")`, `element.setAttribute("...","value")`, `element.appendChild(...)` и аналогичные методы безопасны для создания динамических интерфейсов.

Важно отметить, что `element.setAttribute` безопасен только для ограниченного числа атрибутов.

Опасные атрибуты включают любые атрибуты, которые могут выполнять команды, такие как `onclick` или `onblur`.

Примеры безопасных атрибутов включают: `align`, `alink`, `alt`, `bgcolor`, `border`, `cellpadding`, `cellspacing`, `class`, `color`, `cols`, `colspan`, `coords`, `dir`, `face`, `height`, `hspace`, `ismap`, `lang`, `marginheight`, `marginwidth`, `multiple`, `nohref`, `noresize`, `noshade`, `nowrap`, `ref`, `rel`, `rev`, `rows`, `rowspan`, `scrolling`, `shape`, `span`, `summary`, `tabindex`, `title`, `usemap`, `valign`, `value`, `vlink`, `vspace`, `width`.

### РЕКОМЕНДАЦИЯ №4 - Избегайте отправки недоверенных данных в методы рендеринга HTML

Избегайте использования недоверенных данных в следующих методах:

1. `element.innerHTML = "...";`
2. `element.outerHTML = "...";`
3. `document.write(...);`
4. `document.writeln(...);`

### РЕКОМЕНДАЦИЯ №5 - Избегайте методов, которые неявно вызывают `eval()` для переданных данных

Существует множество методов, которые неявно вызывают `eval()` для переданных данных, их следует избегать.

Убедитесь, что любые недоверенные данные, передаваемые в эти методы, выполняют следующие шаги:

1. Заключены в строковые разделители.
2. Заключены в замыкание или закодированы на N-уровнях в зависимости от использования.
3. Обернуты в пользовательскую функцию.

Следуйте шагу 3, чтобы убедиться, что недоверенные данные не передаются в опасные методы в пользовательской функции или обрабатывайте это, добавляя дополнительный слой кодирования.

#### Использование замыкания (по предложению Gaz)

Следующий пример иллюстрирует использование замыканий для избегания двойного JavaScript-кодирования:

```javascript
 var ESAPI = require('node-esapi');
 setTimeout((function(param) { return function() {
          customFunction(param);
        }
 })("<%=ESAPI.encoder().encodeForJavascript(untrustedData)%>"), y);
```

#### Многоуровневое кодирование

Если ваш код выглядит так, как показано ниже, вам нужно только дважды закодировать данные для JavaScript:

```javascript
setTimeout("customFunction('<%=doubleJavaScriptEncodedData%>', y)");
function customFunction (firstName, lastName) {
     alert("Hello " + firstName + " " + lastName);
}
```

Данные, закодированные как `doubleJavaScriptEncodedData`, расшифровываются на первом уровне (при выполнении) в одинарных кавычках.

Затем неявный вызов `eval` в `setTimeout` расшифровывает ещё один уровень кодирования JavaScript для передачи правильного значения в `customFunction`.

Поскольку функция `customFunction` не передавала вводные данные в другой метод, который явно или неявно вызывает `eval()`, необходимо только двойное JavaScript-кодирование. Однако если *firstName* был бы передан другому JavaScript-методу, который явно или неявно вызывает `eval()`, тогда вместо `<%=doubleJavaScriptEncodedData%>` необходимо использовать `<%=tripleJavaScriptEncodedData%>`.

### Примечания по реализации

Если JavaScript-код пытается использовать дважды или трижды закодированные данные в строковых сравнениях, значение может интерпретироваться по-разному в зависимости от количества вызовов `eval()`, через которые данные прошли, и числа уровней кодирования JavaScript.

Пример:

```javascript
 var x = "doubleJavaScriptEncodedA";  // \u005c\u0075\u0030\u0030\u0034\u0031
 if (x == "A") {
    alert("x is A");
 } else if (x == "\u0041") {
    alert("This is what pops");
 }
```

Этот пример демонстрирует, как важно применять правильное кодирование в нужном контексте и избегать двойного кодирования, если оно не нужно.

### Серверное и клиентское кодирование

Идеальный подход — кодировать на серверной стороне для контекста, в который данные вводятся в приложение, а затем дополнительно кодировать на клиентской стороне (с помощью JavaScript-библиотек, таких как [node-esapi](https://github.com/ESAPI/node-esapi/)) для конкретного субконтекста (методы DOM), куда передаются недоверенные данные.

Примеры:

```javascript
// серверное кодирование
var ESAPI = require('node-esapi');
var input = "<%=ESAPI.encoder().encodeForJavascript(untrustedData)%>";
```

```javascript
// HTML-кодирование в JavaScript
var ESAPI = require('node-esapi');
document.writeln(ESAPI.encoder().encodeForHTML(input));
```

Можно использовать неизменяемые свойства ECMAScript 5 для повышения безопасности или применить предложенный Gaz (Гаретом) конструктивный подход с замыканиями.

Пример:

```javascript
function escapeHTML(str) {
     str = str + "''";
     var out = "''";
     for (var i = 0; i < str.length; i++) {
         if (str[i] === '<') {
             out += '&lt;';
         } else if (str[i] === '>') {
             out += '&gt;';
         } else if (str[i] === "'") {
             out += '&#39;';
         } else if (str[i] === '"') {
             out += '&quot;';
         } else {
             out += str[i];
         }
     }
     return out;
}
```

### РЕКОМЕНДАЦИЯ \#6 - Используйте недоверенные данные только на правой стороне выражения

Используйте недоверенные данные только на правой стороне выражения, особенно данные, которые выглядят как код и могут быть переданы в приложение (например, `location` и `eval()`).

```javascript
window[userDataOnLeftSide] = "userDataOnRightSide";
```

Использование недоверенных пользовательских данных на левой стороне выражения позволяет злоумышленнику изменить внутренние и внешние атрибуты объекта window, тогда как использование пользовательских данных на правой стороне выражения не позволяет напрямую манипулировать ими.

### РЕКОМЕНДАЦИЯ \#7 - При URL-кодировании в DOM учитывайте проблемы с набором символов

При URL-кодировании в DOM учитывайте проблемы с набором символов, так как набор символов в JavaScript DOM не четко определен (Майк Сэмюэл).

### РЕКОМЕНДАЦИЯ \#8 - Ограничивайте доступ к свойствам объекта при использовании `object[x]` аксессоров

Ограничивайте доступ к свойствам объекта при использовании аксессоров `object[x]` (Майк Сэмюэл). Другими словами, добавьте уровень косвенности между недоверенным вводом и указанными свойствами объекта.

Пример проблемы с использованием типов карт:

```javascript
var myMapType = {};
myMapType[<%=untrustedData%>] = "moreUntrustedData";
```

Разработчик, написавший этот код, пытался добавить дополнительные элементы с ключами в объект `myMapType`. Однако злоумышленник может использовать это для изменения внутренних и внешних атрибутов объекта `myMapType`.

Более подходящий способ использования:

```javascript
if (untrustedData === 'location') {
  myMapType.location = "moreUntrustedData";
}
```

### РЕКОМЕНДАЦИЯ \#9 - Запускайте свой JavaScript в канопи ECMAScript 5 или в песочнице

Запускайте свой JavaScript в канопи [ECMAScript 5](https://github.com/jcoglan/canopy) или в песочнице, чтобы усложнить компрометацию API вашего JavaScript (Гарет Хейес и Джон Стивенс).

Примеры песочниц/санитайзеров для JavaScript:

- [js-xss](https://github.com/leizongmin/js-xss)
- [sanitize-html](https://github.com/apostrophecms/sanitize-html)
- [DOMPurify](https://github.com/cure53/DOMPurify)
- [MDN - HTML Sanitizer API](https://developer.mozilla.org/en-US/docs/Web/API/HTML_Sanitizer_API)
- [OWASP Summit 2011 - DOM Sandboxing](https://owasp.org/www-pdf-archive/OWASPSummit2011DOMSandboxingBrowserSecurityTrack.pdf)

### РЕКОМЕНДАЦИЯ \#10 - Не используйте `eval()` для преобразования JSON в нативные JavaScript объекты

Не используйте `eval()` для преобразования JSON в нативные JavaScript объекты. Вместо этого используйте `JSON.toJSON()` и `JSON.parse()` (Крис Шмидт).

## Общие проблемы, связанные с предотвращением DOM-основанных XSS

### Сложные контексты

Во многих случаях контекст не всегда легко различить.

```html
<a href="javascript:myFunction('<%=untrustedData%>', 'test');">Click Me</a>
 ...
<script>
Function myFunction (url,name) {
    window.location = url;
}
</script>
```

В приведенном выше примере недоверенные данные начинаются в контексте URL-адреса (`href` атрибут тега `a`), затем меняются на контекст выполнения JavaScript (`javascript:` протокол) и передаются в субконтекст выполнения URL (`window.location` функции `myFunction`).

Поскольку данные были введены в код JavaScript и переданы в субконтекст URL, подходящее серверное кодирование будет следующим:

```html
<a href="javascript:myFunction('<%=ESAPI.encoder().encodeForJavascript(ESAPI.encoder().encodeForURL(untrustedData)) %>', 'test');">
Click Me</a>
 ...
```

Или если вы используете ECMAScript 5 с неизменяемыми клиентскими библиотеками кодирования JavaScript, можно сделать следующее:

```html
<!-- серверное кодирование URL было удалено. Теперь только кодирование JavaScript на стороне сервера. -->
<a href="javascript:myFunction('<%=ESAPI.encoder().encodeForJavascript(untrustedData)%>', 'test');">Click Me</a>
 ...
<script>
Function myFunction (url,name) {
    var encodedURL = ESAPI.encoder().encodeForURL(url);  //URL-кодирование с использованием клиентских скриптов
    window.location = encodedURL;
}
</script>
```

### Несоответствия библиотек кодирования

Существует несколько библиотек кодирования с открытым исходным кодом:

1. OWASP [ESAPI](https://owasp.org/www-project-enterprise-security-api/)
2. OWASP [Java Encoder](https://owasp.org/www-project-java-encoder/)
3. Apache Commons Text [StringEscapeUtils](https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/StringEscapeUtils.html), замените одну из [Apache Commons Lang3](https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/StringEscapeUtils.html)
4. [Jtidy](http://jtidy.sourceforge.net/)
5. Собственная реализация вашей компании.

Некоторые из них работают на основе черного списка, в то время как другие игнорируют важные символы, такие как "<" и ">".

Java Encoder — это активный проект, поддерживающий кодирование HTML, CSS и JavaScript.

ESAPI — одна из немногих библиотек, которая работает на основе белого списка и кодирует все неалфавитно-цифровые символы. Важно использовать библиотеку кодирования, которая понимает, какие символы могут использоваться для эксплуатации уязвимостей в соответствующих контекстах. Существует множество заблуждений относительно правильного кодирования, необходимого для защиты.

### Заблуждения о кодировании

Многие учебные курсы по безопасности и статьи рекомендуют использовать HTML-кодирование для защиты от XSS.

Это кажется разумным советом, так как парсер JavaScript не понимает HTML-кодирования.

Однако, если страницы вашего веб-приложения возвращаются с типом содержимого `text/xhtml` или расширением файла `*.xhtml`, то HTML-кодирование может не сработать для предотвращения XSS.

Например:

```html
<script>
&#x61;lert(1);
</script>
```

Закодированное значение выше все еще исполняется. Если этого недостаточно, следует помнить, что кодировки теряются при их извлечении с помощью атрибута `value` элемента DOM.

Давайте посмотрим на пример страницы и скрипта:

```html
<form name="myForm" ...>
  <input type="text" name="lName" value="<%=ESAPI.encoder().encodeForHTML(last_name)%>">
 ...
</form>
<script>
  var x = document.myForm.lName.value;  //при извлечении значения кодирование отменяется
  document.writeln(x);  //любой код, переданный в lName, теперь исполняется.
</script>
```

Наконец, существует проблема с тем, что некоторые методы JavaScript, которые обычно считаются безопасными, могут быть небезопасны в определенных контекстах.

### Обычно безопасные методы

Одним из атрибутов, который считается безопасным, является `innerText`.

Некоторые статьи или руководства рекомендуют его использование в качестве альтернативы `innerHTML`, чтобы предотвратить XSS в `innerHTML`. Однако, в зависимости от тега, к которому применяется `innerText`, код может быть выполнен.

```html
<script>
 var tag = document.createElement("script");
 tag.innerText = "<%=untrustedData%>";  //выполняет код
</script>
```

Функция `innerText` была первоначально представлена в Internet Explorer и официально определена в стандарте HTML в 2016 году после того, как была принята всеми основными браузерами.

### Обнаружение DOM XSS с использованием вариативного анализа

**Уязвимый код:**

```
<script>
var x = location.hash.split("#")[1];
document.write(x);
</script>
```

Правило Semgrep для обнаружения XSS [ссылка](https://semgrep.dev/s/we30).