# Шпаргалка по Laravel

## Введение

Эта *шпаргалка* предназначена для предоставления советов по безопасности разработчикам, создающим приложения на Laravel. Она охватывает все распространенные уязвимости и способы обеспечения безопасности ваших приложений на Laravel.

Фреймворк Laravel предоставляет встроенные функции безопасности и предназначен для использования по умолчанию безопасным образом. Однако он также предоставляет дополнительную гибкость для сложных сценариев использования. Это означает, что разработчики, незнакомые с внутренним устройством Laravel, могут столкнуться с проблемой использования сложных функций ненадежным способом. Этот гид предназначен для обучения разработчиков избегать распространенных ошибок и разрабатывать приложения на Laravel безопасным образом.

Вы также можете обратиться к [документации по безопасности Enlightn](https://www.laravel-enlightn.com/docs/security/), которая выделяет общие уязвимости и хорошие практики по обеспечению безопасности приложений на Laravel.

## Основы

- Убедитесь, что ваше приложение не находится в режиме отладки в продакшене. Чтобы выключить режим отладки, установите переменную окружения `APP_DEBUG` в значение `false`:

```ini
APP_DEBUG=false
```

- Убедитесь, что ключ приложения был сгенерирован. Приложения Laravel используют ключ приложения для симметричного шифрования и хеширования SHA256, таких как шифрование куки, подписанные URL-адреса, токены сброса пароля и шифрование данных сеанса. Чтобы сгенерировать ключ приложения, выполните команду Artisan `key:generate`:

```bash
php artisan key:generate
```

- Убедитесь, что ваша конфигурация PHP безопасна. Вы можете обратиться к [шпаргалке по конфигурации PHP](PHP_Configuration_Cheat_Sheet.md) для получения дополнительной информации о безопасных настройках конфигурации PHP.

- Установите безопасные разрешения на файлы и директории вашего приложения Laravel. В общем случае, все директории Laravel должны иметь максимальный уровень разрешений `775`, а неисполняемые файлы — максимальный уровень разрешений `664`. Исполняемые файлы, такие как Artisan или скрипты развертывания, должны иметь максимальный уровень разрешений `775`.

- Убедитесь, что ваше приложение не имеет уязвимых зависимостей. Вы можете проверить это, используя [Enlightn Security Checker](https://github.com/enlightn/security-checker).

## Безопасность куки и управление сеансами

По умолчанию Laravel настроен безопасным образом. Однако, если вы изменяете конфигурации куки или сеансов, убедитесь в следующем:

- Включите промежуточное ПО для шифрования куки, если вы используете хранилище сеансов `cookie` или если вы храните данные, которые не должны быть читаемы или изменяемы клиентами. Обычно это должно быть включено, если только ваше приложение не имеет очень специфического сценария использования, требующего отключения этой функции. Чтобы включить это промежуточное ПО, просто добавьте `EncryptCookies` в группу промежуточного ПО `web` в вашем классе `App\Http\Kernel`:

```php
/**
 * Группы промежуточного ПО маршрутов приложения.
 *
 * @var array
 */
protected $middlewareGroups = [
    'web' => [
        \App\Http\Middleware\EncryptCookies::class,
        ...
    ],
    ...
];
```

- Включите атрибут `HttpOnly` для ваших куки сеансов через файл `config/session.php`, чтобы ваши куки сеансов были недоступны из JavaScript:

```php
'http_only' => true,
```

- Если вы не используете регистрации маршрутов с поддоменами в вашем приложении Laravel, рекомендуется установить атрибут `domain` куки в значение null, чтобы куки могли быть установлены только одним и тем же источником (исключая поддомены). Это можно настроить в вашем файле `config/session.php`:

```php
'domain' => null,
```

- Установите атрибут куки `SameSite` в значение `lax` или `strict` в вашем файле `config/session.php`, чтобы ограничить использование ваших куки контекстом первой стороны или того же сайта:

```php
'same_site' => 'lax',
```

- Если ваше приложение работает только через HTTPS, рекомендуется установить параметр `secure` в вашем файле `config/session.php` в значение `true`, чтобы защититься от атак типа "человек посередине". Если ваше приложение использует комбинацию HTTP и HTTPS, рекомендуется установить это значение в `null`, чтобы атрибут secure автоматически устанавливался при обслуживании HTTPS-запросов:

```php
'secure' => null,
```

- Убедитесь, что у вас установлен низкий тайм-аут бездействия сеанса. [OWASP рекомендует](Session_Management_Cheat_Sheet.md) тайм-аут 2-5 минут для приложений с высокой ценностью и 15-30 минут для приложений с низким риском. Это можно настроить в вашем файле `config/session.php`:

```php
'lifetime' => 15,
```

Вы также можете обратиться к [Руководству по безопасности куки](https://owasp.org/www-chapter-london/assets/slides/OWASPLondon20171130_Cookie_Security_Myths_Misconceptions_David_Johansson.pdf), чтобы узнать больше о безопасности куки и упомянутых атрибутах куки.

## Аутентификация

### Охранники и Провайдеры

В основе механизмов аутентификации Laravel лежат "охранники" и "провайдеры". Охранники определяют, как пользователи аутентифицируются для каждого запроса. Провайдеры определяют, как пользователи извлекаются из вашего постоянного хранилища.

Laravel поставляется с охранником `session`, который поддерживает состояние с использованием хранилища сеансов и куки, и охранником `token` для API токенов.

Что касается провайдеров, Laravel поставляется с провайдером `eloquent` для извлечения пользователей с использованием Eloquent ORM и провайдером `database` для извлечения пользователей с использованием построителя запросов базы данных.

Охранники и провайдеры могут быть настроены в файле `config/auth.php`. Laravel также предоставляет возможность создавать пользовательские охранники и провайдеры.

### Стартовые комплекты

Laravel предлагает широкий выбор первичных стартовых комплектов приложений, которые включают встроенные функции аутентификации:

1. [Laravel Breeze](https://laravel.com/docs/8.x/starter-kits#laravel-breeze): Простая, минимальная реализация всех функций аутентификации Laravel, включая вход в систему, регистрацию, сброс пароля, проверку электронной почты и подтверждение пароля.
2. [Laravel Fortify](https://laravel.com/docs/fortify): Безголовый бэкэнд аутентификации, который включает вышеуказанные функции аутентификации, а также двухфакторную аутентификацию.
3. [Laravel Jetstream](https://jetstream.laravel.com/): Стартовый комплект приложения, который предоставляет пользовательский интерфейс поверх функций аутентификации Laravel Fortify.

Рекомендуется использовать один из этих стартовых комплектов, чтобы обеспечить надежную и безопасную аутентификацию для ваших приложений на Laravel.

### Пакеты для Аутентификации API

Laravel также предлагает следующие пакеты для аутентификации API:

1. [Passport](https://laravel.com/docs/passport): Провайдер аутентификации OAuth2.
2. [Sanctum](https://laravel.com/docs/sanctum): Провайдер аутентификации API токенов.

Стартовые комплекты, такие как Fortify и Jetstream, имеют встроенную поддержку Sanctum.

## Массовое Присвоение

[Массовое присвоение](Mass_Assignment_Cheat_Sheet.md) — это распространенная уязвимость в современных веб-приложениях, использующих ORM, такие как Eloquent ORM Laravel.

Массовое присвоение — это уязвимость, при которой паттерн ORM используется для изменения данных, которые пользователь не должен был бы изменять.

Рассмотрим следующий код:

```php
Route::any('/profile', function (Request $request) {
    $request->user()->forceFill($request->all())->save();

    $user = $request->user()->fresh();

    return response()->json(compact('user'));
})->middleware('auth');
```

Вышеуказанный маршрут профиля позволяет вошедшему в систему пользователю изменить информацию о своем профиле.

Однако, допустим, в таблице пользователей есть столбец `is_admin`. Вы, вероятно, не хотите, чтобы пользователь мог изменять значение этого столбца. Однако вышеуказанный код позволяет пользователям изменять любые значения столбцов для своей строки в таблице пользователей. Это уязвимость массового присвоения.

Laravel имеет встроенные функции по умолчанию для защиты от этой уязвимости. Убедитесь в следующем, чтобы оставаться в безопасности:

- Указывайте разрешенные параметры, которые вы хотите обновить, используя `$request->only` или `$request->validated`, а не `$request->all`.
- Не снимайте защиту с моделей или не устанавливайте переменную `$guarded` в пустой массив. Делая это, вы фактически отключаете встроенную защиту от массового присвоения в Laravel.
- Избегайте использования таких методов, как `forceFill` или `forceCreate`, которые обходят механизм защиты. Вы можете использовать эти методы, если передаете проверенный массив значений.

## SQL Инъекция

Атаки SQL-инъекции, к сожалению, довольно распространены в современных веб-приложениях и предполагают, что злоумышленники предоставляют вредоносные данные запроса для вмешательства в SQL-запросы. Этот гид охватывает SQL-инъекции и способы их предотвращения конкретно для приложений Laravel. Вы также можете обратиться к [Шпаргалке по предотвращению SQL-инъекций](SQL_Injection_Prevention_Cheat_Sheet.md) для получения дополнительной информации, не специфичной для Laravel.

### Защита от SQL-инъекций в Eloquent ORM

По умолчанию Eloquent ORM Laravel защищает от SQL-инъекций, параметризуя запросы и используя SQL-связки. Например, рассмотрим следующий запрос:

```php
use App\Models\User;

User::where('email', $email)->get();
```

Этот код формирует следующий запрос:

```sql
select * from `users` where `email` = ?
```

Таким образом, даже если `$email` содержит непроверенные данные от пользователя, вы защищены от атак SQL-инъекции.

### SQL-инъекция в сырых запросах

Laravel также предоставляет возможности для использования сырых выражений и запросов для создания сложных запросов или запросов, специфичных для базы данных, которые не поддерживаются из коробки.

Хотя это предоставляет большую гибкость, вы должны быть осторожны и всегда использовать SQL-связки для таких запросов. Рассмотрим следующий запрос:

```php
use Illuminate\Support\Facades\DB;
use App\Models\User;

User::whereRaw('email = "'.$request->input('email').'"')->get();
DB::table('users')->whereRaw('email = "'.$request->input('email').'"')->get();
```

Обе строки кода фактически выполняют один и тот же запрос, который уязвим к SQL-инъекциям, поскольку запрос не использует SQL-связки для непроверенных данных пользователя.

Этот код формирует следующий запрос:

```sql
select * from `users` where `email` = "значение параметра email запроса"
```

Всегда помните о необходимости использования SQL-связок для данных запросов. Мы можем исправить приведенный выше код, внеся следующие изменения:

```php
use App\Models\User;

User::whereRaw('email = ?', [$request->input('email')])->get();
```

Мы также можем использовать именованные SQL-связки следующим образом:

```php
use App\Models\User;

User::whereRaw('email = :email', ['email' => $request->input('email')])->get();
```

### SQL Инъекция через имя столбца

Никогда не позволяйте данным, введенным пользователем, определять имена колонок, на которые ссылаются ваши запросы.

Следующие запросы могут быть уязвимы к SQL-инъекциям:

```php
use App\Models\User;

User::where($request->input('colname'), 'somedata')->get();
User::query()->orderBy($request->input('sortBy'))->get();
```

Важно отметить, что, хотя Laravel имеет встроенные функции, такие как оборачивание имен колонок для защиты от вышеупомянутых уязвимостей SQL-инъекций, некоторые СУБД (в зависимости от версий и конфигураций) все равно могут быть уязвимы, поскольку связывание имен колонок не поддерживается базами данных.

По крайней мере, это может привести к уязвимости массового присвоения, вместо SQL-инъекции, поскольку вы могли ожидать определенный набор значений колонок, но, поскольку они не проверены здесь, пользователь может использовать другие колонки.

Всегда проверяйте данные, введенные пользователем, в таких ситуациях следующим образом:

```php
use App\Models\User;

$request->validate(['sortBy' => 'in:price,updated_at']);
User::query()->orderBy($request->validated()['sortBy'])->get();
```

### Уязвимость SQL-инъекции в Правилах Проверки

Некоторые правила проверки имеют возможность предоставления имен колонок базы данных. Такие правила уязвимы к SQL-инъекциям аналогичным образом, как и инъекции через имена колонок, поскольку они формируют запросы подобным образом.

Например, следующий код может быть уязвим:

```php
use Illuminate\Validation\Rule;

$request->validate([
    'id' => Rule::unique('users')->ignore($id, $request->input('colname'))
]);
```

Внутри этот код выполняет следующий запрос:

```php
use App\Models\User;

$colname = $request->input('colname');
User::where($colname, $request->input('id'))->where($colname, '<>', $id)->count();
```

Поскольку имя колонки определяется данными, введенными пользователем, это аналогично SQL-инъекции через имена колонок.

## Межсайтовый скриптинг (XSS)

[Aтаки XSS](https://owasp.org/www-community/attacks/xss/) — это инъекции, при которых вредоносные скрипты (например, фрагменты JavaScript-кода) внедряются в доверенные веб-сайты.

Шаблонизатор [Blade](https://laravel.com/docs/blade) в Laravel имеет операторы вывода `{{ }}`, которые автоматически экранируют переменные с помощью функции `htmlspecialchars` PHP для защиты от XSS-атак.

Laravel также предлагает отображение неэкранованных данных с использованием неэкранованного синтаксиса `{!! !!}`. Это не следует использовать для непроверенных данных, иначе ваше приложение может подвергнуться XSS-атаке.

Например, если у вас есть что-то подобное в любом из ваших Blade-шаблонов, это приведет к уязвимости:

```blade
{!! request()->input('somedata') !!}
```

Однако это безопасно:

```blade
{{ request()->input('somedata') }}
```

Для другой информации о предотвращении XSS, не специфичной для Laravel, вы можете обратиться к [Шпаргалке по предотвращению межсайтового скриптинга](Cross_Site_Scripting_Prevention_Cheat_Sheet.md).

Конечно! Исправлю заголовки:

## Неограниченная загрузка файлов

Атаки неограниченной загрузки файлов включают в себя загрузку злоумышленниками вредоносных файлов для компрометации веб-приложений. Этот раздел описывает, как защититься от таких атак при разработке приложений на Laravel. Вы также можете обратиться к [Шпаргалке по загрузке файлов](File_Upload_Cheat_Sheet.md) для получения дополнительной информации.

### Всегда проверяйте тип и размер файла

Всегда проверяйте тип файла (расширение или MIME-тип) и размер файла, чтобы избежать атак DOS на хранилище и удаленного выполнения кода:

```php
$request->validate([
    'photo' => 'file|size:100|mimes:jpg,bmp,png'
]);
```

Атаки DOS на хранилище используют отсутствие проверки размера файла и загружают большие файлы, чтобы вызвать отказ в обслуживании (DOS), исчерпывая дисковое пространство.

Атаки удаленного выполнения кода заключаются в том, что сначала загружаются вредоносные исполняемые файлы (например, PHP-файлы), а затем их вредоносный код запускается, посещая URL файла (если он доступен публично).

Обе эти атаки можно избежать с помощью простых проверок файлов, как указано выше.

### Не полагайтесь на входные данные пользователя для определения имен файлов или пути

Если ваше приложение позволяет данным, контролируемым пользователем, формировать путь для загрузки файла, это может привести к перезаписи критического файла или сохранению файла в неправильном месте.

Рассмотрим следующий код:

```php
Route::post('/upload', function (Request $request) {
    $request->file('file')->storeAs(auth()->id(), $request->input('filename'));

    return back();
});
```

Этот маршрут сохраняет файл в каталог, специфичный для ID пользователя. Здесь мы полагаемся на данные `filename`, введенные пользователем, и это может привести к уязвимости, поскольку имя файла может быть таким, как `../2/filename.pdf`. Это приведет к загрузке файла в каталог пользователя с ID 2, а не в каталог текущего вошедшего пользователя.

Чтобы исправить это, мы должны использовать функцию PHP `basename`, чтобы удалить любую информацию о каталоге из данных `filename`:

```php
Route::post('/upload', function (Request $request) {
    $request->file('file')->storeAs(auth()->id(), basename($request->input('filename')));

    return back();
});
```

### Избегайте обработки ZIP или XML файлов, если это возможно

XML-файлы могут подвергнуть ваше приложение различным атакам, таким как атаки XXE, атака "миллиард смехов" и другим. Если вы обрабатываете ZIP-файлы, вы можете столкнуться с атаками zip bomb DOS.

Обратитесь к [Шпаргалке по XML-безопасности](XML_Security_Cheat_Sheet.md) и [Шпаргалке по загрузке файлов](File_Upload_Cheat_Sheet.md) для получения дополнительной информации.

Прошу прощения, исправлю заголовки:

## Переход по путям

Атака через переход по путям направлена на доступ к файлам, манипулируя входными данными запроса с помощью последовательностей `../` и их вариациями или используя абсолютные пути файлов.

Если вы позволяете пользователям загружать файлы по имени файла, вы можете подвергнуться этой уязвимости, если входные данные не очищаются от информации о каталоге.

Рассмотрим следующий код:

```php
Route::get('/download', function(Request $request) {
    return response()->download(storage_path('content/').$request->input('filename'));
});
```

Здесь имя файла не очищается от информации о каталоге, поэтому неправильно сформированное имя файла, такое как `../../.env`, может раскрыть ваши учетные данные приложения потенциальным злоумышленникам.

Аналогично неограниченной загрузке файлов, вы должны использовать функцию PHP `basename`, чтобы удалить информацию о каталоге:

```php
Route::get('/download', function(Request $request) {
    return response()->download(storage_path('content/').basename($request->input('filename')));
});
```

## Открытое перенаправление

Атаки через открытое перенаправление сами по себе не так опасны, но они могут привести к фишинг-атакам.

Рассмотрим следующий код:

```php
Route::get('/redirect', function (Request $request) {
   return redirect($request->input('url'));
});
```

Этот код перенаправляет пользователя на любой внешний URL, предоставленный входными данными пользователя. Это может позволить злоумышленникам создавать казалось бы безопасные URL, такие как `https://example.com/redirect?url=http://evil.com`. Например, злоумышленники могут использовать URL такого типа, чтобы подделать электронные письма для сброса пароля и направить жертв на сайт злоумышленника для раскрытия своих учетных данных.

## Cross-Site Request Forgery (CSRF)

[Cross-Site Request Forgery (CSRF)](https://owasp.org/www-community/attacks/csrf) — это тип атаки, который происходит, когда вредоносный веб-сайт, электронное письмо, блог, мгновенное сообщение или программа вызывает выполнение нежелательного действия на доверенном сайте, когда пользователь аутентифицирован.

Laravel предоставляет защиту от CSRF "из коробки" с помощью промежуточного ПО `VerifyCsrfToken`. Обычно, если у вас есть это промежуточное ПО в группе `web` вашего класса `App\Http\Kernel`, вы должны быть хорошо защищены:

```php
/**
 * Группы промежуточного ПО маршрутов приложения.
 *
 * @var array
 */
protected $middlewareGroups = [
    'web' => [
        ...
        \App\Http\Middleware\VerifyCsrfToken::class,
        ...
    ],
];
```

Для всех форм запросов `POST` вы можете использовать директиву Blade `@csrf`, чтобы создать скрытые поля с токеном CSRF:

```html
<form method="POST" action="/profile">
    @csrf

    <!-- Эквивалентно... -->
    <input type="hidden" name="_token" value="{{ csrf_token() }}" />
</form>
```

Для AJAX-запросов вы можете настроить заголовок [X-CSRF-Token](https://laravel.com/docs/csrf#csrf-x-csrf-token).

Laravel также предоставляет возможность исключить определенные маршруты из защиты CSRF с помощью переменной `$except` в вашем классе промежуточного ПО CSRF. Обычно вы хотите исключить только безгосударственные маршруты (например, API или вебхуки) из защиты CSRF. Если какие-либо другие маршруты исключены, это может привести к уязвимостям CSRF.

## Командная инъекция

Уязвимости командной инъекции связаны с выполнением команд оболочки, построенных с использованием неэкранированных данных ввода пользователя.

Например, следующий код выполняет команду `whois` для предоставленного пользователем доменного имени:

```php
public function verifyDomain(Request $request)
{
    exec('whois '.$request->input('domain'));
}
```

Этот код уязвим, так как данные пользователя не экранированы должным образом. Чтобы избежать этого, вы можете использовать функции PHP `escapeshellcmd` и/или `escapeshellarg`.

## Другие инъекции

Атаки, связанные с инъекцией объектов, инъекцией кода `eval` и захватом переменных с помощью функции `extract`, включают десериализацию, оценку или использование функции `extract` с не доверенными данными пользователя.

Примеры таких атак:

```php
unserialize($request->input('data'));
eval($request->input('data'));
extract($request->all());
```

В общем, избегайте передачи любых недоверенных данных ввода в эти опасные функции.

## Заголовки безопасности

Рассмотрите возможность добавления следующих заголовков безопасности на ваш веб-сервер или в промежуточное ПО приложения Laravel:

- X-Frame-Options
- X-Content-Type-Options
- Strict-Transport-Security (только для приложений HTTPS)
- Content-Security-Policy

Для получения дополнительной информации обратитесь к [OWASP проекту по безопасным заголовкам](https://owasp.org/www-project-secure-headers/).

## Инструменты

Рассмотрите возможность использования [Enlightn](https://www.laravel-enlightn.com/), инструмента статического и динамического анализа для приложений Laravel, который имеет более 45 автоматизированных проверок безопасности для выявления потенциальных проблем безопасности. Доступна как открытая, так и коммерческая версии Enlightn. Enlightn включает обширную документацию из 45 страниц по уязвимостям безопасности, и отличный способ узнать больше о безопасности Laravel — это просто ознакомиться с его [документацией](https://www.laravel-enlightn.com/docs/security/).

Также используйте [Enlightn Security Checker](https://github.com/enlightn/security-checker) или [Local PHP Security Checker](https://github.com/fabpot/local-php-security-checker). Оба этих инструмента являются открытым исходным кодом, лицензированным соответственно под MIT и AGPL лицензиями, которые сканируют ваши зависимости PHP на наличие известных уязвимостей с использованием [Security Advisories Database](https://github.com/FriendsOfPHP/security-advisories).

## Ссылки

- [Документация Laravel по аутентификации](https://laravel.com/docs/authentication)
- [Документация Laravel по авторизации](https://laravel.com/docs/authorization)
- [Документация Laravel по CSRF](https://laravel.com/docs/csrf)
- [Документация Laravel по валидации](https://laravel.com/docs/validation)
- [Enlightn SAST и DAST Tool](https://www.laravel-enlightn.com/)
- [Документация по безопасности Laravel Enlightn](https://www.laravel-enlightn.com/docs/security/)
