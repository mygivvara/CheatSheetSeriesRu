# Шпаргалка по криптографическому хранилищу

## Введение

В этой статье представлена простая модель, которой следует придерживаться при внедрении решений для защиты данных в состоянии покоя.

Не следует хранить пароли с использованием обратимого шифрования - вместо этого следует использовать безопасные алгоритмы хэширования паролей. В [Шпаргалке по хранению паролей](Password_Storage_Cheat_Sheet.md) содержится дополнительное руководство по хранению паролей.

## Архитектурное проектирование

Первым шагом при разработке любого приложения является рассмотрение общей архитектуры системы, поскольку это окажет огромное влияние на техническую реализацию.

Этот процесс должен начинаться с рассмотрения [модели угроз] (Threat_Modeling_Cheat_Sheet.md) приложения (то есть того, от кого вы пытаетесь защитить эти данные).

Использование специализированных систем управления секретами или ключами может обеспечить дополнительный уровень защиты, а также значительно упростить управление секретами, однако это сопряжено с дополнительными сложностями и административными расходами, поэтому может оказаться нецелесообразным для всех приложений. Обратите внимание, что многие облачные среды предоставляют такие услуги, поэтому их следует использовать по возможности. В [Шпаргалке по управлению секретами] (Secrets_Management_Cheat_Sheet.md) содержится дополнительное руководство по этой теме.

### Где выполнять шифрование

Шифрование может осуществляться на нескольких уровнях в стеке приложений, например:

- На уровне приложений.
- На уровне базы данных (например, [SQL Server TDE](https://docs.microsoft.com/en-us/sql/relational-databases/security/encryption/transparent-data-encryption?view=sql-server-ver15))
- На уровне файловой системы (например, BitLocker или LUKS)
- На аппаратном уровне (например, зашифрованные карты RAID или твердотельные накопители)

Выбор наиболее подходящего уровня (уровней) зависит от модели угрозы. Например, шифрование на аппаратном уровне эффективно для защиты от физической кражи сервера, но не обеспечит защиты, если злоумышленник сможет скомпрометировать сервер удаленно.

### Минимизируйте хранение чувствительной информации

Лучший способ защитить конфиденциальную информацию - не хранить ее вообще. Хотя это относится ко всем видам информации, чаще всего это применимо к данным кредитных карт, поскольку они очень желанны для злоумышленников, а PCI DSS предъявляет столь строгие требования к их хранению. По возможности следует избегать хранения конфиденциальной информации.

## Алгоритмы

Для симметричного шифрования следует использовать алгоритм **AES** с ключом не менее **128 бит** (в идеале **256 бит**) и безопасным [режимом](#режимы-шифрования).

Для асимметричного шифрования используйте криптографию эллиптических кривых (ECC) с безопасной кривой, например **Curve25519**, как предпочтительный алгоритм. Если ECC недоступна и необходимо использовать **RSA**, убедитесь, что ключ имеет размер не менее **2048 бит**.

Существует множество других симметричных и асимметричных алгоритмов, у которых есть свои плюсы и минусы, и они могут быть лучше или хуже AES или Curve25519 в конкретных случаях использования. При их рассмотрении следует учитывать ряд факторов, в том числе:

- Размер ключа.
- Известные атаки и слабые места алгоритма.
- Зрелость алгоритма.
- Одобрение третьими сторонами, такими как [программа проверки алгоритмов NIST](https://csrc.nist.gov/projects/cryptographic-algorithm-validation-program).
- Производительность (как при шифровании, так и при дешифровании).
- Качество доступных библиотек.
- Переносимость алгоритма (т.е. насколько широко он поддерживается).

В некоторых случаях могут существовать нормативные требования, ограничивающие возможности использования алгоритмов, например [FIPS 140-2](https://csrc.nist.gov/csrc/media/publications/fips/140/2/final/documents/fips1402annexa.pdf) или [PCI DSS](https://www.pcisecuritystandards.org/pci_security/glossary#Strong%20Cryptography).

### Пользовательские алгоритмы

Не делайте этого.

### Режимы шифрования

Существуют различные [режимы](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation), которые могут быть использованы для того, чтобы блочные шифры (такие как AES) могли шифровать произвольные объемы данных так же, как и потоковые шифры. Эти режимы имеют различные характеристики безопасности и производительности, и их полное обсуждение выходит за рамки данной шпаргалки. Некоторые из режимов требуют генерировать безопасные векторы инициализации (IVs) и другие атрибуты, но они должны обрабатываться библиотекой автоматически.

Там, где это возможно, всегда следует использовать аутентифицированные режимы. Они обеспечивают гарантии целостности и подлинности данных, а также конфиденциальность. Наиболее часто используемыми аутентифицированными режимами являются **[GCM](https://en.wikipedia.org/wiki/Galois/Counter_Mode)** и **[CCM](https://en.wikipedia.org/wiki/CCM_mode)**, которые следует использовать в первую очередь.

Если GCM или CCM недоступны, то следует использовать режим [CTR](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Counter_%28CTR%29) или [CBC](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_Block_Chaining_%28CBC%29). Поскольку они не дают никаких гарантий подлинности данных, следует применять отдельную аутентификацию, например, с помощью техники [Encrypt-then-MAC](https://en.wikipedia.org/wiki/Authenticated_encryption#Encrypt-then-MAC_%28EtM%29). Необходимо соблюдать осторожность при использовании этого метода с сообщениями [переменной длины](https://en.wikipedia.org/wiki/CBC-MAC#Security_with_fixed_and_variable-length_messages).

[ECB](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#ECB) не следует использовать за исключением очень специфических обстоятельств.

### Случайная прокладка

Для RSA необходимо включить функцию Random Padding. Random Padding также известен как OAEP или Optimal Asymmetric Encryption Padding. Этот класс защиты защищает от атак на известный простой текст, добавляя случайность в начало полезной нагрузки.

В этом случае обычно используется схема подшивки из [PKCS#1](https://wikipedia.org/wiki/RSA_(cryptosystem)#Padding_schemes).

### Безопасная генерация случайных чисел

Случайные числа (или строки) необходимы для различных важных для безопасности функций, таких как генерация ключей шифрования, IVs, идентификаторов сессий, маркеров CSRF или маркеров сброса пароля. Поэтому важно, чтобы они генерировались безопасно и чтобы злоумышленник не мог их угадать и предсказать.

Как правило, компьютеры не могут генерировать действительно случайные числа (без специального оборудования), поэтому большинство систем и языков обеспечивают два различных типа случайности.

Генераторы псевдослучайных чисел (ГПСЧ) обеспечивают низкокачественную случайность, работают гораздо быстрее и могут использоваться для функций, не связанных с безопасностью (например, для упорядочивания результатов на странице или рандомизации элементов пользовательского интерфейса). Однако они **не должны** использоваться для чего-либо, имеющего отношение к безопасности, поскольку злоумышленники часто могут угадать или предсказать результат.

Криптографически защищенные генераторы псевдослучайных чисел (CSPRNG) предназначены для получения случайных данных гораздо более высокого качества (точнее, большего количества энтропии), что делает их безопасными для использования в функциях, чувствительных к безопасности. Однако они медленнее и более требовательны к процессору, и в некоторых случаях могут блокироваться при запросе большого количества случайных данных. Поэтому, если требуется большое количество случайных данных, не связанных с безопасностью, они могут не подойти.

В таблице ниже приведены рекомендуемые алгоритмы для каждого языка, а также небезопасные функции, которые не следует использовать.

| Язык | Небезопасные функции | Криптографически безопасные функции |
|-------------|------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| C | `random()`, `rand()` | [getrandom(2)](http://man7.org/linux/man-pages/man2/getrandom.2.html) |
| Java | `Math.random()`, `StrictMath.random()`, `java.util.Random`, `java.util.SplittableRandom`, `java.util.concurrent.ThreadLocalRandom` | [java.security.SecureRandom](https://docs.oracle.com/javase/8/docs/api/java/security/SecureRandom.html), [java.util.UUID.randomUUID()](https://docs.oracle.com/javase/8/docs/api/java/util/UUID.html#randomUUID--)|
| PHP | `array_rand()`, `lcg_value()`, `mt_rand()`, `rand()`, `uniqid()` | [random_bytes()](https://www.php.net/manual/en/function.random-bytes.php), [Random\Engine\Secure](https://www.php.net/manual/en/class.random-engine-secure.php) в PHP 8, [random_int()](https://www.php.net/manual/en/function.random-int.php) в PHP 7, [openssl_random_pseudo_bytes()](https://www.php.net/manual/en/function.openssl-random-pseudo-bytes.php) в PHP 5 |
| .NET/C# | `Random()` | [RandomNumberGenerator](https://learn.microsoft.com/en-us/dotnet/api/system.security.cryptography.randomnumbergenerator?view=net-6.0) |
| Objective-C | `arc4random()`/`arc4random_uniform()` (Использует шифр RC4), подклассы `GKRandomSource`, rand(), random() | [SecRandomCopyBytes](https://developer.apple.com/documentation/security/1399291-secrandomcopybytes?language=objc) |
| Python | `random()` | [secrets()](https://docs.python.org/3/library/secrets.html#module-secrets) |
| Ruby | `rand()`, `Random` | [SecureRandom](https://ruby-doc.org/stdlib-2.5.1/libdoc/securerandom/rdoc/SecureRandom.html) |
| Go | `rand` с использованием пакета `math/rand` | библиотека [crypto.rand](https://golang.org/pkg/crypto/rand/) |
| Rust | `rand::prng::XorShiftRng` | [rand::prng::chacha::ChaChaRng](https://docs.rs/rand/0.5.0/rand/prng/chacha/struct.ChaChaRng.html) и остальная часть библиотеки Rust [CSPRNGs.](https://docs.rs/rand/0.5.0/rand/prng/index.html#cryptographically-secure-pseudo-random-number-generators-csprngs)|
| Node.js | `Math.random()` | [crypto.randomBytes()](https://nodejs.org/api/crypto.html#cryptorandombytessize-callback), [crypto.randomInt()](https://nodejs.org/api/crypto.html#cryptorandomintmin-max-callback), [crypto.randomUUID()](https://nodejs.org/api/crypto.html#cryptorandomuuidoptions) |

#### UUID и GUID.

Универсальные уникальные идентификаторы (UUID или GUID) иногда используются как быстрый способ генерации случайных строк. Хотя они могут обеспечить приемлемый источник случайности, это будет зависеть от [типа или версии](https://en.wikipedia.org/wiki/Universally_unique_identifier#Versions) создаваемого UUID.

В частности, UUID версии 1 состоят из высокоточной временной метки и MAC-адреса системы, которая их сгенерировала, поэтому они **не случайны** (хотя их трудно угадать, учитывая, что временная метка генерируется с точностью до 100 нс). UUID типа 4 генерируются случайным образом, хотя используется ли для этого CSPRNG, зависит от реализации. Если не известно, что это безопасно в конкретном языке или фреймворке, не следует полагаться на случайность UUID.

### Глубинная оборона

Приложения должны быть спроектированы таким образом, чтобы они оставались безопасными даже в случае отказа криптографических средств управления. Любая информация, которая хранится в зашифрованном виде, также должна быть защищена дополнительными уровнями безопасности. Приложения также не должны полагаться на безопасность зашифрованных параметров URL и должны обеспечивать строгий контроль доступа для предотвращения несанкционированного доступа к информации.

## Управление ключами

### Процессы

Должны быть внедрены (и протестированы) формальные процессы, охватывающие все аспекты управления ключами, включая:

- Генерация и хранение новых ключей.
- Распределение ключей среди необходимых сторон.
- Развертывание ключей на серверах приложений.
- Ротация и вывод из эксплуатации старых ключей

### Генерация ключей

Ключи должны генерироваться случайным образом с помощью криптографически безопасной функции, например, описанной в разделе [Secure Random Number Generation](#secure-random-number-generation). Ключи **не должны** быть основаны на обычных словах или фразах, а также на "случайных" символах, сгенерированных путем нажатия на клавиатуру.

Если используется несколько ключей (например, раздельные ключи для шифрования данных и ключи для шифрования ключей), они должны быть полностью независимы друг от друга.

### Срок службы и ротация ключей

Ключи шифрования следует менять (или ротировать) на основании ряда различных критериев:

- Если известно (или есть подозрения), что предыдущий ключ был взломан.
    - Это также может быть вызвано тем, что человек, имевший доступ к ключу, покинул организацию.
- После истечения определенного периода времени (известного как криптопериод).
    - Существует множество факторов, которые могут повлиять на выбор подходящего криптопериода, включая размер ключа, чувствительность данных и модель угроз системы. Дополнительные рекомендации см. в разделе 5.3 документа [NIST SP 800-57] (https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57pt1r4.pdf).
- После того как ключ был использован для шифрования определенного объема данных.
    - Обычно это `2^35` байт (~34 ГБ) для 64-битных ключей и `2^68` байт (~295 экзабайт) для 128-битного размера блока.
- Если в безопасности, обеспечиваемой алгоритмом, произошли значительные изменения (например, было объявлено о новой атаке).

Как только один из этих критериев будет выполнен, необходимо сгенерировать новый ключ и использовать его для шифрования всех новых данных. Существует два основных подхода к тому, как следует обращаться с существующими данными, которые были зашифрованы с помощью старого ключа (ключей):

1. Расшифровка и повторное шифрование с помощью нового ключа.
2. Пометить каждый элемент идентификатором ключа, который был использован для его шифрования, и хранить несколько ключей, чтобы можно было расшифровать старые данные.

Как правило, предпочтение отдается первому варианту, поскольку он значительно упрощает как код приложения, так и процессы управления ключами; однако он не всегда может быть осуществим. Обратите внимание, что старые ключи обычно следует хранить в течение определенного периода времени после их списания, на случай если потребуется расшифровать старые резервные копии данных.

Важно, чтобы код и процессы, необходимые для ротации ключей, были созданы **до** того, как они потребуются, чтобы в случае компрометации ключи можно было быстро ротировать. Кроме того, должны быть реализованы процессы, позволяющие изменять алгоритм шифрования или библиотеку в случае обнаружения новой уязвимости в алгоритме или реализации.

## Хранилище ключей

Безопасное хранение криптографических ключей - одна из самых сложных проблем, поскольку для расшифровки данных приложению всегда требуется определенный уровень доступа к ключам. Хотя полностью защитить ключи от злоумышленника, полностью скомпрометировавшего приложение, невозможно, можно предпринять ряд шагов, чтобы затруднить получение ключей.

Там, где это возможно, следует использовать механизмы безопасного хранения, предоставляемые операционной системой, фреймворком или поставщиком облачных услуг. К ним относятся:

- Физический аппаратный модуль безопасности (HSM).
- Виртуальный HSM.
- Хранилища ключей, такие как [Amazon KMS](https://aws.amazon.com/kms/) или [Azure Key Vault](https://azure.microsoft.com/en-gb/services/key-vault/).
- Внешний сервис управления секретами, например [Conjur](https://github.com/cyberark/conjur) или [HashiCorp Vault](https://github.com/hashicorp/vault).
- API-интерфейсы безопасного хранения данных, предоставляемые классом [ProtectedData](https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.protecteddata?redirectedfrom=MSDN&view=netframework-4.8) в .NET-фреймворке.

Использование таких типов безопасного хранения имеет множество преимуществ по сравнению с простым размещением ключей в конфигурационных файлах. Конкретные преимущества зависят от используемого решения, но они включают в себя:

- Централизованное управление ключами, особенно в контейнерных средах.
- Легкое вращение и замена ключей.
- Безопасная генерация ключей.
- Упрощение соблюдения нормативных стандартов, таких как FIPS 140 или PCI DSS.
- Это затрудняет злоумышленникам экспорт или кражу ключей.

В некоторых случаях ни один из них не будет доступен, например в среде виртуального хостинга, что означает невозможность получения высокой степени защиты для любых ключей шифрования. Однако следующие основные правила все же можно соблюдать:

- Не вводите ключи в исходный код приложения.
- Не проверяйте ключи в системах контроля версий.
- Защитите файлы конфигурации, содержащие ключи, ограничительными разрешениями.
- Избегайте хранения ключей в переменных окружения, так как они могут быть случайно раскрыты через такие функции, как [phpinfo()](https://www.php.net/manual/en/function.phpinfo.php) или через файл `/proc/self/environ`.

В [Шпаргалке по управлению секретами](Secrets_Management_Cheat_Sheet.md) содержится более подробная информация о безопасном хранении секретов.

### Разделение ключей и данных

По возможности ключи шифрования следует хранить в отдельном от зашифрованных данных месте. Например, если данные хранятся в базе данных, ключи должны храниться в файловой системе. Это означает, что если у злоумышленника есть доступ только к одному из них (например, через обход каталога или SQL-инъекцию), он не сможет получить доступ и к ключам, и к данным.

В зависимости от архитектуры среды можно хранить ключи и данные в отдельных системах, что обеспечит большую степень изоляции.

### Шифрование хранимых ключей

По возможности, ключи шифрования должны храниться в зашифрованном виде. Для этого требуется как минимум два отдельных ключа:

- Ключ шифрования данных (DEK) используется для шифрования данных.
- Ключ шифрования (KEK) используется для шифрования DEK.

Чтобы это было эффективно, KEK должен храниться отдельно от DEK. Зашифрованный DEK может храниться вместе с данными, но его можно будет использовать только в том случае, если злоумышленник сможет получить KEK, который хранится в другой системе.

KEK также должен быть не менее стойким, чем DEK. Руководство [envelope encryption](https://cloud.google.com/kms/docs/envelope-encryption) от Google содержит дополнительные сведения о том, как управлять DEK и KEK.

В более простых архитектурах приложений (например, в средах виртуального хостинга), где KEK и DEK не могут храниться отдельно, ценность такого подхода невелика, поскольку злоумышленник, скорее всего, сможет получить оба ключа одновременно. Однако он может стать дополнительным барьером для неквалифицированных злоумышленников.

Функция выведения ключа (KDF) может использоваться для генерации KEK из предоставленных пользователем данных (например, парольной фразы), которые затем используются для шифрования случайно сгенерированного DEK. Это позволяет легко менять KEK (когда пользователь меняет свою ключевую фразу), не прибегая к повторному шифрованию данных (поскольку DEK остается неизменным).
