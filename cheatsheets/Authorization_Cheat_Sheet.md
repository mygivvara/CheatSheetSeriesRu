# Шпаргалка по авторизации

## Введение

Авторизация может быть определена как «процесс проверки того, что запрашиваемое действие или услуга одобрены для конкретного субъекта» ([NIST](https://csrc.nist.gov/glossary/term/authorization)).  Авторизация отличается от аутентификации, которая представляет собой процесс проверки личности субъекта. При проектировании и разработке программного решения важно помнить об этих различиях. Пользователь, прошедший аутентификацию (например, предоставив имя пользователя и пароль), часто не имеет права доступа ко всем ресурсам и выполнению всех действий, которые технически возможны в системе. Например, веб-приложение может иметь как обычных пользователей, так и администраторов, причем администраторы могут выполнять действия, которые обычные пользователи не могут, даже если они прошли аутентификацию. Кроме того, аутентификация не всегда требуется для доступа к ресурсам; неаутентифицированный пользователь может иметь доступ к определенным публичным ресурсам, таким как изображение, страница входа или даже целое веб-приложение.

Цель этого руководства — помочь разработчикам внедрять логику авторизации, которая будет надежной, соответствующей бизнес-контексту приложения, поддерживаемой и масштабируемой. Рекомендации, представленные в этом руководстве, должны быть применимы на всех этапах жизненного цикла разработки и достаточно гибкими, чтобы соответствовать потребностям различных сред разработки.

Ошибки, связанные с логикой авторизации, вызывают особую озабоченность в веб-приложениях. Нарушение контроля доступа было признано самой серьезной уязвимостью безопасности веб-приложений в [OWASP Top 10 2021](https://owasp.org/Top10/A01_2021-Broken_Access_Control/) и было обозначено как имеющее «Высокую» вероятность эксплуатации программой CWE компании [MITRE](https://cwe.mitre.org/data/definitions/285.html). Более того, согласно [10-му отчёту Veracode о состоянии безопасности программного обеспечения](https://www.veracode.com/sites/default/files/pdf/resources/sossreports/state-of-software-security-volume-10-veracode-report.pdf), контроль доступа оказался среди наиболее распространённых рисков из Топ-10 OWASP, участвующих в эксплуатациях и инцидентах безопасности, несмотря на то, что был одним из наименее распространённых среди рассмотренных.

Потенциальное воздействие от эксплуатации уязвимостей авторизации сильно варьируется как по форме, так и по тяжести. Злоумышленники могут читать, создавать, изменять или удалять ресурсы, которые должны были быть защищены (тем самым ставя под угрозу их конфиденциальность, целостность и/или доступность); однако реальное влияние таких действий напрямую зависит от критичности и чувствительности скомпрометированных ресурсов. Таким образом, бизнес-стоимость успешно эксплуатируемой уязвимости авторизации может варьироваться от очень низкой до крайне высокой.

Как полностью неаутентифицированные внешние лица, так и аутентифицированные (но не обязательно авторизованные) пользователи могут воспользоваться слабостями авторизации. Хотя честные ошибки или небрежность со стороны добросовестных субъектов могут способствовать обходам авторизации, для полной реализации угроз контроля доступа обычно требуется злой умысел. Горизонтальное повышение привилегий (т.е. возможность доступа к ресурсам другого пользователя) является особенно распространённой слабостью, которую может использовать аутентифицированный пользователь. Ошибки, связанные с управлением авторизацией, могут позволить как злонамеренным инсайдерам, так и аутсайдерам просматривать, изменять или удалять конфиденциальные ресурсы всех форм (записи баз данных, статические файлы, персонально идентифицируемая информация (PII) и т. д.) или выполнять действия, такие как создание новой учетной записи или инициирование дорогостоящего заказа, которые они не должны иметь права выполнять. Более того, если журналы, связанные с контролем доступа, не настроены должным образом, такие нарушения авторизации могут остаться незамеченными или, по крайней мере, неотслеживаемыми до конкретного лица или группы.

## Рекомендации

### Принцип наименьших привелегий

Принцип наименьших привилегий относится к концепции предоставления пользователям только тех минимальных привилегий, которые необходимы для выполнения их работы. Хотя, возможно, он чаще всего применяется в системном администрировании, этот принцип также имеет значение для разработчиков программного обеспечения. Принцип наименьших привилегий должен применяться как по горизонтали, так и по вертикали. Например, хотя бухгалтер и торговый представитель могут занимать один и тот же уровень в иерархии организации, оба они требуют доступа к разным ресурсам для выполнения своей работы. Бухгалтеру, вероятно, не должен быть предоставлен доступ к базе данных клиентов, а торговому представителю не следует предоставлять доступ к данным о заработной плате. Точно так же руководителю отдела продаж, скорее всего, понадобится более привилегированный доступ, чем его подчинённым.

Нарушение принципа наименьших привилегий в приложении может поставить под угрозу конфиденциальность конфиденциальных ресурсов. Стратегии снижения риска применяются в основном на этапе архитектуры и проектирования (см. [CWE-272](https://cwe.mitre.org/data/definitions/272.html)); однако принцип должен соблюдаться на протяжении всего жизненного цикла разработки программного обеспечения (SDLC).

Рассмотрите следующие моменты и лучшие практики:

- На этапе проектирования убедитесь, что границы доверия определены. Перечислите типы пользователей, которые будут иметь доступ к системе, ресурсы, которые будут доступны, и операции (например, чтение, запись, обновление и т. д.), которые могут выполняться над этими ресурсами. Для системы ABAC (на основе атрибутов) убедитесь, что все категории атрибутов учтены. Например, торговому представителю может потребоваться доступ к базе данных клиентов из внутренней сети в рабочее время, но не из дома в полночь.
- Создайте тесты, которые проверяют правильность применения разрешений, определённых на этапе проектирования.
- После развертывания приложения периодически проверяйте разрешения в системе на наличие «накопления привилегий»; т.е. убедитесь, что привилегии пользователей в текущей среде не превышают те, что были определены на этапе проектирования (с учётом любых официально утверждённых изменений).
- Помните, что предоставлять пользователям дополнительные разрешения легче, чем отбирать те, которыми они уже пользовались. Тщательное планирование и реализация принципа наименьших привилегий на ранних стадиях SDLC могут помочь уменьшить риск необходимости отзыва разрешений, которые позже будут сочтены чрезмерно широкими.

### Отказ по умолчанию

Даже если ни одно из правил контроля доступа не было явно выполнено, приложение не может оставаться нейтральным, когда субъект запрашивает доступ к определённому ресурсу. Приложение всегда должно принимать решение — явно или неявно — либо отклонить, либо разрешить запрашиваемый доступ. Логические ошибки и другие ошибки, связанные с контролем доступа, могут возникать, особенно когда требования к доступу сложны; следовательно, не следует полагаться только на явно определённые правила для соответствия всем возможным запросам. В целях безопасности приложение должно быть настроено на отказ в доступе по умолчанию.

Рассмотрите следующие моменты и лучшие практики:

- Примите менталитет «отказа по умолчанию» как на этапе начальной разработки, так и при добавлении новой функциональности или ресурсов в приложение. Должно быть возможно явно обосновать, почему конкретное разрешение было предоставлено определённому пользователю или группе, а не предполагать, что доступ является положением по умолчанию.
- Хотя некоторые фреймворки или библиотеки сами могут придерживаться стратегии отказа по умолчанию, предпочтительнее явная конфигурация, а не полагаться на значения по умолчанию фреймворков или библиотек. Логика и значения по умолчанию стороннего кода могут изменяться со временем, без полного знания разработчика или понимания последствий изменений для конкретного проекта.
  
### Проверяйте разрешения для каждого запроса

Разрешения должны проверяться корректно при каждом запросе, независимо от того, был ли запрос инициирован с помощью AJAX-скрипта, на стороне сервера или из любого другого источника. Технология, используемая для выполнения таких проверок, должна обеспечивать глобальную конфигурацию на уровне всего приложения, а не требовать применения проверки к каждому методу или классу в отдельности. Помните, что злоумышленнику достаточно найти только один способ обхода. Даже если пропущена всего одна проверка контроля доступа, конфиденциальность и/или целостность ресурса могут быть под угрозой. Правильная проверка разрешений только для большинства запросов недостаточна. Конкретные технологии, которые могут помочь разработчикам выполнять такие согласованные проверки разрешений, включают:

- [Фильтры Java/Jakarta EE](https://jakarta.ee/specifications/platform/8/apidocs/javax/servlet/Filter.html) включая реализации в [Spring Security](https://docs.spring.io/spring-security/site/docs/5.4.0/reference/html5/#servlet-security-filters)
- [Промежуточное ПО (Middleware) в Django Framework](https://docs.djangoproject.com/en/4.0/ref/middleware/)
- [Фильтры в .NET Core](https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/filters?view=aspnetcore-3.1#authorization-filters)
- [Промежуточное ПО в Laravel PHP Framework](https://laravel.com/docs/8.x/middleware)

### Тщательно проверяйте логику авторизации выбранных инструментов и технологий, внедряйте пользовательскую логику, если это необходимо

Современные разработчики имеют доступ к огромному количеству библиотек, платформ и фреймворков, которые позволяют им легко интегрировать сложную логику в свои приложения. Однако эти фреймворки и библиотеки не должны рассматриваться как быстрая панацея от всех проблем разработки; разработчики обязаны использовать такие фреймворки ответственно и разумно. Две общие проблемы, связанные с выбором фреймворка/библиотеки, касающиеся надлежащего контроля доступа, включают неправильную конфигурацию или отсутствие конфигурации со стороны разработчика, а также уязвимости внутри самих компонентов (см. [A6](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A6-Security_Misconfiguration) и [A9](https://owasp.org/www-project-top-ten/2017/A9_2017-Using_Components_with_Known_Vulnerabilities.html) для получения общей информации по этим темам).

Даже в ином случае безопасно разработанное приложение уязвимости в сторонних компонентах могут позволить злоумышленнику обойти обычные механизмы авторизации. Такие опасения не обязательно ограничиваются неопробованными или плохо поддерживаемыми проектами, но могут затрагивать даже самые надежные и популярные библиотеки и фреймворки. Написание сложного, безопасного программного обеспечения — это трудно. Даже самые компетентные разработчики, работающие над высококачественными библиотеками и фреймворками, допускают ошибки. Предположите, что любой сторонний компонент, который вы включаете в приложение, может содержать или стать уязвимым для авторизации. Важные соображения включают:

- Создание, поддержание и следование процессам по выявлению и реагированию на уязвимые компоненты.
- Интеграция таких инструментов, как [Dependency Check](https://owasp.org/www-project-dependency-check/)  в жизненный цикл разработки программного обеспечения (SDLC) и рассмотрение возможности подписки на каналы данных от поставщиков, [NVD](https://nvd.nist.gov/vuln/data-feeds), или других соответствующих источников.
- Внедрение многоуровневой защиты (Defense in Depth). Не полагайтесь на какой-либо один фреймворк, библиотеку, технологию или контроль как на единственный механизм обеспечения надлежащего контроля доступа.

Неправильная конфигурация (или её полное отсутствие) — это ещё одна важная область, в которой компоненты, на которых строят разработчики, могут привести к нарушению авторизации. Эти компоненты, как правило, предназначены для использования в относительно широких целях и для привлечения широкой аудитории. Для всех, кроме самых простых случаев использования, эти фреймворки и библиотеки должны быть настроены или дополнены дополнительной логикой, чтобы удовлетворить уникальные требования конкретного приложения или среды. Это соображение особенно важно, когда речь идет о требованиях безопасности, включая авторизацию. Основные аспекты настройки авторизации включают:

- Потратьте время на тщательное изучение любой технологии, на которой вы строите логику авторизации. Анализируйте возможности технологий, понимая, что *логика авторизации, предоставленная компонентом, может быть недостаточной для выполнения конкретных требований безопасности вашего приложения*. Полагаться на готовую логику может быть удобно, но это не означает, что она будет достаточной. Поймите, что может потребоваться собственная логика авторизации для удовлетворения требований безопасности приложения.
- Не позволяйте возможностям любой библиотеки, платформы или фреймворка определять ваши требования к авторизации. Скорее, требования к авторизации должны определяться в первую очередь, а затем сторонние компоненты могут анализироваться с учетом этих требований.
- Не полагайтесь на настройки по умолчанию.
- Проверяйте конфигурацию. Не следует просто предполагать, что любая настройка, выполненная для стороннего компонента, будет работать именно так, как предполагается, в вашей конкретной среде. Документация может быть неправильно понята, неопределённа, устарела или просто неточна.

### Отдавайте предпочтение управлению доступом на основе атрибутов и отношений, а не ролей

В программной инженерии широко используются две основные формы управления доступом: Управление доступом на основе ролей (RBAC) и управление доступом на основе атрибутов (ABAC). Существует и третья, более новая, модель, которая набирает популярность: Управление доступом на основе отношений (ReBAC). Выбор между моделями имеет значительное влияние на весь жизненный цикл разработки программного обеспечения и должен быть сделан как можно раньше.

- RBAC — это модель управления доступом, в которой доступ предоставляется или отклоняется на основе ролей, назначенных пользователю. Разрешения не назначаются напрямую сущности; скорее, разрешения ассоциируются с ролью, и сущность наследует разрешения любой роли, назначенной ей. Как правило, отношения между ролями и пользователями могут быть многими ко многим, а роли могут быть иерархичными по своей природе.

- ABAC может быть определен как модель управления доступом, в которой «запросы субъекта на выполнение операций над объектами предоставляются или отклоняются на основе назначенных атрибутов субъекта, назначенных атрибутов объекта, условий среды и набора политик, которые определены с точки зрения этих атрибутов и условий» ([NIST SP 800-162](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-162.pdf), стр. 7). Как определено в NIST SP 800-162, атрибуты — это просто характеристики, которые могут быть представлены в виде пар имя-значение и назначены субъекту, объекту или среде. Должность, время суток, название проекта, MAC-адрес и дата создания — это лишь малая часть возможных атрибутов, которые подчеркивают гибкость реализаций ABAC.

- ReBAC (Relationship-Based Access Control) — это модель управления доступом, которая предоставляет доступ на основе отношений между ресурсами. Например, доступ к редактированию поста может быть предоставлен только пользователю, который его создал. Это особенно необходимо в приложениях социальных сетей, таких как Twitter или Facebook, где пользователи хотят ограничить доступ к своим данным (например, твитам или постам) только тем людям, которых они выбрали (друзья, семья, подписчики).

Хотя RBAC (Role-Based Access Control) имеет долгую историю и остается популярной среди разработчиков программного обеспечения, для разработки приложений предпочтительнее использовать модели ABAC (Attribute-Based Access Control) и ReBAC. Их преимущества по сравнению с RBAC включают:

- **Поддержка детализированной и сложной логики с использованием булевых операций**. В RBAC решения о доступе принимаются на основе наличия или отсутствия ролей; то есть основная характеристика запрашивающей сущности — это назначенные ей роли. Такая простая логика плохо подходит для принятия решений об уровне доступа на уровне объектов или горизонтальных решений, требующих учета множества факторов.

    - ABAC значительно расширяет как количество, так и типы характеристик, которые могут быть учтены. В ABAC «роль» или должностная функция может быть одним из атрибутов, назначенных субъекту, но не обязательно должна учитываться в изоляции (или вовсе не рассматриваться, если эта характеристика не имеет отношения к конкретному запрашиваемому доступу). Более того, ABAC может учитывать динамические атрибуты, такие как время суток, тип используемого устройства и географическое положение. Примеры, когда ABAC может удовлетворять требованиям к управлению доступом, которые трудно реализовать с помощью RBAC: отказ в доступе к чувствительному ресурсу вне рабочего времени или если пользователь не прошел обязательное обучение в последние сроки. Таким образом, ABAC более эффективен, чем RBAC, в соблюдении принципа наименьших привилегий.
    - ReBAC, поскольку он поддерживает назначение отношений между прямыми объектами и пользователями (а не только ролью), позволяет создавать детализированные разрешения. Некоторые системы также поддерживают алгебраические операторы, такие как AND и NOT, чтобы выражать политики, например, «если у этого пользователя есть отношение X, но нет отношения Y с объектом, то предоставить доступ».

- **Надёжность**. В крупных проектах или когда присутствует множество ролей, легко пропустить или неправильно выполнить проверку ролей ([OWASP C7: Enforce Access Controls](https://owasp.org/www-project-proactive-controls/v3/en/c7-enforce-access-controls)). Это может привести как к избыточному, так и к недостаточному доступу. Это особенно актуально в реализации RBAC, где отсутствует иерархия ролей, и для достижения желаемого эффекта необходимо объединять несколько проверок ролей (например, `if(user.hasAnyRole("SUPERUSER", "ADMIN", "ACCT_MANAGER"))`).
- **Скорость**. В RBAC может возникнуть «взрыв ролей», когда система определяет слишком много ролей. Если пользователи отправляют свои учетные данные и роли через такие средства, как HTTP-заголовки, которые имеют ограничения по размеру, может не хватить места для включения всех ролей пользователя. Решением этой проблемы является отправка только идентификатора пользователя, а затем приложение извлекает его роли, что увеличивает задержку каждого запроса.
- **Поддержка многопользовательской среды и запросов между организациями**. RBAC плохо подходит для сценариев, когда различные организации или клиенты нуждаются в доступе к одному и тому же набору защищенных ресурсов. Для удовлетворения таких требований в RBAC потребуются чрезвычайно громоздкие методы, такие как настройка правил для каждого клиента в многопользовательской среде или предварительное предоставление идентификаторов для межорганизационных запросов ([OWASP C7](https://owasp.org/www-project-proactive-controls/v3/en/c7-enforce-access-controls); [NIST SP 800-162](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-162.pdf)). Напротив, при условии согласованного определения атрибутов, ABAC позволяет принимать решения о доступе «в одной или нескольких инфраструктурах при соблюдении надлежащего уровня безопасности» ([NIST SP 800-162](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-162.pdf), стр. 6).
- **Удобство управления**. Хотя начальная настройка RBAC часто проще, чем ABAC, это краткосрочное преимущество быстро исчезает по мере увеличения масштаба и сложности системы. В начале может быть достаточно нескольких простых ролей, таких как пользователь и администратор, но это вряд ли будет справедливо в течение длительного времени для производственных приложений. По мере увеличения количества ролей как тестирование, так и аудит — критические процессы для установления доверия к кодовой базе и логике — становятся более сложными ([OWASP C7](https://owasp.org/www-project-proactive-controls/v3/en/c7-enforce-access-controls)). Напротив, ABAC и ReBAC гораздо более выразительны, включают атрибуты и булевую логику, лучше отражающие реальные проблемы, их легче обновлять при изменении требований к управлению доступом, а также они способствуют разделению управления политикой, реализации и предоставления идентификаторов ([NIST SP 800-162](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-162.pdf); см. также [XACML-V3.0](http://docs.oasis-open.org/xacml/3.0/xacml-3.0-core-spec-os-en.html), стандарт, подчёркивающий эти преимущества).

### Убедитесь, что идентификаторы объектов недоступны даже в случае их угадывания и не могут быть изменены

Приложения часто раскрывают внутренние идентификаторы объектов (например, номера счетов или первичные ключи в базе данных), которые используются для поиска и ссылок на объект. Эти идентификаторы могут быть представлены в виде параметров запроса, переменных пути, «скрытых» полей формы или в другом виде. Например:

```https://mybank.com/accountTransactions?acct_id=901```

Исходя из этого URL-адреса, можно разумно предположить, что приложение вернет список транзакций и что возвращенные транзакции будут ограничены определенным счетом — тем, который указан в параметре `acct_id` Но что произойдет, если пользователь изменит значение параметра `acct_id`  на другое, например, `523`?  Сможет ли пользователь просматривать транзакции, связанные с другим счетом, даже если он ему не принадлежит? Если нет, то будет ли ошибка просто результатом того, что счет "523" не существует/не найден, или это будет связано с неудачной проверкой контроля доступа? Хотя этот пример может быть чрезмерно упрощен, он иллюстрирует очень распространенную ошибку безопасности в разработке приложений — [CWE 639: обход авторизации с помощью ключа, управляемого пользователем](https://cwe.mitre.org/data/definitions/639.html).  При эксплуатации эта слабость может привести к обходу авторизации, горизонтальному повышению привилегий и, реже, вертикальному повышению привилегий (см. [CWE-639](https://cwe.mitre.org/data/definitions/639.html)). Этот тип уязвимости также представляет собой форму небезопасной прямой ссылки на объект (IDOR). Следующие параграфы описывают эту слабость и возможные меры противодействия.

В приведенном выше примере идентификатор поиска не только был раскрыт пользователю и легко изменялся, но также, по-видимому, имел довольно предсказуемое, возможно, последовательное значение. Хотя можно использовать различные методы для маскирования или рандомизации этих идентификаторов и сделать их трудными для угадывания, такой подход сам по себе, как правило, недостаточен. Пользователь не должен иметь возможность получить доступ к ресурсу, к которому у него нет разрешения, просто потому, что он может угадать и изменить идентификатор объекта в параметре запроса или в другом месте. Вместо того чтобы полагаться на некую форму безопасности через неясность, следует сосредоточиться на контроле доступа к самим объектам и/или идентификаторам. Рекомендуемые меры для устранения этой слабости включают:

- Избегайте раскрытия идентификаторов пользователю, когда это возможно. Например, возможно получить некоторые объекты, такие как данные учетной записи, исключительно на основе идентификации и атрибутов текущего аутентифицированного пользователя (например, с использованием информации, содержащейся в безопасно реализованном JSON Web Token (JWT) или на стороне сервера).
- Реализуйте косвенные ссылки, зависящие от пользователя/сессии, используя такие инструменты, как [OWASP ESAPI](https://owasp.org/www-project-enterprise-security-api/) (см. [OWASP 2013 Top 10 - A4 Insecure Direct Object References](https://wiki.owasp.org/index.php/Top_10_2013-A4-Insecure_Direct_Object_References))
- Выполняйте проверки контроля доступа на *каждом* запросе для *конкретного* объекта или функционала, к которому осуществляется доступ. То, что у пользователя есть доступ к объекту определенного типа, не означает, что он должен иметь доступ ко всем объектам этого типа.

### Применение проверок авторизации к статическим ресурсам

Необходимость обеспечения безопасности статических ресурсов часто недооценивается или по крайней мере отходит на второй план перед другими проблемами безопасности. Хотя защита баз данных и аналогичных хранилищ данных справедливо получает значительное внимание от команд, заботящихся о безопасности, статические ресурсы также должны быть должным образом защищены. Хотя незащищенные статические ресурсы являются проблемой для веб-сайтов и веб-приложений всех типов, в последние годы особое внимание привлекают плохо защищенные ресурсы в облачных хранилищах (таких как Amazon S3). При обеспечении безопасности статических ресурсов учитывайте следующее:

- Убедитесь, что статические ресурсы включены в политику управления доступом. Тип защиты, необходимый для статических ресурсов, в значительной степени будет зависеть от контекста. Возможно, вполне допустимо, чтобы некоторые статические ресурсы были доступны публично, в то время как другие должны быть доступны только при наличии очень ограниченного набора атрибутов пользователя и окружающей среды. Поэтому важно понимать, какой тип данных содержится в рассматриваемых ресурсах. Подумайте, следует ли установить формальную схему классификации данных и включить её в логику управления доступом (см. [здесь](https://resources.infosecinstitute.com/information-and-asset-classification/) для обзора классификации данных).
- Убедитесь, что любые облачные сервисы, используемые для хранения статических ресурсов, защищены с помощью параметров конфигурации и инструментов, предоставляемых поставщиком. Ознакомьтесь с документацией облачного провайдера (см. рекомендации от [AWS](https://aws.amazon.com/premiumsupport/knowledge-center/secure-s3-resources/), [Google Cloud](https://cloud.google.com/storage/docs/best-practices#security) и [Azure](https://docs.microsoft.com/en-us/azure/storage/blobs/security-recommendations)  для получения конкретных деталей реализации).
- При возможности защищайте статические ресурсы с помощью той же логики и механизмов управления доступом, которые используются для защиты других ресурсов и функционала приложения.

### Убедитесь, что проверки авторизации выполняются в правильном месте

Разработчики никогда не должны полагаться на проверки контроля доступа на стороне клиента. Такие проверки могут быть допустимыми для улучшения пользовательского опыта, но они никогда не должны быть решающим фактором при предоставлении или отказе в доступе к ресурсу; логику на стороне клиента часто легко обойти. Проверки контроля доступа должны выполняться на серверной стороне, на шлюзе или с использованием serverless функций (см. [OWASP ASVS 4.0.3, V1.4.1 and V4.1.1](https://raw.githubusercontent.com/OWASP/ASVS/v4.0.3/4.0/OWASP%20Application%20Security%20Verification%20Standard%204.0.3-en.pdf))

### Безопасное завершение при сбоях проверок авторизации

Непрошедшие проверки управления доступом — нормальное явление в защищенном приложении; следовательно, разработчики должны планировать такие отказы и обрабатывать их безопасным образом. Неправильная обработка таких отказов может привести к тому, что приложение окажется в непредсказуемом состоянии ([CWE-280: Неправильная обработка недостаточных разрешений или привилегий](https://cwe.mitre.org/data/definitions/280.html)). Конкретные рекомендации включают следующее:

- Убедитесь, что все исключения и неудачные проверки управления доступом обрабатываются, независимо от того, насколько маловероятными они кажутся ([OWASP Top Ten Proactive Controls C10: Обработка всех ошибок и исключений](https://owasp.org/www-project-proactive-controls/v3/en/c10-errors-exceptions.html)). Это не означает, что приложение всегда должно пытаться «исправить» неудачную проверку; часто достаточно простого сообщения или кода состояния HTTP.
- Централизуйте логику обработки неудачных проверок управления доступом.
- Проверьте обработку исключений и ошибок авторизации. Убедитесь, что такие сбои, независимо от их маловероятности, не приводят программное обеспечение в нестабильное состояние, которое может привести к обходу авторизации.

### Реализуйте надлежащее ведение логов

Ведение логов — один из важнейших детективных средств контроля в безопасности приложений; недостаточное ведение логов и мониторинг признаны одними из самых критических рисков безопасности в [OWASP Top 10 2021](https://owasp.org/Top10/A09_2021-Security_Logging_and_Monitoring_Failures/). Соответствующие логи могут не только обнаружить вредоносную активность, но и быть ценными ресурсами в постинцидентных расследованиях, использоваться для устранения проблем с управлением доступом и другими вопросами безопасности, а также полезны в аудите безопасности. Хотя их легко упустить из виду на этапе начального проектирования и требований, ведение логов — важный компонент целостной безопасности приложений и должно быть включено на всех этапах жизненного цикла разработки программного обеспечения (SDLC). Рекомендации по ведению логов включают следующее:

- Используйте логирование в согласованных, хорошо определенных форматах, которые легко поддаются анализу. Согласно [OWASP Top Ten Proactive Controls C9](https://owasp.org/www-project-proactive-controls/v3/en/c9-security-logging.html), [Apache Logging Services](https://logging.apache.org/) — это пример проекта, который предоставляет поддержку для множества языков и платформ.
- Тщательно определите объем информации для ведения логов. Это следует определять в зависимости от конкретной среды и требований приложения. И слишком большое, и слишком маленькое количество логов может считаться слабостью безопасности (см. [CWE-778](https://cwe.mitre.org/data/definitions/778.html) и [CWE-779](https://cwe.mitre.org/data/definitions/779.html)). Недостаточное ведение логов может привести к тому, что вредоносная активность останется незамеченной и значительно снизит эффективность анализа после инцидента. Чрезмерное ведение логов может не только перегружать ресурсы и приводить к чрезмерному количеству ложных срабатываний, но и может привести к ненужному ведению логов конфиденциальных данных.
- Убедитесь, что часы и часовые пояса синхронизированы между системами. Точность важна для воссоздания последовательности атаки во время и после инцидента.
- Рассмотрите возможность интеграции логов приложения в централизованный сервер логов или SIEM.

### Создание модульных и интеграционных тестов для логики авторизации

Модульное и интеграционное тестирование необходимы для проверки того, что приложение работает должным образом и стабильно в условиях изменений. Недостатки в логике управления доступом могут быть скрытыми, особенно когда требования сложны; однако даже небольшая логическая или конфигурационная ошибка в управлении доступом может привести к серьезным последствиям. Хотя они не заменяют специализированные тесты безопасности или тесты на проникновение (см. [OWASP WSTG 4.5](https://owasp.org/www-project-web-security-testing-guide/v42/4-Web_Application_Security_Testing/05-Authorization_Testing/README) для отличного руководства по этой теме, связанной с управлением доступом), автоматическое модульное и интеграционное тестирование логики управления доступом может помочь уменьшить количество недостатков безопасности, которые попадают в производство. Эти тесты хорошо подходят для выявления «легкодоступных» проблем безопасности, но не более сложных векторов атак ([OWASP SAMM: Security Testing](https://owaspsamm.org/model/verification/security-testing/)).

Модульное и интеграционное тестирование должны стремиться к включению многих концепций, рассмотренных в этом документе. Например, доступ по умолчанию должен быть запрещен? Завершается ли приложение безопасно, если проверка управления доступом не выполняется, даже в ненормальных условиях? Правильно ли соблюдаются политики ABAC? Хотя простые модульные и интеграционные тесты никогда не заменят ручное тестирование, проводимое квалифицированным хакером, они являются важным инструментом для быстрого выявления и исправления проблем безопасности с гораздо меньшими затратами ресурсов, чем ручное тестирование.

## Источники

### ABAC

- [ABAC with Spring Security](https://dzone.com/articles/simple-attribute-based-access-control-with-spring)

- [What is ABAC? Implementation patterns and examples](https://www.osohq.com/learn/what-is-attribute-based-access-control-abac)

- [NIST Special Publication 800-162 Guide to Attribute Based Access Control (ABAC) Definition and Considerations](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-162.pdf)
  
- [NIST SP 800-178 A Comparison of Attribute Based Access Control (ABAC) Standards for Data Service Applications](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-178.pdf)
  
- [NIST SP 800-205 Attribute Considerations for Access Control Systems](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-205.pdf)

- [XACML-V3.0](http://docs.oasis-open.org/xacml/3.0/xacml-3.0-core-spec-os-en.html) for standard that highlights these benefits)

### Общее

- [OWASP Application Security Verification Standard 4.0 (especially see V4: Access Control Verification Requirements)](https://raw.githubusercontent.com/OWASP/ASVS/v4.0.3/4.0/OWASP%20Application%20Security%20Verification%20Standard%204.0.3-en.pdf)

- [OWASP Web Security Testing Guide - 4.5 Authorization Testing](https://owasp.org/www-project-web-security-testing-guide/v42)

### Принцип наименьших привелегий

- [Least Privilege](https://us-cert.cisa.gov/bsi/articles/knowledge/principles/least-privilege)

### RBAC

- [Role-Based Access Controls](https://csrc.nist.gov/CSRC/media/Publications/conference-paper/1992/10/13/role-based-access-controls/documents/ferraiolo-kuhn-92.pdf)

### ReBAC

- [Relationship-Based Access Control (ReBAC)](https://www.osohq.com/academy/relationship-based-access-control-rebac)
- [Google Zanzibar](https://zanzibar.academy/)
