# Шпаргалка по ужесточению цепочки инструментов C

## Введение

Ужесточение цепочки инструментов на основе C — это настройка параметров проекта, которая поможет вам создать надежный и безопасный код при использовании языков C, C++ и Objective C в различных средах разработки. Эта статья рассматривает цепочки инструментов Microsoft и GCC для языков C, C++ и Objective C. Мы проведем вас через шаги, которые необходимо предпринять для создания исполняемых файлов с более устойчивой защитой и повышенной интеграцией с доступными средствами безопасности платформы. Эффективная настройка цепочки инструментов также означает, что ваш проект будет иметь ряд преимуществ в процессе разработки, включая улучшенные предупреждения, статический анализ и самодиагностику кода.

Есть четыре области, которые нужно рассмотреть при ужесточении цепочки инструментов: конфигурация, препроцессор, компилятор и компоновщик. Почти все эти области часто упускаются или игнорируются при настройке проекта. Эта проблема широко распространена и касается практически всех проектов, включая проекты, настроенные автоматически, на основе makefile, Eclipse, Visual Studio и Xcode. Важно устранить пробелы на этапе конфигурации и сборки, потому что на некоторых платформах трудно или невозможно [обавить защиту к уже распространенному исполняемому файлу](https://sourceware.org/ml/binutils/2012-03/msg00309.html) on some platforms.

Эта статья носит предписывающий характер и не будет спорить о семантике или предполагать поведение. Некоторые сведения, такие как мотивация и происхождение комитета C/C++ для [`program diagnostics`, `NDEBUG`, `assert`, и `abort()`](https://groups.google.com/a/isocpp.org/forum/?fromgroups=#!topic/std-discussion/ak8e1mzBhGs), кажутся утраченными, как сказание из "Властелина колец". Таким образом, статья определит семантику (например, философию конфигураций сборки "отладка" и "релиз"), назначит поведение (например, что должно делать утверждение в конфигурациях сборки "отладка" и "релиз") и представит позицию. Если вы считаете, что позиция слишком агрессивна, вы можете ослабить её в соответствии с вашими предпочтениями.

Безопасная цепочка инструментов не является универсальным решением. Это всего лишь один элемент общей стратегии в процессе разработки, который поможет обеспечить успех. Она будет дополнять существующие процессы, такие как статический анализ, динамический анализ, безопасное кодирование, негативные тестовые наборы и т. д. Инструменты, такие как Valgrind и Helgrind, все равно будут нужны, и проект по-прежнему будет требовать прочных проектных решений и архитектур.

Проект OWASP [ESAPI C++](https://code.google.com/p/owasp-esapi-cplusplus/source) pиспользует свой собственный опыт. Многие примеры, которые вы увидите в этой статье, взяты непосредственно из проекта ESAPI C++.

Наконец, для тех, кто предпочитает краткое изложение материала, доступна шпаргалка. Пожалуйста, посетите [Шпаргалку по ужесточению цепочки инструментов C](C-Based_Toolchain_Hardening_Cheat_Sheet.md) для сокращенной версии.

## Мудрость

Код **должен** быть правильным. Он **должен** быть безопасным. Он **может** быть эффективным.

[Доктор Джон Бентли](https://en.wikipedia.org/wiki/Jon_Bentley): _"Если код не обязательно должен быть правильным, я могу сделать его настолько быстрым, насколько вы хотите"_.

[Dr. Гэри МакГроу](https://en.wikipedia.org/wiki/Gary_McGraw): _"Не полагайтесь исключительно на функции и средства безопасности для создания безопасного программного обеспечения, поскольку безопасность является свойством всей системы в целом и, следовательно, зависит от правильного построения и интеграции всех ее частей"_.

## Конфигурация

Конфигурация — это первая возможность настроить ваш проект на успех. Вам нужно не только настроить проект для достижения целей надежности и безопасности, но и правильно настроить интегрируемые библиотеки. Обычно у вас есть три варианта. Во-первых, вы можете использовать утилиты автоматической конфигурации, если работаете в Linux или Unix. Во-вторых, вы можете написать makefile вручную. Это преимущественно используется в Linux, macOS и Unix, но применяется и к Windows. Наконец, вы можете использовать интегрированную среду разработки (IDE).

### Конфигурации сборки

На этом этапе процесса следует сосредоточиться на настройке двух сборок: отладочной и релизной. Отладка будет использоваться для разработки и включать полную инструментализацию. Релиз будет настроен для производства. Разница между двумя настройками обычно заключается в _уровне оптимизации_ и _уровне отладки_. A third build configuration is Test, and it's usually a special case of Release.

Для отладочных и релизных сборок настройки обычно диаметрально противоположны. Отладочные конфигурации не имеют оптимизаций и содержат полную отладочную информацию, в то время как релизные сборки включают оптимизации и минимальную или умеренную отладочную информацию. Кроме того, отладочный код имеет полные утверждения (assertions) и дополнительную интеграцию библиотек, таких как mudflaps и malloc-защитники, такие как `dmalloc`.

Тестовая конфигурация часто является релизной конфигурацией, которая делает всё публичным для тестирования и создает тестовую оболочку. Например, все функции-члены, которые являются публичными (в классе C++), и все интерфейсы (библиотеки или общие объекты) должны быть доступны для тестирования. Многие сторонники объектно-ориентированного подхода выступают против тестирования приватных интерфейсов, но здесь речь идет не об объектно-ориентированности. Это касается создания надежного и безопасного программного обеспечения.

[GCC 4.8](https://gcc.gnu.org/gcc-4.8/changes.html) представил оптимизацию `-Og`. Учтите, что это всего лишь оптимизация, и все равно требуется обычный уровень отладки через `-g`.

#### Отладочные сборки

Отладочные сборки - это то, где разработчики проводят большую часть своего времени при проверке проблем, поэтому такая сборка должна концентрировать силы и инструменты или быть "мультипликатором силы". Хотя многие этого не осознают, отладочный код ценится выше, чем релизный, потому что он дополнен дополнительной инструментализацией. Отладочная инструментализация позволяет программе практически "самоотлаживаться" и помогает ловить ошибки, такие как неверные параметры, неудачные вызовы API и проблемы с памятью.

Самоотлаживающийся код сокращает время на устранение неполадок и отладку. Сокращение времени под отладчиком означает, что у вас остается больше времени для разработки и реализации новых функций. Если код проверен без отладочной инструментализации, его следует исправить, добавив инструментализацию, или отклонить.

В GCC оптимизации и символизация отладки управляются с помощью двух переключателей: `-O` и `-g`. Вы должны использовать следующие параметры как часть `CFLAGS` и `CXXFLAGS`  для минимальной отладочной сессии:

```text
-O0 -g3 -ggdb
```

`-O0` отключает оптимизации, а `-g3` обеспечивает максимальную доступность отладочной информации. Возможно, вам придется использовать `-O1` чтобы была выполнена некоторая анализирующая обработка. В противном случае в вашей отладочной сборке будет отсутствовать ряд предупреждений, которых нет в релизных сборках. `-g3` обеспечивает максимальное количество отладочной информации для отладочной сессии, включая символические константы и  `#defines`. `-ggdb` включает расширения для помощи в отладочной сессии под GDB. Для полноты информации Ян Крахтовил заявил, что `-ggdb` в настоящее время не имеет эффекта в личной переписке.

Релизные сборки также должны рассмотреть пару конфигураций `-mfunction-return=thunk` и `-mindirect-branch=thunk`. Это так называемая фиксация "Reptoline", которая представляет собой косвенный переход, используемый для предотвращения уязвимостей спекулятивного выполнения ЦП, таких как Spectre и Meltdown. ЦП не может определить, какой код выполнять `спекулятивно`, так как это косвенный (в отличие от прямого) переход. Это дополнительный уровень косвенности, как вызов указателя через указатель.

Отладочная сборка также должна определить `DEBUG`и убедиться, что `NDEBUG` не определен. `NDEBUG` удаляет "программные диагностические данные" и имеет нежелательное поведение и побочные эффекты, которые обсуждаются ниже более подробно. Определения должны присутствовать для всего кода, а не только для программы. Вы используете их для всего кода (вашей программы и включенных библиотек), потому что вам нужно знать, как они также выходят из строя (помните, вы принимаете отчет об ошибке, а не сторонняя библиотека).

Кроме того, вы должны использовать другие соответствующие флаги, такие как `-fno-omit-frame-pointer`. Обеспечение наличия указателя фрейма облегчает декодирование трассировок стека. Поскольку отладочные сборки не поставляются, можно оставить символы в исполняемом файле. Программы с отладочной информацией не страдают от ухудшения производительности. См., например, [Как влияет опция gcc -g на производительность?](https://gcc.gnu.org/ml/gcc-help/2005-03/msg00032.html)

Наконец, убедитесь, что ваш проект включает дополнительные диагностические библиотеки, такие как `dmalloc` и [Address Sanitizer](https://github.com/google/sanitizers/tree/master/hwaddress-sanitizer). Сравнение некоторых инструментов для проверки памяти можно найти в [Сравнении инструментов проверки памяти](https://github.com/google/sanitizers/wiki/AddressSanitizerComparisonOfMemoryTools). Если вы не включаете дополнительные диагностические средства в отладочные сборки, вам следует начать их использовать, так как нет ничего плохого в обнаружении ошибок, которые вы не ищете.

#### Релизные сборки

Релизные сборки — это то, что получает ваш клиент. Они предназначены для работы на производительном оборудовании и серверах, и они должны быть надежными, безопасными и эффективными. Стабильная релизная сборка — это результат упорной работы и усилий в процессе разработки.

Для релизных сборок следует использовать следующие параметры в `CFLAGS` и `CXXFLAGS`:

```text
-On -g2
```

`-O`_`n`_ устанавливает оптимизации по скорости или размеру (например, `-Os` или `-O2`), а `-g2` обеспечивает создание отладочной информации.

Отладочная информация должна быть удалена и сохранена для символизации в случае отчета о сбое с места эксплуатации. Хотя это не желательно, отладочная информация может быть оставлена без потери производительности. Подробнее см. в статье _[Как влияет опция gcc -g на производительность?](https://gcc.gnu.org/ml/gcc-help/2005-03/msg00032.html)_.

Релизные сборки также должны определить `NDEBUG` и убедиться, что `DEBUG` не определен. Время для отладки и диагностики прошло, поэтому пользователи получают производственный код с полной оптимизацией, без "программной диагностики" и других улучшений. Если вы не можете оптимизировать или проводите чрезмерное логирование, это обычно означает, что программа не готова к производству.

Если вы полагались на `assert`, а затем на последующий `abort()`, вы злоупотребляли "программной диагностикой", поскольку она не имеет места в производственном коде. Если вам нужно создать дамп памяти, создайте его так, чтобы пользователи не беспокоились о секретах и другой конфиденциальной информации, записанной в файловую систему и отправленной по электронной почте в открытом виде.

Для Windows используйте `/Od` для отладочных сборок и `/Ox`, `/O2` или `/Os` для релизных сборок. Подробности смотрите в документации Microsoft по [Опциям /O (Оптимизация кода)](https://docs.microsoft.com/en-us/cpp/build/reference/o-options-optimize-code).

#### Тестовые сборки

Тестовые сборки используются для эвристической валидации с помощью положительных и отрицательных тестов. В рамках тестовой конфигурации все интерфейсы тестируются, чтобы убедиться, что они работают в соответствии со спецификацией и удовлетворяют требованиям. "Удовлетворение" субъективно, но оно должно включать отсутствие сбоев и отсутствие порчи памяти, даже при отрицательных тестах.

Поскольку все интерфейсы тестируются (а не только публичные), ваши `CFLAGS` и `CXXFLAGS` должны включать:

```text
-Dprotected=public -Dprivate=public
```

Также следует изменить `__attribute__` `((visibility` `("hidden")))` to `__attribute__` `((visibility` `("default")))`.

Почти каждый проходит положительный тест, поэтому здесь больше нечего сказать. Отрицательные тесты гораздо более интересны, и вы должны сосредоточиться на том, чтобы попытаться заставить вашу программу выйти из строя, чтобы вы могли проверить, что она выходит из строя плавно. Помните, что злоумышленник не будет вежлив, когда попытается вызвать сбой вашей программы, и ваш проект окажется в затруднительном положении из-за отчета об ошибке или неожиданного появления на [Full Disclosure](https://nmap.org/mailman/listinfo/fulldisclosure) или [Bugtraq](https://www.securityfocus.com/archive) - а не `<некоторой библиотеки>`, которую вы включили.

### Автоинструменты

Инструменты автонастройки популярны на многих Linux и Unix системах, и они включают в себя _Autoconf_, _Automake_, _config_, и _Configure_. Инструменты работают вместе, чтобы создать проектные файлы из скриптов и шаблонных файлов. После завершения процесса ваш проект должен быть настроен и готов к сборке с помощью `make`.

При использовании инструментов автонастройки стоит упомянуть несколько интересных файлов. Эти файлы являются частью цепочки Autotools и включают `m4` и различные `*.in`, `*.ac` (Autoconf), и `*.am` (Automake) файлы. Иногда вам придется открывать их или полученные makefile'ы, чтобы настроить "стандартную" конфигурацию.

У командных инструментов настройки в цепочке есть три недостатка: (1) они часто игнорируют запросы пользователя, (2) они не могут создавать конфигурации и (3) безопасность часто не является целью.

Чтобы продемонстрировать первую проблему, настройте проект следующим образом: `configure` `CFLAGS="-Wall` `-fPIE"` `CXXFLAGS="-Wall` `-fPIE"` `LDFLAGS="-pie"`. Вы, вероятно, обнаружите, что Autotools проигнорировал ваш запрос, что означает, что приведенная ниже команда не даст ожидаемых результатов. В качестве обходного пути вам придется открыть сценарий `m4`, `makefile.in` или `makefile.am` и исправить конфигурацию.

```bash
$ configure CFLAGS="-Wall -Wextra -Wconversion -fPIE -Wno-unused-parameter
    -Wformat=2 -Wformat-security -fstack-protector-all -Wstrict-overflow"
    LDFLAGS="-pie -z,noexecstack -z,noexecheap -z,relro -z,now"
```

По второму пункту вы, вероятно, будете разочарованы, узнав, что [Automake не поддерживает концепцию конфигураций](https://lists.gnu.org/archive/html/automake/2012-12/msg00019.html). Это не полностью вина Autoconf или Automake - *Make* и его неспособность обнаруживать изменения являются основной проблемой. В частности, *Make* [проверяет только время изменения предпосылок и целей](https://pubs.opengroup.org/onlinepubs/9699919799/utilities/make.html) и не проверяет такие вещи, как `CFLAGS` и `CXXFLAGS`. В итоге вы не получите ожидаемых результатов, когда выполните `make` `debug`, а затем `make` `test` или `make` `release`.

Наконец, вы, вероятно, будете разочарованы, узнав, что такие инструменты, как Autoconf и Automake, упускают многие возможности, связанные с безопасностью, и изначально поставляются с небезопасными настройками. Существуют различные переключатели компилятора и флаги линкера, которые улучшают защитную позицию программы, но они не включены по умолчанию. Такие инструменты, как Autoconf, которые должны обрабатывать эту ситуацию, часто предоставляют настройки для минимально общего знаменателя.

Недавнее обсуждение в списке рассылки Automake проясняет проблему: _[Включение флагов предупреждения компилятора](https://lists.gnu.org/archive/html/autoconf/2012-12/msg00038.html)_. Попытки улучшить стандартные конфигурации встретили сопротивление, и никаких действий предпринято не было. Сопротивление часто имеет форму "`<какое-то полезное предупреждение> также вызывает ложные срабатывания`" или "`<некоторая неясная платформа> не поддерживает <утвержденную функцию безопасности>`". Примечательно, что Дэвид Уилер, автор _[Secure Programming for Linux and Unix HOWTO](https://dwheeler.com/secure-programs/)_, был одним из тех, кто пытался улучшить настройки безопасности.

### Makefiles

Make — один из первых инструментов сборки, появившийся в 1970-х годах. Он доступен в Linux, macOS и Unix, поэтому вы часто будете сталкиваться с проектами, использующими его. К сожалению, у Make есть ряд недостатков (_[Recursive Make Considered Harmful](https://embeddedartistry.com/blog/2017/04/10/recursive-make-considered-harmful/)_ и _[What's Wrong With GNU make?](https://www.conifersystems.com/whitepapers/gnu-make/)_) и может вызвать некоторые неудобства. Несмотря на проблемы с Make, ESAPI C++ использует его по трем основным причинам: во-первых, он повсеместно распространен; во-вторых, он проще в управлении, чем семейство Autotools; и в-третьих, использование `libtool` было исключено.

Рассмотрим, что происходит, когда вы: (1) вводите `make` `debug`, а затем вводите `make` `release`. Каждая сборка потребует разных `CFLAGS` из-за оптимизаций и уровня поддержки отладки. В вашем makefile вы извлекаете соответствующую цель и устанавливаете `CFLAGS` и `CXXFLAGS`, как показано ниже (взято из [ESAPI C++ makefile](https://code.google.com/archive/p/owasp-esapi-cplusplus/source/default/source)):

```text
## makefile
DEBUG_GOALS = $(filter $(MAKECMDGOALS), debug)
ifneq ($(DEBUG_GOALS),)
    WANT_DEBUG := 1
    WANT_TEST := 0
    WANT_RELEASE := 0
endif
…

ifeq ($(WANT_DEBUG),1)
    ESAPI_CFLAGS += -DDEBUG=1 -UNDEBUG -g3 -ggdb -O0
    ESAPI_CXXFLAGS += -DDEBUG=1 -UNDEBUG -g3 -ggdb -O0
endif

ifeq ($(WANT_RELEASE),1)
    ESAPI_CFLAGS += -DNDEBUG=1 -UDEBUG -g -O2
    ESAPI_CXXFLAGS += -DNDEBUG=1 -UDEBUG -g -O2
endif

ifeq ($(WANT_TEST),1)
    ESAPI_CFLAGS += -DESAPI_NO_ASSERT=1 -g2 -ggdb -O2 -Dprivate=public
                                                      -Dprotected=public
    ESAPI_CXXFLAGS += -DESAPI_NO_ASSERT=1 -g2 -ggdb -O2 -Dprivate=public
                                                        -Dprotected=public
endif
…

## Merge ESAPI flags with user supplied flags. We perform the extra step to ensure
## user options follow our options, which should give user option's a preference.
override CFLAGS := $(ESAPI_CFLAGS) $(CFLAGS)
override CXXFLAGS := $(ESAPI_CXXFLAGS) $(CXXFLAGS)
override LDFLAGS := $(ESAPI_LDFLAGS) $(LDFLAGS)
…
```

Make сначала соберет программу в отладочной конфигурации для сессии под отладчиком с помощью правила, похожего на:

```text
%.cpp:%.o:
        $(CXX) $(CPPFLAGS) $(CXXFLAGS) -c $< -o $@
```

Когда вам нужна релизная сборка, Make ничего не сделает, потому что считает, что все актуально, несмотря на то, что `CFLAGS` и `CXXFLAGS` изменились. В результате ваша программа фактически будет находиться в отладочной конфигурации и рискует завершиться с `SIGABRT` во время выполнения, потому что присутствует отладочная инструментализация (помните, `assert` вызывает `abort()`, когда `NDEBUG` **не** определен). По сути, вы создали себе DoS из-за `make`.

Кроме того, многие проекты не учитывают параметры командной строки пользователя. ESAPI C++ делает все возможное, чтобы гарантировать, что флаги пользователя будут учтены с помощью `override`, как показано выше, но другие проекты этого не делают. Например, рассмотрим проект, который должен быть собран с включенной поддержкой Position Independent Executable (PIE или ASLR) и предотвращением выполнения данных (DEP). Игнорирование пользовательских настроек в сочетании с небезопасными настройками по умолчанию (и не учтенными при автонастройке или авто-конфигурации) означает, что программа, собранная следующим образом, вероятно, не будет иметь ни одной защиты:

```bash
make CFLAGS="-fPIE" CXXFLAGS="-fPIE" LDFLAGS="-pie -z,noexecstack, -z,noexecheap"
```

Такие защиты, как ASLR и DEP, особенно важны в Linux, потому что [исполнение данных — а не их предотвращение — является нормой](https://linux.die.net/man/5/elf).

### Интеграция

Интеграция на уровне проекта предоставляет возможности для укрепления вашей программы или библиотеки с учетом знаний специфики домена. Например, если платформа поддерживает Position Independent Executables (PIE или ASLR) и предотвращение выполнения данных (DEP), то вам следует интегрироваться с ними. Последствия невыполнения этого требования могут привести к эксплуатации уязвимостей. В качестве примера можно привести 0-day уязвимости KingCope для MySQL в декабре 2012 года (CVE-2012-5579 и CVE-2012-5612, среди прочих). Интеграция с механизмами безопасности платформы могла бы предотвратить ряд этих уязвимостей.

Также у вас есть возможность включить полезные библиотеки, которые не требуются для поддержки бизнес-логики. Например, если вы работаете на платформе с [DMalloc](http://dmalloc.com) или [Address Sanitizer](https://github.com/google/sanitizers/tree/master/hwaddress-sanitizer), вам, вероятно, стоит использовать их в ваших отладочных сборках. Для Ubuntu DMalloc доступен в менеджере пакетов и может быть установлен с помощью команды `sudo apt install libdmalloc5`. На платформах Apple он доступен как опция схемы. Address Sanitizer доступен в [GCC 4.8 и выше](https://gcc.gnu.org/gcc-4.8/changes.html) для многих платформ.

Кроме того, интеграция на уровне проекта предоставляет возможность усилить сторонние библиотеки, которые вы решили включить. Так как вы включили их в проект, вы и ваши пользователи несете ответственность за них. Если вы или ваши пользователи проходят аудит по `SP800-53`, сторонние библиотеки будут в области аудита, потому что включена цепочка поставок (в частности, пункт SA-12, Защита цепочки поставок). Аудиты не ограничиваются только федеральной ареной США — финансовые учреждения также проводят проверки. Прекрасным примером нарушения этого руководства является [CVE-2012-1525](https://nvd.nist.gov/vuln/detail/CVE-2012-1525), причиной которого стало [включение компанией Adobe дефектной библиотеки Sablotron](https://www.agarri.fr/blog/index.html).

Другим примером является включение OpenSSL. Вы знаете, что (1) [SSLv2 небезопасен](https://www.schneier.com/academic/paperfiles/paper-ssl-revised.pdf), (2) [SSLv3 небезопасен](https://blog.qualys.com/ssllabs/2014/10/15/ssl-3-is-dead-killed-by-the-poodle-attack), и (3) [сжатие небезопасно](https://arstechnica.com/security/2012/09/crime-hijacks-https-sessions/) (среди прочих). Кроме того, предположим, что вы не используете аппаратное обеспечение и механизмы, и допускаете только статическую компоновку. С учетом этих знаний и спецификаций вы бы настроили библиотеку OpenSSL следующим образом:

```bash
$ Configure darwin64-x86_64-cc -no-hw -no-engine -no-comp -no-shared
    -no-dso -no-ssl2 -no-ssl3 --openssldir=…
```

_Примечание_: возможно, вам нужны механизмы, особенно на микроархитектурах Ivy Bridge (3-е поколение процессоров Intel Core i5 и i7). Чтобы OpenSSL использовал генератор случайных чисел процессора (через инструкцию `rdrand`), вам нужно вызвать функцию `ENGINE_load_rdrand()` OpenSSL, а затем `ENGINE_set_default` с `ENGINE_METHOD_RAND`. См. [Случайные числа в OpenSSL](https://wiki.openssl.org/index.php/Random_Numbers).

Конфигурация без переключателей скорее всего приведет к уязвимому коду/библиотекам и риску провала аудита. Если программа является удаленным сервером, то следующая команда покажет, активна ли компрессия на канале:

```bash
echo "GET / HTTP1.0" | openssl s_client -connect <nowiki>example.com:443</nowiki>
```

Команды `nm` или `openssl` `s_client` покажут, что компрессия включена в клиенте. На самом деле, любой символ в предопределенном макросе `OPENSSL_NO_COMP` будет свидетельствовать о том, что `-no-comp` переводится в определение `CFLAGS`.

```bash
$ nm /usr/local/ssl/iphoneos/lib/libcrypto.a 2>/dev/null | egrep -i "(COMP_CTX_new|COMP_CTX_free)"
0000000000000110 T COMP_CTX_free
0000000000000000 T COMP_CTX_new
```

Еще более вопиющим является ответ, данный аудиторам, которые специально спрашивают о конфигурациях и протоколах: "мы не используем слабые/поврежденные/сломанные шифры" или "мы следуем лучшим практикам". Использование компрессии говорит аудитору о том, что вы используете поврежденные протоколы в небезопасной конфигурации и не следуете лучшим практикам. Это, вероятно, вызовет тревогу и заставит аудитора более тщательно изучить другие аспекты.

## Предпроцессор

Предпроцессор имеет решающее значение для успешной настройки проекта. Комитет по языку C предоставил один макрос - `NDEBUG` - и этот макрос можно использовать для создания множества конфигураций и управления инженерными процессами. К сожалению, комитет также оставил многие сопутствующие элементы на волю случая, что привело к тому, что программисты злоупотребляют встроенными функциями. Этот раздел поможет вам настроить ваши проекты для интеграции с другими проектами и обеспечить надежность и безопасность.

Есть три темы для обсуждения при усилении препроцессора. Первая — это хорошо определенные конфигурации, которые приводят к четко определенному поведению. Вторая — полезное поведение функции assert, и третья — правильное использование макросов при интеграции кода поставщиков и сторонних библиотек.

### Конфигурации

Чтобы исключить двусмысленность, следует учитывать две конфигурации: Release и Debug. Release предназначена для рабочего кода на продуктивных серверах, и её поведение задается макросом C/C++ `NDEBUG`. Это также единственный макрос, используемый комитетами по стандартам C и C++ и Posix. Противоположностью Release является Debug. Хотя аргумент в пользу `!defined(NDEBUG)` выглядит убедительно, следует использовать явный макрос для конфигурации, и этим макросом должен быть `DEBUG`. Это связано с тем, что поставщики и сторонние библиотеки используют макрос  `DEBUG` (или аналогичный) для своей конфигурации. Например, ядро Mach от Carnegie Mellon использует `DEBUG`, CRT от Microsoft использует [`_DEBUG`](https://www.microsoft.com/en-us/download/details.aspx?id=55979), а Workbench от Wind River использует `DEBUG_MODE`.

В дополнение к `NDEBUG` (Release) и `DEBUG` (Debug) имеются еще два перекрестных продукта: оба макроса определены или ни один не определен. Определение обоих должно быть ошибкой, а неопределение ни одного должно приводить к конфигурации release. Пример ниже взят из [ESAPI C++ EsapiCommon.h](https://code.google.com/archive/p/owasp-esapi-cplusplus/source/default/source), который является конфигурационным файлом, используемым всеми исходными файлами:

```c
// Только один или другой, но не оба
##if (defined(DEBUG) || defined(_DEBUG)) && (defined(NDEBUG)
                                           || defined(_NDEBUG))
## error Both DEBUG and NDEBUG are defined.
##endif

// Переключаемся на debug только по запросу.
// NDEBUG или {ничего} приводят
// к сборке release (меньше сюрпризов во время выполнения).
##if defined(DEBUG) || defined(_DEBUG)
## define ESAPI_BUILD_DEBUG 1
##else
## define ESAPI_BUILD_RELEASE 1
##endif
```

Когда `DEBUG` активен, ваш код должен получать полную инструментализацию для отладки, включая всю мощь утверждений.

### ASSERT

Утверждения (assert) помогут вам создавать самопроверяющийся код, быстро и легко находя точку первого сбоя. Утверждения должны использоваться на протяжении всей программы, включая проверку параметров, проверку возвращаемых значений и состояния программы. `assert` будет безмолвно защищать ваш код на протяжении его жизни. Он всегда будет там, даже если вы не отлаживаете конкретный компонент модуля. Если у вас полное покрытие кода, вы будете тратить меньше времени на отладку и больше времени на разработку, так как программы будут отлаживаться сами.

Чтобы эффективно использовать утверждения, вы должны проверять все. Это включает параметры при входе в функцию, возвращаемые значения вызовов функций и любое состояние программы. Везде, где вы размещаете оператор `if` для проверки или валидации, вы должны использовать assert. Везде, где у вас есть `assert` для проверки или валидации, вы должны иметь оператор `if`. Они идут рука об руку.

Если вы все еще используете `printf`, у вас есть возможность для улучшения. На то время, которое требуется, чтобы написать оператор `printf` или `NSLog`, вы могли бы написать утверждение `assert`. В отличие от `printf` или `NSLog`, которые часто удаляются, когда больше не нужны, утверждение `assert` остается активным всегда. Помните, что все это направлено на быстрое нахождение точки первого сбоя, чтобы вы могли заниматься другими вещами.

Существует одна проблема с использованием утверждений - [стандарт Posix предписывает, что `assert` должен вызывать `abort()`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/assert.html) если `NDEBUG` **не** определен. При отладке `NDEBUG` никогда не будет определен, так как вам нужны "диагностика программы" (цитата из описания Posix). Такое поведение делает `assert` и его сопровождающий `abort()` совершенно бесполезными для разработки. Результат "диагностики программы", вызывающий `abort()` из-за стандартного поведения C/C++, приводит к отказу от их использования - разработчики просто их не используют. Это чрезвычайно плохо для сообщества разработчиков, так как программы, которые могут проверять сами себя, могут помочь устранить множество проблем со стабильностью.

Поскольку самопроверяющие программы настолько мощны, вам придется предоставить свой собственный assert и обработчик сигналов с улучшенным поведением. Ваш assert заменит автоматическое поведение прерывания на автоматическое поведение отладки. Функция автоматической отладки обеспечит срабатывание отладчика при обнаружении проблемы, и вы быстро и легко найдете точку первого сбоя.

ESAPI C++ предоставляет собственный assert с поведением, описанным выше. В коде ниже `ASSERT` вызывает `SIGTRAP`, когда он активен, или оценивается в `void` в других случаях.

```c
// Отладочное утверждение, которое следует использовать щедро.
// Это утверждение срабатывает и продолжает выполнение, 
// а не вызывает abort(). Полезно при проверке негативных 
// тестовых случаев с командной строки.
##if (defined(ESAPI_BUILD_DEBUG) && defined(ESAPI_OS_STARNIX))
##  define ESAPI_ASSERT1(exp) {                                    \
    if(!(exp)) {                                                  \
        std::ostringstream oss;                                     \
        oss << "Assertion failed: " << (char*)(__FILE__) << "("     \
            << (int)__LINE__ << "): " << (char*)(__func__)          \
            << std::endl;                                           \
        std::cerr << oss.str();                                     \
        raise(SIGTRAP);                                             \
    }                                                             \
    }
##  define ESAPI_ASSERT2(exp, msg) {                               \
    if(!(exp)) {                                                  \
        std::ostringstream oss;                                     \
        oss << "Assertion failed: " << (char*)(__FILE__) << "("     \
            << (int)__LINE__ << "): " << (char*)(__func__)          \
            << ": \"" << (msg) << "\"" << std::endl;                \
        std::cerr << oss.str();                                     \
        raise(SIGTRAP);                                             \
    }                                                             \
    }
##elif (defined(ESAPI_BUILD_DEBUG) && defined(ESAPI_OS_WINDOWS))
##  define ESAPI_ASSERT1(exp)      assert(exp)
##  define ESAPI_ASSERT2(exp, msg) assert(exp)
##else
##  define ESAPI_ASSERT1(exp)      ((void)(exp))
##  define ESAPI_ASSERT2(exp, msg) ((void)(exp))
##endif

##if !defined(ASSERT)
##  define ASSERT(exp)     ESAPI_ASSERT1(exp)
##endif
```

При запуске программы обработчик `SIGTRAP` будет установлен, если его не предоставил другой компонент:

```c
    struct DebugTrapHandler
    {
      DebugTrapHandler()
      {
        struct sigaction new_handler, old_handler;

        do
          {
            int ret = 0;

            ret = sigaction (SIGTRAP, NULL, &old_handler);
            if (ret != 0) break; // Ошибка

            // Не перезаписываем обработчик другого
            if (old_handler.sa_handler != NULL) break;

            new_handler.sa_handler = &DebugTrapHandler::NullHandler;
            new_handler.sa_flags = 0;

            ret = sigemptyset (&new_handler.sa_mask);
            if (ret != 0) break; // Ошибка

            ret = sigaction (SIGTRAP, &new_handler, NULL);
            if (ret != 0) break; // Ошибка

          } while(0);
      }

      static void NullHandler(int /*не используется*/) { }

    };

    // Мы указываем относительно низкий приоритет, чтобы убедиться, что
    // обработчик запустится до других конструкторов
    // http://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Attributes.html#C_002b_002b-Attributes
    static const DebugTrapHandler g_dummyHandler __attribute__ ((init_priority (110)));
```

На платформе Windows следует вызвать `_set_invalid_parameter_handler` (и, возможно, `set_unexpected` или `set_terminate`) для установки нового обработчика.

Рабочие узлы, на которых выполняется продуктивный код, всегда должны определять `NDEBUG` (то есть конфигурацию release), что означает, что они не выполняют утверждения и не завершают выполнение автоматически. Автоматическое завершение работы недопустимо, и любой, кто просит об этом, злоупотребляет функциональностью "диагностики программы". Если программе нужен дамп памяти, она должна создать его самостоятельно, а не завершаться аварийно.

Для более подробного чтения о том, как эффективно использовать утверждения, пожалуйста, обратитесь к одной из книг Джона Роббинса, например, _[Debugging Applications](https://www.amazon.com/dp/0735608865)_. Джон — легендарный охотник за ошибками в мире Windows, и он покажет вам, как делать почти все: от отладки простой программы до охоты за ошибками в многопоточных программах.

### Дополнительные макросы

Дополнительные макросы включают любые макросы, необходимые для правильной и безопасной интеграции. Это включает интеграцию программы с платформой (например, MFC или Cocoa/CocoaTouch) и библиотеками (например, Crypto++ или OpenSSL). Это может быть проблемой, так как вы должны обладать навыками работы с вашей платформой и всеми включенными библиотеками и фреймворками. Приведенный ниже список иллюстрирует уровень детализации, который вам понадобится при интеграции.

Хотя Boost отсутствует в списке, похоже, что ему не хватает рекомендаций, дополнительных средств диагностики и руководства по усилению. Подробнее см. в _[BOOST Hardening Guide (Preprocessor Macros)](https://stackoverflow.com/questions/14927033/boost-hardening-guide-preprocessor-macros)_. Кроме того, Тим Дэй указывает на _[\[boost.build\] should we not define \_SECURE_SCL=0 by default for all msvc toolsets](https://lists.boost.org/Archives/boost/2008/12/145749.php)_ для обсуждения, связанного с усилением (или его отсутствием).

В дополнение к тому, что следует определить, определение некоторых макросов и удаление других должны вызывать дефект, связанный с безопасностью. Например, `-U_FORTIFY_SOURCES` на Linux и `_CRT_SECURE_NO_WARNINGS=1`, `_SCL_SECURE_NO_WARNINGS`, `_ATL_SECURE_NO_WARNINGS` или `STRSAFE_NO_DEPRECATE` на Windows.

![AdditionalPlatformLibraryMacrosTable](../assets/C-Based_Toolchain_Hardening_AdditionalPlatformLibraryMacrosTable.png)

a) Будьте осторожны с `_GLIBCXX_DEBUG` при использовании предварительно скомпилированных библиотек, таких как Boost из дистрибутива. Существуют несовместимости ABI, и результатом, скорее всего, будет сбой. Вам придется компилировать Boost с `_GLIBCXX_DEBUG` или пропустить `_GLIBCXX_DEBUG`.

b) См. [Chapter 5, Diagnostics](https://gcc.gnu.org/onlinedocs/libstdc++/manual/concept_checking.html) руководства по libstdc++ для получения подробной информации.

c) Безопасное удаление в SQLite обнуляет память при уничтожении. Определите по необходимости и всегда определяйте в соответствии с требованиями федеральных стандартов США, так как обнуление необходимо для FIPS 140-2, Уровень 1.

d) *N** по умолчанию равно 0644, что означает, что у всех есть некоторый доступ.

e) Принудительное помещение временных таблиц в память (никаких незашифрованных данных на диск).

## Компилятор и компоновщик

Разработчики компиляторов предоставляют богатый набор предупреждений на основе анализа кода во время компиляции. Как GCC, так и Visual Studio имеют возможности статического анализа, которые помогают находить ошибки на ранних этапах разработки. Встроенные возможности статического анализа GCC и Visual Studio обычно достаточны для обеспечения правильного использования API и нахождения ряда ошибок, таких как использование неинициализированной переменной или сравнение отрицательного знакового int и положительного беззнакового int.

В качестве конкретного примера (и для тех, кто не знаком с правилами продвижения C/C++), будет выдано предупреждение, если знаковый целочисленный тип будет продвинут до беззнакового и затем сравнен, поскольку побочный эффект будет `-1 > 1`  после продвижения! В настоящее время GCC и Visual Studio не могут обнаруживать, например, SQL-инъекции и другое использование загрязненных данных. Для этого вам понадобится инструмент, предназначенный для анализа потока данных или анализа загрязнений.

Некоторые в сообществе разработчиков сопротивляются статическому анализу или опровергают его результаты. Например, когда статический анализ предупредил, что в `sys_prctl` ядра Linux сравнивается беззнаковое значение с числом меньше нуля, Йеспер Юль предложил патч для очистки кода. Линус Торвальдс воскликнул: "Нет, вы не должны этого делать… GCC — это ерунда" (имеется в виду компиляция с предупреждениями). Полное обсуждение смотрите в _[\[PATCH\] Don't compare unsigned variable for &lt;0 in sys_prctl()](https://groups.google.com/g/fa.linux.kernel/c/jjk_K4HOemQ/)_ из рассылки ядра Linux.

Следующие разделы подробно опишут шаги для трех платформ. Во-первых, это типичный дистрибутив на основе GNU Linux, предлагающий GCC и Binutils; во-вторых, Clang и Xcode; и в-третьих, современные платформы Windows.

### Укрепление дистрибутива

Перед обсуждением GCC и Binutils стоит отметить, что некоторые из защит, описанных ниже, уже присутствуют в дистрибутивах. К сожалению, они разрабатываются комитетом, поэтому то, что присутствует, обычно представляет собой лишь мягкий вариант доступного (так, чтобы каждый был немного недоволен). Те, кто беспокоится исключительно о производительности, могут быть удивлены, узнав, что уже использовали небольшую оптимизацию производительности, не осознавая этого.

Linux и BSD дистрибутивы часто применяют некоторую защиту без вмешательства через _[спецификации GCC](https://gcc.gnu.org/onlinedocs/gcc/Spec-Files.html)_. Если вы используете Debian, Ubuntu, Linux Mint и семейство, см. _[Debian Hardening](https://wiki.debian.org/Hardening)_. Для систем Red Hat и Fedora см. _[Поддержка нового усиленного сборочного процесса (в разработке) в F16](https://lists.fedoraproject.org/pipermail/devel-announce/2011-August/000821.html)_. Пользователи Gentoo могут посетить _[Hardened Gentoo](https://wiki.gentoo.org/wiki/Project:Hardened)_.

Вы можете увидеть настройки, используемые в дистрибутиве, с помощью `gcc` `-dumpspecs`. В Linux Mint 12, например, `-fstack-protector` (но не `-fstack-protector-all`) используется по умолчанию.

```bash
$ gcc -dumpspecs
…
*link_ssp: %{fstack-protector:}

*ssp_default: %{!fno-stack-protector:%{!fstack-protector-all:
              %{!ffreestanding:%{!nostdlib:-fstack-protector}}}}
…
```

"SSP" выше означает Stack Smashing Protector. SSP — это повторная реализация работы Хироаки Это на IBM Pro Police Stack Detector. См. патч Хироаки _[gcc stack-smashing protector](https://gcc.gnu.org/ml/gcc-patches/2001-06/msg01753.html)_ и статью IBM _[GCC extension for protecting applications from stack-smashing attacks](https://pdfs.semanticscholar.org/9d92/fa9eaa6ca12888d303deffe8bc392b85c09f.pdf)_ для получения подробностей.

### GCC/Binutils

GCC (коллекция компиляторов) и Binutils (ассемблеры, компоновщики и другие инструменты) — это отдельные проекты, которые работают вместе для создания исполняемого файла. Как компилятор, так и компоновщик предлагают опции, которые помогут вам написать более безопасный код. Компоновщик создаст код, который использует преимущества функций безопасности платформы, предлагаемых ядром и PaX, таких как non-executable стеки и кучи (NX) и Position Independent Executable (PIE).

Таблица ниже предлагает набор опций компилятора для сборки вашей программы. Статические анализаторы предупреждений помогают обнаружить ошибки на ранней стадии, в то время как опции компоновщика усиливают исполняемый файл во время выполнения. В таблице ниже "GCC" следует воспринимать в широком смысле как "не древние дистрибутивы". В то время как команда GCC считает 4.2 древней, вы все еще можете столкнуться с ней на платформах Apple и BSD из-за изменений в лицензировании GPL около 2007 года. Смотрите _[GCC Option Summary](https://gcc.gnu.org/onlinedocs/gcc/Option-Summary.html)_, _[Options to Request or Suppress Warnings](https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html)_ и _[Binutils (LD) Command Line Options](https://sourceware.org/binutils/docs-2.21/ld/Options.html)_ для получения деталей использования.

Стоит отметить специальные флаги `-fno-strict-overflow` и `-fwrapv`. Эти флаги обеспечивают, что компилятор не удаляет инструкции, приводящие к переполнению или обёртыванию. Если ваша программа работает корректно только с использованием этих флагов, вероятно, она нарушает правила C/C++ относительно переполнения и является недопустимой. Если программа является недопустимой из-за проверки переполнения или обёртывания, вам следует рассмотреть использование [safe-iop](https://code.google.com/archive/p/safe-iop/) для C или [SafeInt](https://archive.codeplex.com/?p=safeint) Дэвида Лебланка для C++.

Для проекта, собранного и связанного с усиленными настройками, некоторые из этих настроек могут быть проверены с помощью инструмента [Checksec](https://www.trapkit.de/tools/checksec.html) , написанного Тобиасом Кляйном. Скрипт `checksec.sh` предназначен для тестирования стандартных функций безопасности Linux OS и PaX, используемых приложением. Подробности смотрите на веб-странице [Trapkit](https://www.trapkit.de/tools/checksec.html).

Таблица опций предупреждений GCC для C:

![GCCCWarningOptionsTable](../assets/C-Based_Toolchain_Hardening_GCCCWarningOptionsTable.png)

- [AddressSanitizer](https://github.com/google/sanitizers)
- [ThreadSanitizer](https://github.com/google/sanitizers/wiki/ThreadSanitizerCppManual)

a) В отличие от Clang и -Weverything, GCC не предоставляет переключателя для включения всех предупреждений.
b) `-fstack-protector` защищает функции с объектами высокого риска, такими как строки C, в то время как `-fstack-protector-all` защищает все объекты.

Дополнительные предупреждения для C++, которые можно использовать, приведены в Таблице 3. См. _[Опции GCC для управления диалектом C++](https://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Dialect-Options.html)_ для дополнительных опций и деталей.

Таблица опций предупреждений GCC для C++

![GCCCPPWarningOptionsTable](../assets/C-Based_Toolchain_Hardening_GCCCPPWarningOptionsTable.png)

[Книга "Эффективный C++", второе издание](https://www.aristeia.com/books.html).

А дополнительные предупреждения для Objective C, которые часто полезны, включены ниже. См. _[Опции управления диалектами Objective-C и Objective-C++](https://gcc.gnu.org/onlinedocs/gcc-4.6.0/gcc/Objective_002dC-and-Objective_002dC_002b_002b-Dialect-Options.html)_ для получения дополнительных опций и деталей.

Таблица опций предупреждений GCC для Objective C

![GCCObjectiveCWarningOptionsTable](../assets/C-Based_Toolchain_Hardening_GCCObjectiveCWarningOptionsTable.png)

Использование агрессивных предупреждений вызовет избыточный шум. Этот шум — компромисс: вы можете узнать о потенциальных проблемах ценой пропуска некоторого «мусора». Следующее поможет уменьшить избыточный шум от системы предупреждений:

- `-Wno-unused-parameter` (GCC)
- `-Wno-type-limits` (GCC 4.3)
- `-Wno-tautological-compare` (Clang)

Ниже приведен простой пример makefile, основанный на версиях. Это отличается от makefile на основе функций, созданного с помощью Autotools (который будет тестировать конкретную функцию, а затем определять символ или настраивать шаблонный файл). Не все платформы используют все опции и флаги. Чтобы решить эту проблему, вы можете выбрать одну из двух стратегий. Во-первых, можно поставлять продукт с ослабленной защитой, обслуживая наименьший общий знаменатель, или, во-вторых, можно поставлять его с полной защитой. Во втором случае те, у кого нет доступной функции, отредактируют makefile, чтобы он соответствовал их установке.

```bash
CXX=g++
EGREP = egrep
…

GCC_COMPILER = $(shell $(CXX) -v 2>&1 | $(EGREP) -i -c '^gcc version')
GCC41_OR_LATER = $(shell $(CXX) -v 2>&1 | $(EGREP) -i -c '^gcc version (4\.[1-9]|[5-9])')
…

GNU_LD210_OR_LATER = $(shell $(LD) -v 2>&1 | $(EGREP) -i -c '^gnu ld .* (2\.1[0-9]|2\.[2-9])')
GNU_LD214_OR_LATER = $(shell $(LD) -v 2>&1 | $(EGREP) -i -c '^gnu ld .* (2\.1[4-9]|2\.[2-9])')
…

ifeq ($(GCC_COMPILER),1)
    MY_CC_FLAGS += -Wall -Wextra -Wconversion
    MY_CC_FLAGS += -Wformat=2 -Wformat-security
    MY_CC_FLAGS += -Wno-unused-parameter
endif

ifeq ($(GCC41_OR_LATER),1)
    MY_CC_FLAGS += -fstack-protector-all
endif

ifeq ($(GCC42_OR_LATER),1)
    MY_CC_FLAGS += -Wstrict-overflow
endif

ifeq ($(GCC43_OR_LATER),1)
    MY_CC_FLAGS += -Wtrampolines
endif

ifeq ($(GNU_LD210_OR_LATER),1)
    MY_LD_FLAGS += -z,nodlopen -z,nodump
endif

ifeq ($(GNU_LD214_OR_LATER),1)
    MY_LD_FLAGS += -z,noexecstack -z,noexecheap
endif

ifeq ($(GNU_LD215_OR_LATER),1)
    MY_LD_FLAGS += -z,relro -z,now
endif

ifeq ($(GNU_LD216_OR_LATER),1)
    MY_CC_FLAGS += -fPIE
    MY_LD_FLAGS += -pie
endif

## Используйте 'override', чтобы учитывать командную строку пользователя
override CFLAGS := $(MY_CC_FLAGS) $(CFLAGS)
override CXXFLAGS := $(MY_CC_FLAGS) $(CXXFLAGS)
override LDFLAGS := $(MY_LD_FLAGS) $(LDFLAGS)
…
```

### Clang/Xcode

[Clang](https://clang.llvm.org) и [LLVM](https://llvm.org) активно разрабатываются с тех пор, как Apple потеряла свой компилятор с лицензией GPL в 2007 году (из-за Tivoization, что привело к появлению GPLv3). С тех пор к усилиям присоединились несколько разработчиков и Google. Хотя Clang поддерживает большинство (все?) флагов и переключателей GCC/Binutils, проект поддерживает ряд собственных опций, включая статический анализатор. Кроме того, Clang относительно легко собрать с дополнительными средствами диагностики, такими как [Integer Overflow Checker (IOC)](https://embed.cs.utah.edu/ioc/) доктора Джона Регера и Пэн Ли.

IOC чрезвычайно полезен и обнаружил ошибки в ряде проектов, начиная с ядра Linux (`include/linux/bitops.h`, все еще не исправлено), SQLite, PHP, Firefox (многие все еще не исправлены), LLVM и Python. В будущих версиях Clang (Clang 3.3 и выше) вы сможете включить проверки из коробки с помощью `-fsanitize=integer` и `-fsanitize=shift`.

Опции Clang можно найти в [руководстве пользователя компилятора Clang](https://clang.llvm.org/docs/UsersManual.html). Clang включает опцию для включения всех предупреждений — `-Weverything`. Используйте ее с осторожностью, но регулярно, так как она выдаст много шума и проблем, которые вы могли пропустить. Например, добавьте `-Weverything` для производственных сборок и сделайте отсутствующие ложные проблемы критерием качества. В Xcode просто добавьте `-Weverything` к `CFLAGS` и `CXXFLAGS`.

В дополнение к предупреждениям компилятора могут выполняться как статический анализ, так и дополнительные проверки безопасности. Информацию о возможностях статического анализа Clang можно найти в [Clang Static Analyzer](https://clang-analyzer.llvm.org). Ниже на Рисунке 1 показаны некоторые из проверок безопасности, используемых Xcode.

![XCode1](../assets/C-Based_Toolchain_Hardening_XCode1.png)

### Visual Studio

Visual Studio предлагает удобную интегрированную среду разработки (IDE) для управления решениями и их настройками. Раздел "Параметры Visual Studio" обсуждает параметры, которые следует использовать с Visual Studio, а раздел "Свойства проекта" демонстрирует включение этих параметров в проект решения.

Таблица ниже перечисляет переключатели компилятора и компоновщика, которые следует использовать в Visual Studio. Подробное обсуждение можно найти в книге Говарда и Лебланка "Writing Secure Code" (Microsoft Press) или в разделе _[Protecting Your Code with Visual C++ Defenses](https://docs.microsoft.com/en-us/archive/msdn-magazine/2008/march/security-briefs-protecting-your-code-with-visual-c-defenses)_ в Security Briefs Майкла Ховарда. В таблице ниже "Visual Studio" относится к почти всем версиям среды разработки, включая Visual Studio 5.0 и 6.0.

Для проекта, собранного и связанного с усиленными настройками, эти настройки можно проверить с помощью BinScope. BinScope — это инструмент верификации от Microsoft, который анализирует бинарные файлы, чтобы убедиться, что они были собраны в соответствии с требованиями и рекомендациями Microsoft Security Development Lifecycle (SDLC). См. страницу загрузки _[BinScope Binary Analyzer](https://www.microsoft.com/en-us/download/details.aspx?id=44995)_ для получения подробностей.

![VStudioWarningOptionsTable](../assets/C-Based_Toolchain_Hardening_VStudioWarningOptionsTable.png)

a) См. обсуждение переключателя Джоном Стёрдженом в _[Off By Default Compiler Warnings in Visual C++](https://devblogs.microsoft.com/cppblog/off-by-default-compiler-warnings-in-visual-c/)_.

b) При использовании /GS существует ряд обстоятельств, которые влияют на включение защитного кода. Например, защита не используется, если в стеке нет буфера, отключены оптимизации или функция объявлена как "голая" или содержит встроенную ассемблерную вставку.

c) Директиву `#pragma` `strict_gs_check(on)` следует использовать с осторожностью, но она рекомендуется в ситуациях высокого риска, таких как обработка входных данных из Интернета.

### Подавление предупреждений

Из приведенных выше таблиц видно, что было включено множество предупреждений для помощи в обнаружении возможных ошибок программирования. Потенциальные ошибки обнаруживаются компилятором, который во время фазы анализа кода переносит много контекстной информации. Иногда вы получите ложные предупреждения, потому что компилятор не настолько "умен". Это понятно и даже хорошо (как бы вам понравилось остаться без работы, потому что программа пишет свои собственные программы?). Иногда вам придется научиться работать с системой предупреждений компилятора для подавления предупреждений. Обратите внимание, что не было сказано "выключить предупреждения".

Подавление предупреждений успокаивает компилятор для избыточного шума, чтобы вы могли перейти к важным проблемам (вы отделяете зерна от плевел). Этот раздел предложит несколько советов и укажет на потенциальные минные поля. Во-первых, это неиспользуемый параметр (например, `argc` или `argv`). Подавление предупреждений о неиспользуемом параметре особенно полезно для программирования на C++ и интерфейсов, где параметры часто не используются. Для этого предупреждения просто определите макрос "UNUSED" и оберните параметр:

```c
##define UNUSED_PARAMETER(x) ((void)x)
…

int main(int argc, char* argv[])
{
    UNUSED_PARAMETER(argc);
    UNUSED_PARAMETER(argv);
    …
}
```

Потенциальное минное поле лежит рядом с "сравнением знаковых и беззнаковых" значений, и `-Wconversion` поймает это за вас. Это связано с тем, что правила повышения типов C/C++ устанавливают, что знаковое значение будет повышено до беззнакового, а затем сравнивается. Это означает, что `-1` `>` `1` после повышения! Чтобы исправить это, нельзя слепо преобразовывать — сначала необходимо протестировать диапазон значения:

```c
int x = GetX();
unsigned int y = GetY();

ASSERT(x >= 0);
if(!(x >= 0))
    throw runtime_error("WTF??? X is negative.");

if(static_cast<unsigned int>(x) > y)
    cout << "x is greater than y" << endl;
else
    cout << "x is not greater than y" << endl;
```

Обратите внимание, что приведенный выше код будет сам себя отлаживать — вам не нужно ставить точку останова, чтобы увидеть, есть ли проблема с `x`. Просто запустите программу и подождите, пока она не сообщит вам о проблеме. Если есть проблема, программа остановит отладчик (и что более важно, не вызовет бесполезную функцию `abort()`, как это указано в Posix). Это гораздо лучше, чем удаленные `printf`, которые больше не нужны или засоряют выходные данные.

Еще одна проблема преобразования, с которой вы столкнетесь, — это преобразование между типами, и `-Wconversion` также поймает это за вас. Следующее всегда будет иметь возможность потерпеть неудачу и должно светиться, как рождественская елка:

```c
struct sockaddr_in addr;
…

addr.sin_port = htons(atoi(argv[2]));
```

Следующее, вероятно, послужит вам гораздо лучше. Обратите внимание, что `atoi` и его аналоги не используются, потому что они могут молча завершиться неудачно. Кроме того, код инструментирован, поэтому вам не нужно тратить много времени на отладку потенциальных проблем:

```c
const char* cstr = GetPortString();

ASSERT(cstr != NULL);
if(!(cstr != NULL))
    throw runtime_error("WTF??? Port string is not valid.");

istringstream iss(cstr);
long long t = 0;
iss >> t;

ASSERT(!(iss.fail()));
if(iss.fail())
    throw runtime_error("WTF??? Failed to read port.");

// Должен ли это быть порт выше зарезервированного диапазона ([0-1024] на Unix)?
ASSERT(t > 0);
if(!(t > 0))
    throw runtime_error("WTF??? Port is too small");

ASSERT(t < static_cast<long long>(numeric_limits<unsigned int>::max()));
if(!(t < static_cast<long long>(numeric_limits<unsigned int>::max())))
    throw runtime_error("WTF??? Port is too large");

// Можно использовать порт
unsigned short port = static_cast<unsigned short>(t);
…
```

Еще раз обратите внимание, что приведенный выше код будет сам себя отлаживать — вам не нужно ставить точку останова, чтобы увидеть, есть ли проблема с `port`. Этот код будет продолжать проверять условия в течение многих лет после его создания (при условии, что код для чтения конфигурационного файла был написан на ранних этапах проекта). Нет необходимости удалять `ASSERT`, в отличие от `printf`, так как они являются молчаливыми защитниками.

Еще один полезный прием подавления предупреждений — избегать игнорирования возвращаемых значений. Это полезно не только для подавления предупреждений, но и для корректности кода. Например, `snprint` предупредит вас о обрезке строки через возвращаемое значение. Не делайте их молча обрезанными, игнорируя предупреждение или приводя его к `void`:

```c
char path[PATH_MAX];
…

int ret = snprintf(path, sizeof(path), "%s/%s", GetDirectory(), GetObjectName());
ASSERT(ret != -1);
ASSERT(!(ret >= sizeof(path)));

if(ret == -1 || ret >= sizeof(path))
    throw runtime_error("WTF??? Unable to build full object name");

// Путь можно использовать
…
```

Проблема является повсеместной и не ограничивается только скучными пользовательскими программами. Проекты, предоставляющие высокоинтеграционный код, такие как SELinux, страдают от тихих обрезок строк. Пример ниже взят из утвержденного патча SELinux, несмотря на то, что было замечено, что он страдает от тихих обрезок в своей функции `security_compute_create_name` из `compute_create.c`.

```c
12  int security_compute_create_raw(security_context_t scon,
13                                  security_context_t tcon,
14                                  security_class_t   tclass,
15                                  security_context_t * newcon)
16  {
17    char path[PATH_MAX];
18    char *buf;
19    size_t size;
20    int fd, ret;
21
22    if (!selinux_mnt) {
23      errno = ENOENT;
24      return -1;
25    }
26
27    snprintf(path, sizeof path, "%s/create", selinux_mnt);
28    fd = open(path, O_RDWR);
```

В отличие от других примеров, приведенный выше код не будет отлаживать сам себя, и вам придется установить точки останова и отслеживать вызовы, чтобы определить точку первой ошибки. (Кроме того, приведенный выше код полагается, что обрезанный файл не существует или не находится под контролем злоумышленника, выполняя `open` вслепую).

## Время выполнения

Предыдущие разделы сосредоточены на настройке вашего проекта для успеха. Этот раздел рассмотрит дополнительные советы по выполнению программы с повышенной диагностикой и защитой. Не все платформы равны — в GNU Linux сложно, а порой невозможно [добавить защиту программе после компиляции и статической компоновки](https://sourceware.org/ml/binutils/2012-03/msg00309.html), тогда как в Windows можно добавить защиту после сборки через загрузку. Помните, цель состоит в том, чтобы быстро найти точку первой ошибки, чтобы улучшить надежность и безопасность кода.

### Xcode

Xcode предоставляет дополнительные [диагностики кода](https://developer.apple.com/documentation/code_diagnostics), оторые могут помочь найти ошибки памяти и проблемы использования объектов. Схемы можно управлять через пункт меню _Products_, подменю _Scheme_, а затем _Edit_. В редакторе перейдите на вкладку _Diagnostics_. На рисунке ниже четыре дополнительных инструмента включены для цикла отладки: Scribble guards, Edge guards, Malloc guards и Zombies.

![XCode2](../assets/C-Based_Toolchain_Hardening_XCode2.png)

Есть одна оговорка при использовании некоторых защит: Apple предоставляет их только для симулятора, а не для устройства. В прошлом защитные механизмы были доступны как для устройств, так и для симуляторов.

#### Windows

Visual Studio предлагает ряд инструментов для отладки, которые можно использовать во время разработки. Эти инструменты называются [Managed Debugging Assistants (MDAs)](https://docs.microsoft.com/en-us/dotnet/framework/debug-trace-profile/diagnosing-errors-with-managed-debugging-assistants). Вы можете найти MDA в меню _Debug_, затем подменю _Exceptions_. MDA позволяют настроить ваш опыт отладки, например, фильтруя исключения, для которых отладчик должен останавливаться. Дополнительные сведения см. в статье Стивена Туба _[Пусть CLR находит ошибки за вас с помощью помощников по управляемой отладке](https://docs.microsoft.com/en-us/archive/msdn-magazine/2006/may/let-the-clr-find-bugs-for-you-with-managed-debugging-assistants)_.

![Windows1](../assets/C-Based_Toolchain_Hardening_Windows1.png)

Наконец, для усиления защиты во время выполнения Microsoft предлагает полезный инструмент под названием EMET. EMET — это [Enhanced Mitigation Experience Toolkit](https://en.wikipedia.org/wiki/Enhanced_Mitigation_Experience_Toolkit), который позволяет применить защиту ко времени выполнения исполняемого файла, который был построен без нее. Это очень полезно для утилит и других программ, созданных без SDLC.

![Windows2](../assets/C-Based_Toolchain_Hardening_Windows2.png)
