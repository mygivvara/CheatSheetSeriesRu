# Шпаргалка по предотвращению DOM Clobbering

## Введение

[DOM Clobbering](https://domclob.xyz/domc_wiki/#overview) — это тип HTML-инъекции и атаки с повторным использованием кода, при которой злоумышленники вводят HTML-элементы, атрибуты `id` или `name` которых совпадают с именами переменных, используемых для выполнения важных операций безопасности или браузерных API, таких как переменные для получения удаленного контента (например, src скрипта), и тем самым переопределяют их значения.

Это особенно актуально, когда инъекция скриптов невозможна, например, когда она блокируется HTML-санитайзерами или предотвращается контролем выполнения скриптов. В таких сценариях злоумышленники могут по-прежнему внедрять HTML-разметку в веб-страницы и превращать изначально безопасную разметку в исполняемый код, достигая [межсайтового скриптинга (XSS)](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).

**Эта шпаргалка представляет собой список руководств, безопасных практик и шаблонов программирования для предотвращения или ограничения воздействия DOM Clobbering на ваше веб-приложение.**

## Основы

Прежде чем углубиться в DOM Clobbering, освежим в памяти основные сведения о веб-технологиях.

Когда загружается веб-страница, браузер создает [DOM-дерево](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction), представляющее структуру и содержание страницы. JavaScript имеет доступ на чтение и запись к этому дереву.

При создании DOM-дерева браузеры также создают атрибуты для (некоторых) именованных HTML-элементов в объектах `window` и `document`. Именованными HTML-элементами являются те, у которых есть атрибут `id` или `name`. Например, разметка:

```html
<form id=x></a>
```

приведет к тому, что браузеры создадут ссылки на этот элемент формы с атрибутом `x` в объектах `window` и `document`:

```js
var obj1 = document.getElementById('x');
var obj2 = document.x;
var obj3 = document.x;
var obj4 = window.x;
var obj5 = x; // по умолчанию объекты принадлежат глобальному объекту Window, поэтому x равен window.x
console.log(
 obj1 === obj2 && obj2 === obj3 &&
 obj3 === obj4 && obj4 === obj5
); // true
```

При доступе к атрибутам объектов `window` и `document`, ссылки на именованные HTML-элементы обрабатываются до поиска встроенных API и других атрибутов `window` и `document`, что называется [доступом по именованному свойству](https://html.spec.whatwg.org/multipage/nav-history-apis.html#named-access-on-the-window-object). Разработчики, не осведомленные о таком поведении, могут использовать содержимое атрибутов `window`/`document` для выполнения чувствительных операций, таких как получение URL для загрузки удаленного контента, что может быть использовано злоумышленниками путем внедрения разметки с пересекающимися именами. DOM Clobbering может также затронуть встроенные API браузера, вызывая их переопределение.

Если злоумышленники могут внедрить (не скриптовую) HTML-разметку в DOM-дерево, это может изменить значение переменной, на которую полагается веб-приложение, из-за доступа к именованным свойствам, что приведет к сбою, утечке данных или выполнению скриптов, контролируемых злоумышленником. DOM Clobbering использует это (устаревшее) поведение, создавая конфликт имен между средой выполнения (т.е. объектами `window` и `document`) и кодом JavaScript.

### Пример атаки 1

```javascript
let redirectTo = window.redirectTo || '/profile/';
location.assign(redirectTo);
```

Злоумышленник может:

- внедрить разметку `<a id=redirectTo href='javascript:alert(1)'` и получить XSS.
- внедрить разметку `<a id=redirectTo href='phishing.com'` и выполнить открытый редирект.

### Пример атаки 2

```javascript
var script = document.createElement('script');
let src = window.config.url || 'script.js';
s.src = src;
document.body.appendChild(s);
```

Злоумышленник может внедрить разметку `<a id=config><a id=config name=url href='malicious.js'>`, чтобы загрузить дополнительный JavaScript-код и выполнить произвольный клиентский код.

## Сводка руководств

Для быстрой справки ниже приведена сводка обсуждаемых далее руководств.

|    | **Руководства**                                                | Описание                                                                 |
|----|---------------------------------------------------------------|-------------------------------------------------------------------------|
| \# 1  | Используйте HTML-санитайзеры                                  | [ссылка](#1-html-sanitization)                                           |
| \# 2  | Используйте Политику Безопасности Содержимого (CSP)           | [ссылка](#2-content-security-policy)                                     |
| \# 3  | Замораживайте чувствительные DOM-объекты                      | [ссылка](#3-freezing-sensitive-dom-objects)                              |
| \# 4  | Проверяйте все данные, вводимые в DOM-дерево                  | [ссылка](#4-validate-all-inputs-to-dom-tree)                             |
| \# 5  | Используйте явные объявления переменных                       | [ссылка](#5-use-explicit-variable-declarations)                          |
| \# 6  | Не используйте `document` и `window` для глобальных переменных | [ссылка](#6-do-not-use-document-and-window-for-global-variables)         |
| \# 7  | Не доверяйте встроенным API `document` до валидации            | [ссылка](#7-do-not-trust-document-built-in-apis-before-validation)       |
| \# 8  | Применяйте проверку типов                                      | [ссылка](#8-enforce-type-checking)                                       |
| \# 9  | Используйте строгий режим                                      | [ссылка](#9-use-strict-mode)                                             |
| \# 10 | Применяйте обнаружение возможностей браузера                   | [ссылка](#10-apply-browser-feature-detection)                            |
| \# 11 | Ограничьте переменные локальной областью видимости             | [ссылка](#11-limit-variables-to-local-scope)                             |
| \# 12 | Используйте уникальные имена переменных в продакшене           | [ссылка](#12-use-unique-variable-names-in-production)                    |
| \# 13 | Используйте объектно-ориентированные техники программирования, такие как инкапсуляция | [ссылка](#13-use-object-oriented-programming-techniques-like-encapsulation) |

## Техники смягчения угроз

### \#1: Санитизация HTML

Надежные HTML-санитайзеры могут предотвратить или ограничить риск DOM Clobbering различными способами. Например:

- полное удаление именованных свойств, таких как `id` и `name`. Хотя это эффективно, такое решение может мешать использованию именованных свойств для законных функциональных задач.
- изоляция пространств имен, например, добавление префикса к значению именованных свойств, чтобы уменьшить риск коллизий имен.
- динамическая проверка наличия коллизий именованных свойств введенной разметки с существующим DOM-деревом и удаление этих свойств при обнаружении коллизий.

OWASP рекомендует использовать [DOMPurify](https://github.com/cure53/DOMPurify) или [Sanitizer API](https://developer.mozilla.org/en-US/docs/Web/API/HTML_Sanitizer_API) для санитизации HTML.

#### Санитайзер DOMPurify

По умолчанию DOMPurify удаляет все коллизии с **встроенными** API и свойствами (благодаря включенной по умолчанию опции `SANITIZE_DOM`).

Чтобы защититься также от коллизий пользовательских переменных и свойств, необходимо включить настройку `SANITIZE_NAMED_PROPS`:

```js
var clean = DOMPurify.sanitize(dirty, {SANITIZE_NAMED_PROPS: true});
```

Это изолирует пространство имен для именованных свойств и JavaScript-переменных, добавив к ним строку `user-content-`.

#### Sanitizer API

Новый встроенный в браузер [Sanitizer API](https://developer.mozilla.org/en-US/docs/Web/API/HTML_Sanitizer_API) не предотвращает DOM Clobbering в [настройках по умолчанию](https://wicg.github.io/sanitizer-api/#dom-clobbering), но может быть настроен для удаления именованных свойств:

```js
const sanitizerInstance = new Sanitizer({
  blockAttributes: [
    {'name': 'id', elements: '*'},
    {'name': 'name', elements: '*'}
  ]
});
containerDOMElement.setHTML(input, {sanitizer: sanitizerInstance});
```

### \#2: Политика безопасности контента (CSP)

[Политика безопасности контента (CSP)](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy) — это набор правил, которые указывают браузеру, какие ресурсы разрешено загружать на веб-странице. CSP может предотвратить инъекцию вредоносного кода путем ограничения источников JavaScript-файлов (например, с помощью директивы [script-src](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src)).

**Примечание:** CSP может смягчить **некоторые варианты** атак DOM Clobbering, например, когда злоумышленники пытаются загрузить новые скрипты через переопределение источников скриптов. Однако это не предотвратит использование уже существующего кода, который может быть использован для выполнения команд, например, через переопределение параметров конструкций, таких как `eval()`.

### \#3: Замораживание чувствительных объектов DOM

Простой способ предотвратить DOM Clobbering для отдельных объектов — это заморозить чувствительные DOM-объекты и их свойства с помощью метода [Object.freeze()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze).

**Примечание:** Замораживание свойств объекта предотвращает их перезапись именованными элементами DOM. Однако определить все объекты и их свойства, которые необходимо заморозить, может быть сложно, что ограничивает полезность этого подхода.

## Рекомендации по безопасному программированию

DOM Clobbering можно избежать с помощью защитного программирования и соблюдения нескольких шаблонов и руководств по кодированию.

### \#4: Проверяйте все данные перед их добавлением в DOM-дерево

Прежде чем вставлять разметку в DOM-дерево страницы, санитизируйте атрибуты `id` и `name` (см. раздел [Санитизация HTML](#html-sanitization)).

### \#5: Используйте явные объявления переменных

При инициализации переменных всегда используйте объявление переменных с помощью `var`, `let` или `const`, чтобы предотвратить их перезапись.

**Примечание:** Объявление переменной с `let` не создает свойства в `window`, в отличие от `var`. Поэтому переменная `window.VARNAME` все еще может быть переопределена (если `VARNAME` — это имя переменной).

### \#6: Не используйте `document` и `window` для глобальных переменных

Избегайте использования объектов `document` и `window` для хранения глобальных переменных, так как они легко поддаются манипуляциям (см., например, [здесь](https://domclob.xyz/domc_wiki/indicators/patterns.html#do-not-use-document-for-global-variables)).

### \#7: Не доверяйте встроенным API `document` до валидации

Свойства объекта `document`, включая встроенные, всегда могут быть переопределены с помощью DOM Clobbering, даже сразу после их присвоения значения.

**Подсказка:** Это связано с так называемым [алгоритмом видимости именованных свойств](https://webidl.spec.whatwg.org/#legacy-platform-object-abstract-ops), при котором ссылки на именованные HTML-элементы обрабатываются до обращения к встроенным API и другим атрибутам `document`.

### \#8: Применяйте проверку типов

Всегда проверяйте типы свойств `document` и `window` перед их использованием в чувствительных операциях, например, с помощью оператора [instance of](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof).

**Подсказка:** Когда объект переопределен, он будет ссылаться на экземпляр [HTMLElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement), что может не соответствовать ожидаемому типу.

### \#9: Используйте строгий режим

Используйте `strict` режим, чтобы предотвратить непреднамеренное создание глобальных переменных и [вызывать ошибку](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Read-only), когда попытка перезаписать свойства с правами только для чтения.

### \#10: Применяйте обнаружение возможностей браузера

Вместо того, чтобы полагаться на специфические для браузера функции или свойства, используйте обнаружение возможностей браузера, чтобы определить, поддерживается ли функция, перед ее использованием. Это поможет предотвратить ошибки и DOM Clobbering, которые могут возникнуть при использовании этих функций в неподдерживаемых браузерах.

**Подсказка:** Неподдерживаемые API функций могут вести себя как неопределенные переменные/свойства в неподдерживаемых браузерах, что делает их уязвимыми для DOM Clobbering.

### \#11: Ограничьте переменные локальной областью видимости

Глобальные переменные более подвержены перезаписи с помощью DOM Clobbering. По возможности используйте локальные переменные и свойства объектов.

### \#12: Используйте уникальные имена переменных в продакшене

Использование уникальных имен переменных может помочь предотвратить коллизии имен, которые могут привести к случайным перезаписям.

### \#13: Используйте объектно-ориентированные техники программирования, такие как инкапсуляция

Инкапсуляция переменных и функций внутри объектов или классов может помочь предотвратить их перезапись. Сделав их приватными, вы предотвращаете доступ к ним извне объекта, что снижает риск DOM Clobbering.

## Ссылки

- [domclob.xyz](https://domclob.xyz)
- [PortSwigger: DOM Clobbering Strikes Back](https://portswigger.net/research/dom-clobbering-strikes-back)
- [Блог: XSS в AMP4Email от GMail](https://research.securitum.com/xss-in-amp4email-dom-clobbering/)
- [HackTricks: DOM Clobbering](https://book.hacktricks.xyz/pentesting-web/xss-cross-site-scripting/dom-clobbering)
- [HTMLHell: DOM Clobbering](https://www.htmhell.dev/adventcalendar/2022/12/)
