# Шпаргалка по защите от Clickjacking

## Введение

Эта шпаргалка предназначен для предоставления разработчикам рекомендаций по защите от [Clickjacking](https://owasp.org/www-community/attacks/Clickjacking), также известной как атака переадресации пользовательского интерфейса (UI redress).

Существует три основных механизма, которые можно использовать для защиты от таких атак:

- Предотвращение загрузки страницы в фрейме браузером с помощью HTTP-заголовков [X-Frame-Options](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options) или [Content Security Policy (frame-ancestors)](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/frame-ancestors).
- Предотвращение включения файлов cookie сеанса при загрузке страницы в фрейме с использованием атрибута cookie [SameSite](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite).
- Реализация JavaScript-кода на странице, чтобы попытаться предотвратить ее загрузку в фрейме (так называемый "frame-buster").

Обратите внимание, что эти механизмы независимы друг от друга, и, по возможности, следует реализовать более одного из них для обеспечения глубокой защиты.

## Защита с помощью директивы Content Security Policy (CSP) frame-ancestors

Директива `frame-ancestors` может использоваться в HTTP-заголовке Content-Security-Policy, чтобы указать, следует ли браузеру разрешать отображение страницы в `<frame>` или `<iframe>`. Сайты могут использовать это для предотвращения атак Clickjacking, гарантируя, что их контент не будет встроен в другие сайты.

`frame-ancestors` позволяет сайту разрешать несколько доменов с использованием стандартной семантики Content Security Policy.

### Примеры Content-Security-Policy: frame-ancestors

Наиболее распространенные примеры использования CSP frame-ancestors:

- `Content-Security-Policy: frame-ancestors 'none';`
    - Предотвращает отображение контента в любом домене. Эта настройка рекомендуется, если только не обнаружена конкретная необходимость в фреймировании.
- `Content-Security-Policy: frame-ancestors 'self';`
    - Разрешает отображение контента только текущим сайтом.
- `Content-Security-Policy: frame-ancestors 'self' *.somesite.com https://myfriend.site.com;`
    - Разрешает отображение контента текущим сайтом, а также любыми страницами на `somesite.com` (с использованием любого протокола) и только страницей `myfriend.site.com`, использующей только HTTPS на порте по умолчанию (443).

Обратите внимание, что одинарные кавычки обязательны вокруг `self` и `none`, но не используются вокруг других выражений источника.

Подробности и более сложные примеры смотрите в следующей документации:

- <https://w3c.github.io/webappsec-csp/#directive-frame-ancestors>
- <https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/frame-ancestors>

### Ограничения

- **X-Frame-Options имеет приоритет:** [Раздел "Отношение к X-Frame-Options" в спецификации CSP](https://w3c.github.io/webappsec/specs/content-security-policy/#frame-ancestors-and-frame-options) гласит: "*Если ресурс поставляется с политикой, включающей директиву с именем frame-ancestors и которой назначено значение "enforce", заголовок X-Frame-Options ДОЛЖЕН быть проигнорирован*", но Chrome 40 и Firefox 35 игнорируют директиву frame-ancestors и следуют заголовку X-Frame-Options.

### Поддержка браузерами

Следующие [браузеры](https://caniuse.com/?search=frame-ancestors) поддерживают CSP frame-ancestors.

Ссылки:

- [Mozilla Developer Network](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/frame-ancestors#browser_compatibility)

## Защита с помощью HTTP-заголовков X-Frame-Options

HTTP-заголовок `X-Frame-Options` может использоваться для указания, следует ли браузеру разрешать отображение страницы в `<frame>` или `<iframe>`. Сайты могут использовать это для предотвращения атак Clickjacking, гарантируя, что их контент не будет встроен в другие сайты. Установите заголовок X-Frame-Options для всех ответов, содержащих HTML-контент. Возможные значения — "DENY", "SAMEORIGIN" или "ALLOW-FROM uri".

### Типы заголовков X-Frame-Options

Существует три возможных значения для заголовка X-Frame-Options:

- **DENY**, который предотвращает отображение контента в любом домене. Настройка "DENY" рекомендуется, если только не обнаружена конкретная необходимость в фреймировании.
- **SAMEORIGIN**, который разрешает отображение контента только текущим сайтом.
- **ALLOW-FROM uri**, который позволяет указанному "uri" отображать эту страницу (например, `ALLOW-FROM http://www.example.com`).
    - Это устаревшая директива, которая больше не работает в современных браузерах.
    - Проверьте ограничения ниже, поскольку она будет работать в режиме "открыто", если браузер ее не поддерживает.
    - Другие браузеры поддерживают новую [директиву CSP frame-ancestors](https://w3c.github.io/webappsec-csp/#directive-frame-ancestors). Некоторые поддерживают обе.

### Поддержка браузерами

Следующие [браузеры](https://caniuse.com/#search=X-Frame-Options) поддерживают заголовки X-Frame-Options.

Ссылки:

- [Mozilla Developer Network](https://developer.mozilla.org/en-US/docs/web/http/headers/x-frame-options#browser_compatibility)
- [IETF Draft](http://datatracker.ietf.org/doc/draft-ietf-websec-x-frame-options/)
- [X-Frame-Options Compatibility Test](https://erlend.oftedal.no/blog/tools/xframeoptions/) - проверьте это для получения ПОСЛЕДНЕЙ информации о поддержке заголовка X-Frame-Options браузерами.

### Реализация

Для реализации этой защиты вам нужно добавить HTTP-заголовок ответа `X-Frame-Options` на любую страницу, которую вы хотите защитить от Clickjacking через framebusting. Один из способов сделать это — добавить HTTP-заголовок ответа вручную на каждую страницу. Более простой способ — реализовать фильтр, который автоматически добавляет заголовок на каждую страницу, или добавить его на уровне межсетевого экрана веб-приложений или сервера веб-приложений.

### Частые ошибки защиты

Мета-теги, пытающиеся применить директиву X-Frame-Options, НЕ РАБОТАЮТ. Например, `<meta http-equiv="X-Frame-Options" content="deny">` не сработает. Вы должны применить директиву X-FRAME-OPTIONS в качестве HTTP-заголовка ответа, как описано выше.

### Ограничения

- **Определение политики на странице**: Политика должна быть определена для каждой страницы, что может усложнить развертывание. Возможность ее применения для всего сайта, например, при входе в систему, может упростить ее использование.
- **Проблемы с сайтами с несколькими доменами**: Текущая реализация не позволяет администратору сайта предоставить список доменов, которым разрешено фреймирование страницы. Хотя перечисление разрешенных доменов может быть опасным, в некоторых случаях у администратора сайта может не быть выбора, кроме как использовать более одного имени хоста.
- **Поддержка браузером опции ALLOW-FROM**: Опция ALLOW-FROM устарела и больше не работает в современных браузерах. БУДЬТЕ ОСТОРОЖНЫ ПРИ ИСПОЛЬЗОВАНИИ ALLOW-FROM. Если вы примените ее, и браузер ее не поддерживает, у вас не будет защиты от Clickjacking.
- **Несколько вариантов не поддерживаются**: Невозможно разрешить текущему сайту и стороннему сайту отображать один и тот же ответ. Браузеры поддерживают только один заголовок X-Frame-Options и только одно значение для этого заголовка.
- **Вложенные фреймы не работают с SAMEORIGIN и ALLOW-FROM**: В следующей ситуации фрейм `http://framed.invalid/child` не загружается, потому что ALLOW-FROM применяется к верхнему уровню контекста просмотра, а не к непосредственному родителю. Решение состоит в том, чтобы использовать ALLOW-FROM как в родительском, так и в дочернем фреймах (но это предотвращает загрузку дочернего фрейма, если страница `//framed.invalid/parent` загружается как документ верхнего уровня).

![NestedFrames](../assets/Clickjacking_Defense_Cheat_Sheet_NestedFrames.png)

- **X-Frame-Options устарел** Хотя заголовок X-Frame-Options поддерживается основными браузерами, он был заменен на директиву frame-ancestors из спецификации CSP Level 2.
- **Прокси-серверы** Веб-прокси-серверы печально известны добавлением и удалением заголовков. Если веб-прокси удаляет заголовок X-Frame-Options, то сайт теряет защиту от фреймирования.

## Защита с помощью файлов cookie SameSite

Атрибут cookie `SameSite`, определенный в [RFC 6265bis](https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-02#section-5.3.7), в первую очередь предназначен для защиты от [межсайтовой подделки запроса (CSRF)](Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.md#samesite-cookie-attribute); однако он также может обеспечить защиту от атак Clickjacking.

Cookies с атрибутом `SameSite`, установленным на `strict` или `lax`, не будут включены в запросы, отправляемые на страницу внутри `<iframe>`. Это означает, что если сессионные cookies помечены как `SameSite`, любая атака Clickjacking, требующая аутентификации жертвы, не сработает, так как cookie не будут отправлены. Статья на [блоге Netsparker](https://www.netsparker.com/blog/web-security/same-site-cookie-attribute-prevent-cross-site-request-forgery/) предоставляет дополнительные сведения о типах запросов, для которых cookies отправляются в зависимости от разных политик SameSite.

Этот подход обсуждается на сайте [JavaScript.info](https://javascript.info/clickjacking#samesite-cookie-attribute).

### Ограничения

Если атака Clickjacking не требует аутентификации пользователя, этот атрибут не обеспечит никакой защиты.

Кроме того, хотя атрибу `SameSite` поддерживается [большинством современных браузеров](https://caniuse.com/#feat=same-site-cookie-attribute), все еще существует около 6% пользователей (по состоянию на ноябрь 2020 года) с браузерами, которые его не поддерживают.

Использование этого атрибута должно рассматриваться как часть многослойного подхода к защите, и не следует полагаться на него как на единственную меру против Clickjacking.

## Скрипт для защиты от Clickjacking для устаревших браузеров

Один из способов защиты от Clickjacking — это включение скрипта «прерывания фреймов» на каждой странице, которая не должна быть встраиваемой. Следующий метод предотвратит встраивание веб-страницы даже в устаревших браузерах, которые не поддерживают заголовок X-Frame-Options.

В элемент HEAD документа добавьте следующее:

Сначала примените ID к самому элементу стиля:

```html
<style id="antiClickjack">
    body{display:none !important;}
</style>
```

Затем удалите этот стиль по его ID сразу же в скрипте:

```html
<script type="text/javascript">
    if (self === top) {
        var antiClickjack = document.getElementById("antiClickjack");
        antiClickjack.parentNode.removeChild(antiClickjack);
    } else {
        top.location = self.location;
    }
</script>
```

Таким образом, все может находиться в элементе HEAD документа, и вам нужен только один метод/taglib в вашем API.

## Защита с использованием window.confirm()

Использование X-Frame-Options или скрипта прерывания фреймов является более надежным методом защиты от Clickjacking. Однако в ситуациях, когда контент должен быть встраиваемым, можно использовать `window.confirm()`, чтобы помочь смягчить Clickjacking, информируя пользователя о действии, которое он собирается выполнить.

Вызов `window.confirm()` отобразит всплывающее окно, которое не может быть встроено. Если `window.confirm()` вызывается внутри iframe с другим доменом, чем у родителя, диалоговое окно покажет, с какого домена был вызван `window.confirm()`. В этой ситуации браузер отображает источник диалогового окна, чтобы помочь предотвратить атаки Clickjacking. Следует отметить, что Internet Explorer — единственный известный браузер, который не отображает домен, с которого было вызвано диалоговое окно `window.confirm()`. Чтобы решить эту проблему в Internet Explorer, убедитесь, что сообщение в диалоговом окне содержит контекстную информацию о типе выполняемого действия. Например:

```html
<script type="text/javascript">
   var action_confirm = window.confirm("Вы уверены, что хотите удалить свой аккаунт на YouTube?");
   if (action_confirm) {
       //... Выполнить действие
   } else {
       //... Пользователь не хочет выполнять запрошенное действие.
   }
</script>
```

## Небезопасные неработающие скрипты (НЕ ИСПОЛЬЗОВАТЬ)

Рассмотрим следующий фрагмент, который **НЕ рекомендуется** для защиты от Clickjacking:

```html
<script>if (top!=self) top.location.href=self.location.href</script>
```

Этот простой скрипт прерывания фреймов пытается предотвратить встраивание страницы в фрейм или iframe, заставляя родительское окно загрузить URL текущего фрейма. К сожалению, были опубликованы несколько способов обхода этого типа скрипта. Некоторые из них мы рассмотрим ниже.

### Двойное встраивание (Double Framing)

Некоторые техники прерывания фреймов перенаправляют на правильную страницу, присваивая значение `parent.location`. Это работает хорошо, если страница-жертва встроена в один фрейм. Однако если злоумышленник заключит страницу-жертву в один фрейм внутри другого (двойное встраивание), то доступ к `parent.location` станет нарушением безопасности во всех популярных браузерах из-за **политики навигации потомков фрейма**. Это нарушение безопасности отключает действие противодействия навигации.

**Код прерывания фреймов жертвы:**

```javascript
if(top.location != self.location) {
    parent.location = self.location;
}
```

**Верхний фрейм злоумышленника:**

```html
<iframe src="attacker2.html">
```

**Подфрейм злоумышленника:**

```html
<iframe src="http://www.victim.com">
```

### Событие onBeforeUnload

Пользователь может вручную отменить любой запрос навигации, отправленный встроенной страницей. Чтобы воспользоваться этим, встраивающая страница регистрирует обработчик события `onBeforeUnload`, который вызывается всякий раз, когда встраивающая страница собирается быть выгружена из-за навигации. Функция обработчика возвращает строку, которая становится частью запроса, отображаемого пользователю.

Например, злоумышленник хочет встроить PayPal. Он регистрирует функцию обработчика выгрузки, которая возвращает строку «Вы хотите выйти из PayPal?». Когда эта строка отображается пользователю, он, скорее всего, отменит навигацию, что нарушит попытку прерывания фрейма PayPal.

Злоумышленник осуществляет эту атаку, регистрируя событие выгрузки на верхней странице с использованием следующего кода:

```html
<script>
    window.onbeforeunload = function(){
        return "Просим пользователя вежливо";
    }
</script>

<iframe src="http://www.paypal.com">
```

Код прерывания фреймов PayPal сгенерирует событие `BeforeUnload`, активируя нашу функцию и предлагая пользователю отменить событие навигации.

### Промежуточное опустошение (No-Content Flushing)

Хотя предыдущая атака требует взаимодействия с пользователем, то же самое можно сделать без запроса к пользователю. Большинство браузеров (IE7, IE8, Google Chrome и Firefox) позволяют злоумышленнику автоматически отменить входящий запрос на навигацию в обработчике события `onBeforeUnload` путем многократной отправки запроса на навигацию на сайт, отвечающий кодом "204 - No Content".

Переход на сайт с ответом "No Content" фактически является NOP (операцией, которая ничего не выполняет), но очищает канал запросов, тем самым отменяя исходный запрос на навигацию. Вот пример кода для этого:

```javascript
var preventbust = 0
window.onbeforeunload = function() { killbust++ }
setInterval( function() {
    if(killbust > 0){
    killbust = 2;
    window.top.location = 'http://nocontent204.com'
    }
}, 1);
```

```html
<iframe src="http://www.victim.com">
```

### Использование фильтров XSS

IE8 и Google Chrome представили фильтры отражающих XSS, которые помогают защитить веб-страницы от определенных типов XSS-атак. На конференции "Blackhat" Нава и Линдсей заметили, что эти фильтры можно использовать для обхода кода прерывания фреймов. Фильтр XSS в IE8 сравнивает заданные параметры запроса с набором регулярных выражений, чтобы выявить явные попытки межсайтового скриптинга. С помощью "индуцированных ложных срабатываний" фильтр может использоваться для отключения выбранных скриптов. При совпадении начала любого тега `<script>` в параметрах запроса фильтр XSS отключит все встроенные скрипты на странице, включая скрипты прерывания фреймов. Внешние скрипты также могут быть нацелены путем совпадения внешнего включения, что эффективно отключает все внешние скрипты. Поскольку подмножества загруженного JavaScript все еще функционируют (встроенные или внешние), и cookies все еще доступны, эта атака эффективна для Clickjacking.

**Код прерывания фреймов жертвы:**

```html
<script>
    if(top != self) {
        top.location = self.location;
    }
</script>
```

**Злоумышленник:**

```html
<iframe src="http://www.victim.com/?v=<script>if''>
```

Фильтр XSS сопоставит этот параметр `<script>if` с началом скрипта прерывания фрейма на стороне жертвы и, соответственно, отключит все встроенные скрипты на странице жертвы, включая скрипт прерывания фрейма. Фильтр XSSAuditor, доступный для Google Chrome, позволяет провести такую же эксплуатацию.

### одмена top.location

Некоторые современные браузеры рассматривают переменную location как специальный неизменяемый атрибут во всех контекстах. Однако это не относится к IE7 и Safari 4.0.4, где переменная location может быть переопределена.

**IE7**: Как только страница с фреймами переопределяет location, любой код прерывания фреймов в подфрейме, который пытается прочитать `top.location`, вызовет нарушение безопасности, пытаясь прочитать локальную переменную в другом домене. Аналогично, любая попытка навигации путем присвоения значения `top.location` не удастся.

**Код прерывания фреймов жертвы:**

```javascript
if(top.location != self.location) {
    top.location = self.location;
}
```

**Злоумышленник:**

```html
<script>var location = "clobbered";</script>
<iframe src="http://www.victim.com"></iframe>
```

**Safari 4.0.4:**

Мы наблюдали, что хотя location остается неизменяемым в большинстве случаев, когда пользовательский сеттер location определяется с помощью `defineSetter` (через окно), объект location становится неопределенным.

Страница с фреймами просто делает:

```html
<script>
    window.defineSetter("location", function(){});
</script>
```

Теперь любая попытка прочитать или изменить местоположение верхнего фрейма не удастся.

### Ограниченные зоны

Большинство методов прерывания фреймов полагаются на JavaScript на встроенной странице для обнаружения фрейминга и выхода из него. Если JavaScript отключен в контексте подфрейма, код прерывания фреймов не будет выполнен. К сожалению, существует несколько способов ограничить выполнение JavaScript в подфрейме:

**В IE 8:**

```html
<iframe src="http://www.victim.com" security="restricted"></iframe>
```

**В Chrome:**

```html
<iframe src="http://www.victim.com" sandbox></iframe>
```

**Firefox и IE:**

Активируйте [designMode](https://developer.mozilla.org/en-US/docs/Web/API/Document/designMode) на родительской странице.

```javascript
document.designMode = "on";
```
