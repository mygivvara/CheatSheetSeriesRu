# Шпаргалка по безопасности Kubernetes

## Обзор

Эта шпаргалка предоставляет отправную точку для обеспечения безопасности кластера Kubernetes. Она разделена на следующие категории:

- Получение уведомлений о обновлениях Kubernetes
- ВВЕДЕНИЕ: Что такое Kubernetes?
- Защита хостов Kubernetes
- Защита компонентов Kubernetes
- Использование панели управления Kubernetes
- Лучшие практики безопасности Kubernetes: этап сборки
- Лучшие практики безопасности Kubernetes: этап развертывания
- Лучшие практики безопасности Kubernetes: этап выполнения

Для получения дополнительной информации о Kubernetes см. Приложение.

## Получение уведомлений о обновлениях безопасности и отчетность об уязвимостях

Присоединитесь к группе kubernetes-announce (<https://kubernetes.io/docs/reference/issues-security/security/>) для получения уведомлений по электронной почте о объявлениях безопасности. Подробнее о том, как сообщать об уязвимостях, см. на странице по безопасности (<https://kubernetes.io/docs/reference/issues-security/security>).

## ВВЕДЕНИЕ: Что такое Kubernetes?

Kubernetes — это система с открытым исходным кодом для оркестрации контейнеров, автоматизирующая развертывание, масштабирование и управление контейнеризованными приложениями. Проект с открытым исходным кодом поддерживается Cloud Native Computing Foundation (CNCF).

Когда вы разворачиваете Kubernetes, вы получаете кластер. Кластер Kubernetes состоит из набора рабочих машин, называемых узлами, которые запускают контейнеризованные приложения. Плоскость управления (Control Plane) управляет рабочими узлами и Подами в кластере.

### Компоненты плоскости управления

Компоненты плоскости управления принимают глобальные решения о кластере, а также обнаруживают и реагируют на события в кластере. Она состоит из таких компонентов, как kube-apiserver, etcd, kube-scheduler, kube-controller-manager и cloud-controller-manager.

**Компонент:** kube-apiserver  
**Описание:** Предоставляет API Kubernetes. Сервер API является интерфейсом управления Kubernetes.

**Компонент:** etcd  
**Описание:** Консистентное и высокодоступное хранилище ключ-значение, используемое как основное хранилище данных для всех данных кластера Kubernetes.

**Компонент:** kube-scheduler  
**Описание:** Отслеживает вновь созданные Поды без назначенного узла и выбирает для них узел для выполнения.

**Компонент:** kube-controller-manager  
**Описание:** Запускает процессы контроллеров. Логически каждый контроллер является отдельным процессом, но для уменьшения сложности все они скомпилированы в один бинарный файл и выполняются в одном процессе.

**Компонент:** cloud-controller-manager  
**Описание:** Менеджер облачных контроллеров позволяет вам интегрировать кластер с API вашего облачного провайдера и отделяет компоненты, взаимодействующие с облачной платформой, от компонентов, взаимодействующих с самим кластером.

### Компоненты узла

Компоненты узла работают на каждом узле, поддерживая работу Подов и предоставляя среду выполнения Kubernetes. Она включает в себя такие компоненты, как kubelet, kube-proxy и среда выполнения контейнеров.

**Компонент:** kubelet  
**Описание:** Агент, который работает на каждом узле в кластере. Он гарантирует, что контейнеры работают внутри Подов.

**Компонент:** kube-proxy  
**Описание:** Сетевой прокси-сервер, который работает на каждом узле в вашем кластере и реализует часть концепции Сервиса Kubernetes.

**Контейнер:** runtime  
**Описание:** Программное обеспечение, ответственное за запуск контейнеров.

## РАЗДЕЛ 1: Защита хостов Kubernetes

Kubernetes можно развернуть разными способами: на физических серверах, в локальной инфраструктуре или в публичном облаке (кастомная сборка Kubernetes на виртуальных машинах ИЛИ использование управляемого сервиса). Поскольку Kubernetes разработан для высокой переносимости, пользователи могут легко перемещать свои рабочие нагрузки и переключаться между несколькими установками.

Однако эта гибкость представляет собой слабое место с точки зрения безопасности кластеров Kubernetes. Инженеры, отвечающие за развертывание платформы Kubernetes, должны знать обо всех потенциальных векторах атак и уязвимостях своих кластеров.

Чтобы усилить защиту базовых хостов для кластеров Kubernetes, мы рекомендуем установить последнюю версию операционных систем, усилить их безопасность, внедрить необходимые системы управления патчами и конфигурациями, настроить важные правила межсетевого экрана и принять специфические меры безопасности в датацентре.

### Обновление Kubernetes

Поскольку никто не может отследить все потенциальные векторы атак на ваш кластер Kubernetes, первой и самой важной линией защиты является всегда использование последней стабильной версии Kubernetes.

Если в работающих контейнерах обнаружены уязвимости, рекомендуется всегда обновлять исходный образ и повторно разворачивать контейнеры. **Старайтесь избегать прямого обновления работающих контейнеров, так как это может нарушить связь между образом и контейнером.**

```
Пример: apt-update
```

**Обновление контейнеров становится очень простым благодаря функции постепенного обновления (rolling updates) Kubernetes, которая позволяет обновлять запущенные приложения, постепенно обновляя их образы до последней версии.**

#### График выпусков Kubernetes

Проект Kubernetes поддерживает ветки релизов для последних трёх минорных версий и осуществляет обратное портирование применимых исправлений, включая исправления безопасности, в эти три ветки, в зависимости от серьезности и возможности реализации. Патчи выпускаются на регулярной основе, а также при необходимости — дополнительные срочные выпуски. Поэтому всегда рекомендуется обновлять кластер Kubernetes до последней доступной стабильной версии. Рекомендуется ознакомиться с политикой несовпадения версий по ссылке <https://kubernetes.io/docs/setup/release/version-skew-policy/>.

Существуют различные техники, такие как постепенные обновления (rolling updates) и миграции пулов узлов, которые позволяют выполнить обновление с минимальными сбоями и простоями.

## РАЗДЕЛ 2: Защита компонентов Kubernetes

Этот раздел описывает, как обеспечить безопасность компонентов Kubernetes. Он охватывает следующие темы:

- Защита панели управления Kubernetes
- Ограничение доступа к etcd (Важно)
- Контроль сетевого доступа к чувствительным портам
- Контроль доступа к API Kubernetes
- Внедрение ролевого контроля доступа в Kubernetes
- Ограничение доступа к Kubelet

--

### Защита панели управления Kubernetes

Панель управления Kubernetes — это веб-приложение для управления кластером. Оно не является частью самого кластера и должно быть установлено владельцами кластера. Существует множество руководств по установке панели управления. К сожалению, большинство из них создают учетные записи с очень высокими привилегиями. Это привело к тому, что Tesla и некоторые другие компании стали жертвами атак через неправильно настроенную панель управления Kubernetes. (Ссылка: Ресурсы Tesla взломаны для майнинга криптовалюты - <https://arstechnica.com/information-technology/2018/02/tesla-cloud-resources-are-hacked-to-run-cryptocurrency-mining-malware/>)

Чтобы предотвратить атаки через панель управления, рекомендуется следовать следующим советам:

- Не открывайте доступ к панели управления без дополнительной аутентификации в интернет. Нет необходимости в доступе к такому мощному инструменту вне вашей локальной сети (LAN)
- Включите Ролевой Контроль Доступа (см. ниже), чтобы ограничить учетную запись службы, используемую панелью управления
- Не предоставляйте учетной записи службы панели управления высокие привилегии
- Предоставляйте права каждому пользователю индивидуально, чтобы они видели только то, что им разрешено
- Если вы используете сетевые политики, можно заблокировать запросы к панели управления даже из внутренних Подов (это не повлияет на туннель прокси через kubectl proxy)
- В версиях до 1.8 панель управления имела учетную запись службы с полными привилегиями, поэтому проверьте, чтобы не осталось привязки роли cluster-admin
- Разверните панель управления с аутентифицирующим обратным прокси и включите многофакторную аутентификацию. Это можно сделать с помощью встроенных OIDC `id_tokens` или используя Kubernetes Impersonation. Это позволяет использовать панель управления с учетными данными пользователя вместо привилегированной учетной записи `ServiceAccount`. Этот метод можно использовать как в локальных кластерах, так и в управляемых облачных кластерах.

--

### Ограничение доступа к etcd (ВАЖНО)

etcd — это критический компонент Kubernetes, который хранит информацию о состоянии и секретах, и его следует защищать иначе, чем остальные части кластера. Доступ на запись к etcd от API-сервера эквивалентен получению root-доступа ко всему кластеру, а даже доступ на чтение может использоваться для эскалации привилегий.

Планировщик Kubernetes ищет в etcd определения Подов, не имеющих узла, и направляет их на выполнение в доступные узлы. Валидация Подов проводится API-сервером перед записью в etcd, поэтому злоумышленники, пишущие напрямую в etcd, могут обойти многие механизмы безопасности, такие как политики безопасности Подов (PodSecurityPolicies).

Администраторы должны использовать сильные учетные данные для API-серверов при доступе к etcd, например, взаимную аутентификацию через TLS-сертификаты клиента, и часто рекомендуется изолировать серверы etcd за межсетевым экраном, доступным только для API-серверов.

#### Ограничение доступа к основной инстанции etcd

Разрешение другим компонентам внутри кластера доступа к основной инстанции etcd с правами на чтение или запись всего ключевого пространства эквивалентно предоставлению доступа на уровне cluster-admin. Рекомендуется использовать отдельные инстанции etcd для других компонентов или применять ACL в etcd для ограничения доступа к части ключевого пространства.

--

### Контроль сетевого доступа к чувствительным портам

Настоятельно рекомендуется настроить аутентификацию и авторизацию на уровне кластера и узлов. Поскольку кластеры Kubernetes обычно прослушивают определенный набор портов, злоумышленники могут легко определить эти порты и атаковать кластер.

Ниже приведен обзор стандартных портов, используемых в Kubernetes. Убедитесь, что ваша сеть блокирует доступ к этим портам, и всерьез рассмотрите возможность ограничения доступа к API-серверу Kubernetes только доверенным сетям.

**Узлы плоскости управления:**

| Протокол | Диапазон портов | Назначение                 |
| -------- | --------------- | -------------------------- |
| TCP      | 6443-           | API-сервер Kubernetes      |
| TCP      | 2379-2380       | API для клиентов сервера etcd |
| TCP      | 10250           | API Kubelet                |
| TCP      | 10251           | kube-scheduler             |
| TCP      | 10252           | kube-controller-manager    |
| TCP      | 10255           | API Kubelet (только для чтения) |

**Рабочие узлы:**

| Протокол | Диапазон портов  | Назначение                 |
| -------- | ---------------- | -------------------------- |
| TCP      | 10250            | API Kubelet                |
| TCP      | 10255            | API Kubelet (только для чтения) |
| TCP      | 30000-32767      | Сервисы NodePort           |

--

### Контроль доступа к API Kubernetes

Первая линия защиты Kubernetes от атакующих — это ограничение и защита доступа к API-запросам, так как они используются для управления платформой Kubernetes. Подробнее см. в документации: <https://kubernetes.io/docs/reference/access-authn-authz/controlling-access/>.

Этот раздел охватывает следующие темы:

- Как Kubernetes обрабатывает авторизацию API-запросов
- Внешняя аутентификация API для Kubernetes (рекомендуется)
- Встроенная аутентификация API Kubernetes (не рекомендуется)
- Внедрение ролевого контроля доступа в Kubernetes
- Ограничение доступа к Kubelet

--

#### Как Kubernetes обрабатывает авторизацию API-запросов

В Kubernetes, прежде чем запрос может быть авторизован (получить разрешение на доступ), пользователь должен быть аутентифицирован (войти в систему). Kubernetes ожидает атрибутов, типичных для REST API-запросов. Это означает, что существующие системы управления доступом на уровне организации или облачного провайдера, которые работают с другими API, могут использоваться для авторизации запросов в Kubernetes.

Когда Kubernetes авторизует API-запросы через API-сервер, по умолчанию разрешения на доступ отклоняются. Он оценивает все атрибуты запроса в соответствии со всеми существующими политиками и разрешает или отклоняет запрос. Для выполнения запроса все его части должны быть разрешены какой-либо политикой.

--

#### Внешняя аутентификация API для Kubernetes (РЕКОМЕНДУЕТСЯ)

Из-за слабости внутренних механизмов Kubernetes для аутентификации API настоятельно рекомендуется, чтобы для крупных или производственных кластеров использовались одни из внешних методов аутентификации API.

- [OpenID Connect](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#openid-connect-tokens) (OIDC) позволяет вынести аутентификацию на внешний уровень, использовать токены с коротким сроком действия и централизованные группы для авторизации.
- Управляемые дистрибутивы Kubernetes, такие как GKE, EKS и AKS, поддерживают аутентификацию с использованием учетных данных их соответствующих поставщиков IAM.
- [Имперсонация в Kubernetes](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation) может использоваться как в управляемых облачных кластерах, так и в локальных кластерах для вынесения аутентификации на внешний уровень без необходимости доступа к параметрам конфигурации API-сервера.

Кроме выбора подходящей системы аутентификации, доступ к API должен рассматриваться как привилегированный и использовать многофакторную аутентификацию (MFA) для всех пользователей.

Дополнительную информацию можно найти в справочной документации по аутентификации Kubernetes: <https://kubernetes.io/docs/reference/access-authn-authz/authentication>.

--

#### Опции для встроенной аутентификации API в Kubernetes (НЕ РЕКОМЕНДУЕТСЯ)

Kubernetes предоставляет несколько внутренних механизмов для аутентификации API-сервера, но они обычно подходят только для небольших или непроизводственных кластеров. Ниже мы кратко рассмотрим каждый механизм и объясним, почему не рекомендуется их использовать.

- [Статический файл токенов](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#static-token-file): Аутентификация с использованием открытых текстовых токенов, хранящихся в CSV-файле на узлах API-сервера. ВНИМАНИЕ: Вы не сможете изменить учетные данные в этом файле, пока не перезапустите API-сервер.

- [Клиентские сертификаты X509](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#x509-client-certs) доступны, но не подходят для использования в производственных средах, так как Kubernetes [не поддерживает отзыв сертификатов](https://github.com/kubernetes/kubernetes/issues/18982). В результате, учетные данные пользователей не могут быть изменены или отозваны без замены ключа корневого центра сертификации и перевыпуска всех сертификатов кластера.

- [Токены учетных записей службы](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#service-account-tokens) также могут использоваться для аутентификации. Их основное предназначение — предоставить возможность рабочим нагрузкам, выполняющимся в кластере, аутентифицироваться на API-сервере, хотя они также могут использоваться для аутентификации пользователей.

--

### Внедрение ролевого контроля доступа в Kubernetes

Ролевой контроль доступа (RBAC) — это метод регулирования доступа к ресурсам компьютера или сети на основе ролей отдельных пользователей в вашей организации. К счастью, Kubernetes имеет встроенный компонент RBAC с предустановленными ролями, который позволяет определить обязанности пользователей в зависимости от того, какие действия клиент может выполнить. Рекомендуется использовать авторизаторы Node и RBAC в сочетании с плагином NodeRestriction.

Компонент RBAC сопоставляет пользователя или группу с набором разрешений, связанных с ролями. Эти разрешения сочетают глаголы (получить, создать, удалить) с ресурсами (Pods, сервисы, узлы) и могут быть ограничены на уровне пространства имен или всего кластера. Авторизация RBAC использует группу API rbac.authorization.k8s.io для принятия решений об авторизации, что позволяет динамически настраивать политики через API Kubernetes.

Чтобы включить RBAC, необходимо запустить API-сервер с флагом --authorization-mode, установив его в список, включающий RBAC, например:

```bash
kube-apiserver --authorization-mode=Example,RBAC --other-options --more-options
```

Для подробных примеров использования RBAC см. документацию Kubernetes: <https://kubernetes.io/docs/reference/access-authn-authz/rbac>

--

### Ограничение доступа к Kubelet

Kubelet открывает HTTPS-эндпоинты, которые предоставляют мощный контроль над узлом и контейнерами. По умолчанию Kubelet разрешает неаутентифицированный доступ к этому API. В производственных кластерах необходимо включить аутентификацию и авторизацию для Kubelet.

Дополнительную информацию можно найти в документации по аутентификации/авторизации Kubelet: <https://kubernetes.io/docs/reference/access-authn-authz/kubelet-authn-authz/>.

--

## РАЗДЕЛ 3: Лучшие практики безопасности Kubernetes: Этап сборки

На этапе сборки необходимо обеспечить безопасность образов контейнеров Kubernetes, создавая безопасные образы и сканируя их на наличие известных уязвимостей.

--

### Что такое образ контейнера?

Образ контейнера (CI) — это неизменяемый, легковесный, автономный, исполняемый пакет программного обеспечения, который включает все необходимое для запуска приложения: код, среду выполнения, системные инструменты, системные библиотеки и настройки [<https://www.docker.com/resources/what-container>]. Каждый образ использует ядро операционной системы, установленной на хост-машине.

Ваши образы контейнеров должны быть построены на утвержденном и безопасном базовом образе. Этот базовый образ необходимо регулярно сканировать и мониторить, чтобы убедиться, что все образы контейнеров создаются на основе безопасного и подлинного образа. Внедрите строгие правила управления, определяющие, как создаются образы и хранятся в доверенных реестрах образов.

--

#### Обеспечение актуальности CI

Убедитесь, что ваши образы (и любые сторонние инструменты, которые вы включаете) актуальны и используют последние версии своих компонентов.

--

### Используйте только авторизованные образы в вашей среде

Загрузка и запуск CI из неизвестных источников очень опасны. Убедитесь, что только образы, соответствующие политике организации, разрешены для использования, иначе организация рискует запустить уязвимые или даже вредоносные контейнеры.

--

### Используйте конвейер CI для управления и выявления уязвимостей

Реестр контейнеров Kubernetes служит центральным хранилищем всех образов контейнеров в системе. В зависимости от ваших нужд вы можете использовать публичный реестр или иметь частный реестр в качестве хранилища контейнеров. Мы рекомендуем хранить утвержденные образы в частном реестре и загружать только утвержденные образы в эти реестры, что автоматически сокращает количество потенциальных образов, попадающих в ваш конвейер, до минимального числа по сравнению с сотнями тысяч доступных публично образов.

Также настоятельно рекомендуется интегрировать конвейер CI, который включает оценку безопасности (например, сканирование на уязвимости) в процесс сборки. Этот конвейер должен проверять весь код, одобренный для производства, и используемый для создания образов. После создания образа он должен быть просканирован на наличие уязвимостей. Только если не будет найдено проблем, образ можно отправить в частный реестр и затем развернуть в производственной среде. Если механизм оценки безопасности не пройдет проверку кода, это должно вызвать сбой в конвейере, что поможет вам выявить образы с проблемами безопасности и предотвратит их попадание в реестр образов.

Многие репозитории исходного кода предоставляют возможности сканирования (например, [Github](https://docs.github.com/en/code-security/supply-chain-security), [GitLab](https://docs.gitlab.com/ee/user/application_security/container_scanning/index.html)), а многие инструменты CI предлагают интеграцию с открытыми сканерами уязвимостей, такими как [Trivy](https://github.com/aquasecurity/trivy) или [Grype](https://github.com/anchore/grype).

Проекты разрабатывают плагины для авторизации образов в Kubernetes, которые предотвращают отправку неавторизованных образов. Для получения дополнительной информации см. PR <https://github.com/kubernetes/kubernetes/pull/27129>.

--

### Минимизация функционала всех CI

В качестве лучшей практики, Google и другие технологические гиганты уже много лет строго ограничивают количество кода в своих контейнерах во время выполнения. Такой подход улучшает соотношение сигнала к шуму для сканеров (например, CVE) и снижает нагрузку по установлению подлинности компонентов только до необходимых.

Рассмотрите возможность использования минимальных CI, таких как distroless-образы (см. ниже). Если это невозможно, не включайте в CI менеджеры пакетов ОС или оболочки, так как они могут содержать неизвестные уязвимости. Если необходимо включить пакеты ОС, удалите менеджер пакетов на последнем этапе процесса генерации.

--

#### Использование distroless или пустых образов

Distroless-образы значительно сокращают поверхность атаки, так как они не содержат оболочки и включают меньше пакетов по сравнению с другими образами. Подробнее о distroless-образах можно узнать здесь: <https://github.com/GoogleContainerTools/distroless>.

Пустой образ, идеальный для статически скомпилированных языков, таких как Go, имеет минимальную поверхность атаки — только ваш код!

Для получения дополнительной информации, см. <https://hub.docker.com/_/scratch>.

---

## РАЗДЕЛ 4: Лучшие практики безопасности Kubernetes: Этап развертывания

После того как инфраструктура Kubernetes настроена, её необходимо безопасно конфигурировать перед развертыванием рабочих нагрузок. При этом важно обеспечить видимость того, какие CI развертываются и как они развертываются. Без этого вы не сможете определить и отреагировать на нарушения политики безопасности. До развертывания система должна уметь определять и сообщать вам:

- **Что развертывается** — включая информацию о используемом образе, такие как его компоненты или уязвимости, а также о подах, которые будут развернуты.
- **Где будет развернуто** — в каких кластерах, пространствах имен и на каких узлах.
- **Как оно развернуто** — работает ли оно с привилегиями, с какими другими развертываниями оно может взаимодействовать, какой контекст безопасности подов применен, если таковой имеется.
- **К чему оно имеет доступ** — включая секреты, тома и другие компоненты инфраструктуры, такие как хост или API оркестратора.
- **Соответствует ли оно требованиям** — соблюдает ли оно ваши политики и требования безопасности.

--

### Код, использующий пространства имен для изоляции ресурсов Kubernetes

Пространства имен (namespaces) позволяют создавать логические разделы, обеспечивать разделение ресурсов и ограничивать область действий пользователей.

--

#### Установка пространства имен для запроса

Чтобы установить пространство имен для текущего запроса, используйте флаг `--namespace`. Примеры команд:

```bash
kubectl run nginx --image=nginx --namespace=<вставьте-имя-пространства-имен>
kubectl get pods --namespace=<вставьте-имя-пространства-имен>
```

--

#### Установка предпочтительного пространства имен

Вы можете сохранить пространство имен для всех последующих команд `kubectl` в этом контексте:

```bash
kubectl config set-context --current --namespace=<вставьте-имя-пространства-имен>
```

Проверьте настройку следующей командой:

```bash
kubectl config view --minify | grep namespace:
```

Подробнее о пространствах имен можно узнать на <https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces>.

--

### Использование ImagePolicyWebhook для управления происхождением образов

Мы настоятельно рекомендуем использовать контроллер допуска ImagePolicyWebhook для предотвращения использования неутвержденных образов, отклонения подов с неутвержденными образами и отказа в использовании CI, соответствующих следующим критериям:

- Образы, которые не были недавно просканированы
- Образы, использующие неподтвержденные базовые образы
- Образы из небезопасных регистров

Подробнее о вебхуке читайте на <https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#imagepolicywebhook>.

--

### Реализуйте постоянное сканирование на уязвимости безопасности

Поскольку новые уязвимости постоянно обнаруживаются, ваши контейнеры могут быть подвержены недавно выявленным уязвимостям (CVE) или устаревшим пакетам. Для поддержания высокого уровня безопасности регулярно проводите сканирование как собственных контейнеров (те, которые вы создали и ранее сканировали), так и сторонних контейнеров (полученных из доверенных репозиториев и у проверенных поставщиков).

Проекты с открытым исходным кодом, такие как [ThreatMapper](https://github.com/deepfence/ThreatMapper), могут помочь в выявлении и приоритезации уязвимостей.

--

### Постоянно оценивайте привилегии, используемые контейнерами

Мы настоятельно рекомендуем, чтобы все контейнеры следовали принципу наименьших привилегий, так как уровень безопасности сильно зависит от предоставленных контейнерам возможностей, привязок ролей и привилегий. Каждый контейнер должен иметь только те минимальные привилегии и возможности, которые необходимы для выполнения его основной функции.

**Используйте политики безопасности подов (Pod Security Policies) для контроля параметров безопасности подов, включая уровни привилегий контейнеров.**

Все политики безопасности должны включать следующие условия:

- Процессы приложения не должны запускаться от имени пользователя root.
- Эскалация привилегий не допускается.
- Файловая система root доступна только для чтения.
- Используется стандартная (скрытая) точка монтирования файловой системы /proc.
- Сетевое пространство узла или пространство процессов не должно использоваться (установка `hostNetwork: true` приведет к игнорированию NetworkPolicies, так как под будет использовать сеть узла).
- Удаляются неиспользуемые и ненужные возможности Linux.
- Используйте параметры SELinux для более точного управления процессами.
- Для каждого приложения создайте отдельную учетную запись Kubernetes Service Account.
- Если контейнеру не требуется доступ к API Kubernetes, не позволяйте ему монтировать учетные данные сервисной учетной записи.

Подробнее о политиках безопасности подов можно узнать в документации на <https://kubernetes.io/docs/concepts/policy/pod-security-policy/>.

--

### Применение контекста безопасности к подам и контейнерам

Контекст безопасности (security context) — это свойство, определенное в файле развертывания YAML, которое управляет параметрами безопасности для всех подов, контейнеров и томов, и его необходимо применять по всей инфраструктуре. При правильной реализации контекста безопасности можно устранить целые классы атак, которые зависят от привилегированного доступа. Например, любая атака, основанная на установке программного обеспечения или записи в файловую систему, будет остановлена, если вы укажете файловую систему root только для чтения в контексте безопасности.

При настройке контекста безопасности для подов предоставляйте только те привилегии, которые необходимы для работы ресурсов в контейнерах и томах. Некоторые важные параметры контекста безопасности:

Параметры контекста безопасности:

1. **SecurityContext->runAsNonRoot**  
   Описание: Указывает, что контейнеры должны запускаться не от имени пользователя root.

2. **SecurityContext->Capabilities**  
   Описание: Управляет возможностями Linux, назначенными контейнеру.

3. **SecurityContext->readOnlyRootFilesystem**  
   Описание: Управляет тем, сможет ли контейнер записывать данные в файловую систему root.

4. **PodSecurityContext->runAsNonRoot**  
   Описание: Предотвращает запуск контейнера с пользователем root в составе пода.
#### Пример контекста безопаности

```yaml
apiVersion: v1

kind: Pod
metadata:
  name: hello-world
spec:
  containers:
  # specification of the pod’s containers
  # ...
  # ...
  # Security Context
  securityContext:
    readOnlyRootFilesystem: true
    runAsNonRoot: true
```

Для дополнительной информации о контексте безопасности для подов, смотрите <https://kubernetes.io/docs/tasks/configure-pod-container/security-context>

For more information on security context for Pods, refer to the documentation at <https://kubernetes.io/docs/tasks/configure-pod-container/security-context>.

### Дополнительная безопасность с использованием service mesh

Service mesh — это слой инфраструктуры, который управляет взаимодействием между сервисами приложений быстро, безопасно и надежно. Он помогает упростить управление микросервисами и их развертыванием, предоставляя единообразный способ обеспечения безопасности, подключения и мониторинга микросервисов. Service mesh также решает эксплуатационные задачи, связанные с запуском контейнеров и микросервисов.

#### Преимущества service mesh

1. **Наблюдаемость**

Service mesh генерирует трассировку и метрики телеметрии, что упрощает понимание вашей системы и быстрое выявление причин проблем.

2. **Специализированные функции безопасности**

Service mesh быстро идентифицирует любой компрометирующий трафик, попадающий в ваш кластер, и может защитить сервисы внутри сети при правильной реализации. Он также помогает управлять безопасностью с помощью mTLS, контроля входящего и исходящего трафика и других функций.

3. **Безопасность микросервисов с помощью mTLS**

Service mesh эффективно защищает трафик между микросервисами с помощью шифрования mTLS (взаимное TLS). Mesh автоматически шифрует и дешифрует запросы и ответы, снимая это бремя с разработчиков приложений. Он также может улучшить производительность, повторно используя существующие соединения, что снижает потребность в дорогостоящем создании новых.

4. **Контроль входящего и исходящего трафика**

Service mesh позволяет контролировать трафик, проходящий через систему, и защищать периметр с помощью правил входа, а также управлять взаимодействием с внешними сервисами через контроль исходящего трафика.

5. **Операционный контроль**

Mesh помогает командам безопасности и платформам задавать макро-контроль для обеспечения правильных политик доступа, при этом позволяя разработчикам проводить необходимые настройки в рамках этих границ.

6. **Управление RBAC**

Service mesh помогает реализовать эффективную систему управления доступом на основе ролей (RBAC), которая ограничивает привилегии пользователей минимально необходимыми и обеспечивает доступ к системам по принципу «по умолчанию все запрещено».

--

#### Недостатки service mesh

Хотя service mesh имеет множество преимуществ, с его использованием связаны также определённые сложности, среди которых:

- **Усложнение инфраструктуры**  
  Введение прокси, sidecar-контейнеров и других компонентов добавляет дополнительный слой сложности в уже и так сложную среду разработки и эксплуатации.

- **Необходимость дополнительной экспертизы**  
  Если добавить mesh, такой как Istio, поверх оркестратора, например, Kubernetes, операторам потребуется глубокое знание обеих технологий.

- **Замедление инфраструктуры**  
  Поскольку service mesh — это сложная и инвазивная технология, она может значительно замедлить архитектуру.

- **Необходимость освоения новой платформы**  
  Service mesh заставляет разработчиков и операторов адаптироваться к новой, жёстко структурированной платформе и её правилам.

### Внедрение централизованного управления политиками

Существует множество проектов, которые предоставляют централизованное управление политиками для Kubernetes-кластера, включая [Open Policy Agent](https://www.openpolicyagent.org/) (OPA), [Kyverno](https://kyverno.io/), и [Validating Admission Policy](https://kubernetes.io/docs/reference/access-authn-authz/validating-admission-policy/) (встроенная, но пока ещё бета-функция Kubernetes начиная с версии 1.28). Для примера мы сосредоточимся на OPA в этом cheat sheet.

OPA был запущен в 2016 году с целью унификации выполнения политик в различных технологиях и системах, и его можно использовать для обеспечения выполнения политик на таких платформах, как Kubernetes. На текущий момент OPA является частью CNCF как инкубационный проект и предоставляет единый метод применения политик безопасности в стеке. В то время как разработчики могут контролировать кластер с помощью RBAC и политик безопасности для pod'ов, эти технологии действуют только внутри кластера, но не за его пределами.

OPA — это универсальный инструмент выполнения политик, который не базируется на других проектах, что делает его гибким. Политики OPA могут интегрироваться с API, SSH-демоном Linux, объектными хранилищами (например, Ceph), а также использовать любые допустимые JSON-данные в качестве входных атрибутов, если они содержат необходимую информацию. Вы можете самостоятельно выбирать входные и выходные данные — например, вернуть JSON-объект с логическим значением, числом, строкой или даже сложной структурой данных.

#### Основные случаи использования OPA

##### OPA для авторизации приложений

OPA предоставляет готовую технологию авторизации, что избавляет команду от необходимости разрабатывать её с нуля. Он использует декларативный язык политик для создания и применения правил, таких как «Алиса может записывать в этот репозиторий» или «Боб может обновить эту учётную запись». Это решение предоставляет разработчикам инструменты для интеграции политик в приложения и позволяет конечным пользователям создавать свои политики для своих арендаторов.

Если у вас уже есть собственное решение для авторизации приложений, возможно, OPA вам не подойдёт. Однако если вы стремитесь повысить эффективность разработки, масштабируя её для микросервисов и декомпозируя монолитные приложения, OPA или его аналоги могут быть решением.

##### OPA для контроля доступа в Kubernetes

Kubernetes предоставляет разработчикам значительный контроль над такими аспектами, как вычисления, сеть и хранилище, что позволяет им настраивать инфраструктуру под свои нужды. Это, в свою очередь, требует от администраторов и команд безопасности контроля за тем, чтобы разработчики не нанесли вред своей работе или работе других.

OPA помогает построить политики безопасности, которые ограничивают доступ только к доверенным источникам контейнерных образов, запрещают запуск ПО с правами root, требуют шифрование данных на хранилище и предотвращают их удаление при перезапуске пода. OPA интегрируется напрямую с Kubernetes API и имеет полномочия отклонять любые ресурсы, которые не соответствуют установленным политикам. Политики могут применяться также на ранних стадиях разработки (например, в CICD-пайплайне или даже на этапе разработки на локальных компьютерах), чтобы разработчики получали обратную связь как можно раньше.

##### OPA для авторизации в service mesh

Наконец, OPA может управлять использованием архитектуры service mesh. Администраторы могут создавать политики для обеспечения соответствия требованиям безопасности, даже если это требует изменения исходного кода. OPA можно встроить в service mesh для контроля API микросервисов и предотвращения бокового движения в микросервисной архитектуре, обеспечивая при этом гибкую политику авторизации для межсервисных взаимодействий.

### Ограничение использования ресурсов в кластере

Важно определить квоты на ресурсы для контейнеров в Kubernetes, так как все ресурсы в кластере Kubernetes по умолчанию создаются без ограничений по CPU и запросам/ограничениям памяти. Если вы запускаете контейнеры без ограничений ресурсов, ваша система может столкнуться с риском отказа в обслуживании (DoS) или сценариями "шумного соседа". К счастью, OPA может использовать квоты на ресурсы для пространства имен, что позволит ограничить количество или емкость ресурсов, предоставляемых этому пространству имен, и ограничить его, задавая емкость CPU, память или пространство на диске.

Кроме того, OPA может ограничить количество подов, сервисов или томов в каждом пространстве имен и может ограничивать максимальный или минимальный размер некоторых из указанных ресурсов. Квоты на ресурсы устанавливают значения по умолчанию, если они не указаны, и предотвращают запросы пользователей на неоправданно высокие или низкие значения для обычно зарезервированных ресурсов, таких как память.

Ниже приведен пример определения квоты на ресурсы пространства имен в соответствующем файле yaml. Этот пример ограничивает количество подов в пространстве имен до 4, ограничивает запросы CPU от 1 до 2 и запросы памяти от 1 ГБ до 2 ГБ.

`compute-resources.yaml`:

```yaml
apiVersion: v1
kind: ResourceQuota
metadata:
  name: compute-resources
spec:
  hard:
    pods: "4"
    requests.cpu: "1"
    requests.memory: 1Gi
    limits.cpu: "2"
    limits.memory: 2Gi
```

Назначьте квоту на ресурсы для пространства имен:

```bash
kubectl create -f ./compute-resources.yaml --namespace=myspace
```

Для получения дополнительной информации о настройке квот на ресурсы, обратитесь к документации Kubernetes по адресу <https://kubernetes.io/docs/concepts/policy/resource-quotas/>.

### Использование сетевых политик Kubernetes для управления трафиком между подами и кластерами

Если в вашем кластере работают разные приложения, скомпрометированное приложение может атаковать другие соседние приложения. Это может произойти, потому что Kubernetes по умолчанию позволяет каждому поду контактировать с любым другим подом. Если разрешен входящий трафик из внешней сети, под сможет отправлять свой трафик на конечную точку за пределами кластера.

Рекомендуется внедрить сетевую сегментацию, так как это ключевой элемент безопасности, который гарантирует, что контейнеры могут общаться только с другими одобренными контейнерами и предотвращает перемещение атакующих между контейнерами. Однако применение сетевой сегментации в облаке представляет собой сложную задачу из-за «динамической» природы сетевых идентификаторов контейнеров (IP).

Пользователи Google Cloud Platform могут воспользоваться автоматическими правилами брандмауэра, которые предотвращают межкластерное общение. Другие пользователи могут применять аналогичные реализации, развертывая на собственных серверах с помощью сетевых брандмауэров или решений SDN. Также группа Kubernetes Network SIG работает над методами, которые значительно улучшат политики связи между подами. Новый API сетевых политик должен решить проблему создания правил брандмауэра для подов, ограничивая сетевой доступ, который может иметь контейнер.

Ниже приведен пример сетевой политики, которая контролирует сеть для подов «backend», разрешая входящий сетевой доступ только от подов «frontend»:

```json
POST /apis/net.alpha.kubernetes.io/v1alpha1/namespaces/tenant-a/networkpolicys
{
  "kind": "NetworkPolicy",
  "metadata": {
    "name": "pol1"
  },
  "spec": {
    "allowIncoming": {
      "from": [{
        "pods": { "segment": "frontend" }
      }],
      "toPorts": [{
        "port": 80,
        "protocol": "TCP"
      }]
    },
    "podSelector": {
      "segment": "backend"
    }
  }
}
```

Для получения дополнительной информации о настройке сетевых политик, обратитесь к документации Kubernetes по адресу <https://kubernetes.io/docs/concepts/services-networking/network-policies>.

### Защита данных

#### Держите секреты в секрете

Важно понимать, как чувствительные данные, такие как учетные данные и ключи, хранятся и используются в вашей инфраструктуре. Kubernetes хранит их в объекте "секрет" (Secret), который представляет собой небольшой объект, содержащий чувствительные данные, такие как пароль или токен.

Лучше монтировать секреты в контейнерах в виде только для чтения, а не передавать их как переменные окружения. Также секреты должны храниться отдельно от образа или пода, чтобы никто с доступом к образу не мог получить доступ к секретам. Особенно уязвимы сложные приложения, которые обрабатывают несколько процессов и имеют публичный доступ.

#### Шифрование секретов в покое

Всегда шифруйте свои резервные копии, используя тщательно проверенное решение для резервного копирования и шифрования, и рассмотрите возможность использования полного шифрования диска, если это возможно. Это важно, поскольку база данных etcd содержит любую информацию, доступную через API Kubernetes. Доступ к этой базе данных может предоставить злоумышленнику значительное представление о состоянии вашего кластера.

Kubernetes поддерживает шифрование в покое, функция, введенная в версии 1.7 и в beta-версии начиная с 1.13, которая шифрует ресурсы Secret в etcd и предотвращает доступ к содержимому этих секретов для сторон с доступом к резервным копиям etcd. Хотя эта функция в настоящее время находится на стадии beta, она предоставляет дополнительный уровень защиты, если резервные копии не зашифрованы или если злоумышленник получает доступ к etcd.

#### Альтернативы ресурсам Kubernetes Secret

Поскольку внешний менеджер секретов может хранить и управлять вашими секретами вместо хранения их в Kubernetes Secrets, вы можете рассмотреть эту альтернативу с точки зрения безопасности. Менеджер предоставляет ряд преимуществ по сравнению с использованием Kubernetes Secrets, включая возможность обработки секретов через несколько кластеров (или облаков) и возможность централизованного управления и ротации секретов.

Для получения дополнительной информации о секретах и их альтернативных вариантах, обратитесь к документации по адресу <https://kubernetes.io/docs/concepts/configuration/secret/>.

Также ознакомьтесь с [шпаргалкой по управлению секретами](Secrets_Management_Cheat_Sheet.md) для получения дополнительных деталей и лучших практик по управлению секретами.

#### Поиск раскрытых секретов

Мы настоятельно рекомендуем вам проверять материалы секретов, присутствующие в контейнере, в соответствии с принципом наименьших привилегий, и оценивать риск, связанный с компрометацией.

Помните, что инструменты с открытым исходным кодом, такие как [SecretScanner](https://github.com/deepfence/SecretScanner) и [ThreatMapper](https://github.com/deepfence/ThreatMapper), могут сканировать файловые системы контейнеров на наличие чувствительных ресурсов, таких как API токены, пароли и ключи. Такие ресурсы могут быть доступны любому пользователю, который имеет доступ к незашифрованной файловой системе контейнера, будь то во время сборки, в покое в реестре или резервной копии, или при запуске.

## РАЗДЕЛ 5: Лучшие практики безопасности Kubernetes: Фаза выполнения

Когда инфраструктура Kubernetes переходит в фазу выполнения, контейнеризированные приложения сталкиваются с множеством новых проблем безопасности. Необходимо обеспечить видимость вашего рабочего окружения, чтобы вы могли обнаруживать и реагировать на угрозы по мере их появления.

Если вы проактивно обеспечите безопасность ваших контейнеров и развертываний Kubernetes на этапах сборки и развертывания, вы сможете значительно снизить вероятность инцидентов безопасности в фазе выполнения и последующие усилия, необходимые для их устранения.

Во-первых, отслеживайте наиболее важные с точки зрения безопасности активности контейнеров, включая:

- Активность процессов
- Сетевые коммуникации между контейнеризированными сервисами
- Сетевые коммуникации между контейнеризированными сервисами и внешними клиентами и серверами

Обнаружение аномалий путем наблюдения за поведением контейнеров обычно легче в контейнерах, чем в виртуальных машинах, благодаря декларативной природе контейнеров и Kubernetes. Эти свойства позволяют легче инспектировать то, что вы развернули, и ожидаемую активность.

### Использование Pod Security Admission для предотвращения развертывания рискованных контейнеров/подов

Ранее рекомендуемая [Pod Security Policy](https://kubernetes.io/docs/concepts/policy/pod-security-policy/) устарела и была заменена [Pod Security Admission](https://kubernetes.io/docs/concepts/security/pod-security-admission/), новой функцией, которая позволяет применять политики безопасности к подам в кластере Kubernetes.

Рекомендуется использовать уровень `baseline` как минимальное требование безопасности для всех подов, чтобы обеспечить стандартный уровень безопасности по всему кластеру. Однако кластеры должны стремиться к применению уровня `restricted`, который следует лучшим практикам усиления безопасности подов.

Для получения дополнительной информации о настройке Pod Security Admission обратитесь к документации по адресу <https://kubernetes.io/docs/tasks/configure-pod-container/enforce-standards-admission-controller/>.

### Безопасность контейнерного времени выполнения

Если контейнеры защищены на этапе выполнения, команды безопасности имеют возможность обнаруживать и реагировать на угрозы и аномалии, пока контейнеры или рабочие нагрузки находятся в рабочем состоянии. Обычно это достигается путем перехвата системных вызовов низкого уровня и поиска событий, которые могут указывать на компрометацию. Некоторые примеры событий, которые должны вызвать предупреждение, включают:

- Выполнение командной оболочки внутри контейнера
- Монтирование контейнером чувствительного пути с хоста, такого как /proc
- Неожиданное чтение чувствительного файла в работающем контейнере, такого как /etc/shadow
- Установление исходящего сетевого соединения

Инструменты с открытым исходным кодом, такие как Falco от Sysdig, могут помочь операторам наладить безопасность контейнерного времени выполнения, предоставляя защитникам множество готовых обнаружений, а также возможность создавать собственные правила.

### Песочница для контейнеров

Когда среды выполнения контейнеров имеют возможность делать прямые вызовы к ядру хоста, ядро часто взаимодействует с аппаратным обеспечением и устройствами для обработки запроса. Хотя Cgroups и namespaces предоставляют контейнерам определенную степень изоляции, ядро все еще представляет собой значительную поверхность атаки. Когда защитникам приходится работать с многопользовательскими и крайне ненадежными кластерами, они часто добавляют дополнительный уровень песочницы, чтобы гарантировать отсутствие выхода контейнеров и эксплуатации ядра. Рассмотрим несколько технологий с открытым исходным кодом, которые помогают еще больше изолировать работающие контейнеры от ядра хоста:

- **Kata Containers**: Kata Containers — это проект с открытым исходным кодом, который использует упрощенные виртуальные машины для минимизации использования ресурсов и максимизации производительности, чтобы дополнительно изолировать контейнеры.
- **gVisor**: gVisor — это более легковесное ядро, чем виртуальная машина (даже упрощенная). Это собственное независимое ядро, написанное на Go, которое находится между контейнером и ядром хоста. Оно представляет собой сильную песочницу — gVisor поддерживает около 70% системных вызовов Linux из контейнера, но использует только около 20 системных вызовов к ядру хоста.
- **Firecracker**: Это суперлегковесная виртуальная машина, работающая в пользовательском пространстве. Поскольку она ограничена политиками seccomp, cgroup и namespace, системные вызовы сильно ограничены. Firecracker разработан с учетом безопасности, однако он может не поддерживать все развертывания Kubernetes или среды выполнения контейнеров.

### Предотвращение загрузки нежелательных модулей ядра

Поскольку ядро Linux автоматически загружает модули ядра с диска при необходимости в определенных обстоятельствах, таких как подключение аппаратного обеспечения или монтирование файловой системы, это может представлять собой значительную поверхность атаки. Особенно важно для Kubernetes то, что даже непривилегированные процессы могут вызвать загрузку определенных модулей ядра, связанных с сетевыми протоколами, просто создавая сокет соответствующего типа. Это может позволить злоумышленникам использовать уязвимости в модулях ядра, которые администратор предполагал, что не используются.

Чтобы предотвратить автоматическую загрузку конкретных модулей, вы можете удалить их с узла или добавить правила для их блокировки. На большинстве дистрибутивов Linux это можно сделать, создав файл, например `/etc/modprobe.d/kubernetes-blacklist.conf`, с таким содержимым:

```conf
# DCCP вряд ли будет нужен, имеет несколько серьезных
# уязвимостей и плохо поддерживается.
blacklist dccp

# SCTP не используется в большинстве кластеров Kubernetes и также имел
# уязвимости в прошлом.
blacklist sctp
```

Чтобы более обобщенно блокировать загрузку модулей, вы можете использовать модуль безопасности Linux (например, SELinux), чтобы полностью запретить контейнерам разрешение на модуль_request, что предотвратит загрузку модулей для контейнеров при любых обстоятельствах. (Подам все еще будет позволено использовать модули, которые были загружены вручную или модули, которые были загружены ядром от имени более привилегированного процесса).

### Сравнение и анализ различной активности в подах одного развертывания

Когда контейнеризированные приложения дублируются для обеспечения высокой доступности, отказоустойчивости или масштабируемости, эти реплики должны вести себя почти идентично. Если одна из реплик имеет значительные отклонения от остальных, защитники должны провести дополнительное расследование. Ваше средство безопасности Kubernetes должно быть интегрировано с другими внешними системами (электронная почта, PagerDuty, Slack, Google Cloud Security Command Center, SIEM [системы управления безопасностью и событиями] и т. д.) и использовать метки или аннотации развертывания для уведомления команды, ответственной за данное приложение, когда обнаруживается потенциальная угроза. Если вы выбрали коммерческого поставщика безопасности Kubernetes, он должен поддерживать широкий спектр интеграций с внешними инструментами.

### Мониторинг сетевого трафика для ограничения ненужного или небезопасного общения

Контейнеризированные приложения обычно активно используют сетевые ресурсы кластера, поэтому наблюдение за активным сетевым трафиком — хороший способ понять, как приложения взаимодействуют друг с другом и выявить неожиданное общение. Вы должны наблюдать за своим активным сетевым трафиком и сравнивать этот трафик с тем, что разрешено на основе ваших сетевых политик Kubernetes.

В то же время, сравнение активного трафика с разрешенным предоставляет вам ценную информацию о том, что не происходит, но разрешено. Используя эту информацию, вы можете дополнительно ужесточить свои сетевые политики, чтобы убрать избыточные соединения и сократить общую поверхность атаки.

Открытые проекты, такие как <https://github.com/kinvolk/inspektor-gadget> или <https://github.com/deepfence/PacketStreamer>, могут помочь в этом, а коммерческие решения по безопасности предлагают различные степени анализа сетевого трафика контейнеров.

### В случае компрометации масштабируйте подозрительные поды до нуля

Сдержите успешную атаку, используя родные средства Kubernetes для масштабирования подозрительных подов до нуля или завершения и последующего перезапуска экземпляров скомпрометированных приложений.

### Часто изменяйте учетные данные инфраструктуры

Чем короче срок действия секрета или учетной записи, тем сложнее злоумышленнику использовать эти данные. Устанавливайте короткие сроки действия сертификатов и автоматизируйте их ротацию. Используйте провайдера аутентификации, который может контролировать, как долго выданы токены действительны, и используйте короткие сроки действия, если это возможно. Если вы используете токены сервисных аккаунтов во внешних интеграциях, планируйте часто изменять эти токены. Например, после завершения фазы начальной настройки токен начальной настройки, использованный для настройки узлов, должен быть аннулирован или его авторизация должна быть удалена.

### Логирование

Kubernetes предоставляет кластерное логирование, которое позволяет записывать активность контейнеров в центральный лог-центр. Когда кластер создается, стандартный вывод и стандартный вывод ошибок каждого контейнера могут быть собраны с помощью агента Fluentd, работающего на каждом узле (в Google Stackdriver Logging или в Elasticsearch) и просматриваться с помощью Kibana.

#### Включение журналирования аудита

Журнал аудита — это бета-функция, которая записывает действия, выполняемые через API, для последующего анализа в случае компрометации. Рекомендуется включить журналирование аудита и архивировать файл аудита на безопасном сервере.

Убедитесь, что журналы мониторят аномальные или нежелательные вызовы API, особенно любые сбои авторизации (такие записи в журнале будут иметь сообщение о статусе "Forbidden"). Сбои авторизации могут означать, что злоумышленник пытается использовать украденные учетные данные.

Управляемые провайдеры Kubernetes, включая GKE, предоставляют доступ к этим данным в своей облачной консоли и могут позволить настроить оповещения о сбоях авторизации.

##### Журналы аудита

Журналы аудита могут быть полезны для соблюдения нормативных требований, так как они помогают ответить на вопросы о том, что произошло, кто что сделал и когда. Kubernetes предоставляет гибкое аудирование запросов к kube-apiserver на основе политик. Это помогает отслеживать все действия в хронологическом порядке.

Вот пример журнала аудита:

```json
{
  "kind":"Event",
  "apiVersion":"audit.k8s.io/v1beta1",
  "metadata":{ "creationTimestamp":"2019-08-22T12:00:00Z" },
  "level":"Metadata",
  "timestamp":"2019-08-22T12:00:00Z",
  "auditID":"23bc44ds-2452-242g-fsf2-4242fe3ggfes",
  "stage":"RequestReceived",
  "requestURI":"/api/v1/namespaces/default/persistentvolumeclaims",
  "verb":"list",
  "user": {
    "username":"user@example.org",
    "groups":[ "system:authenticated" ]
  },
  "sourceIPs":[ "172.12.56.1" ],
  "objectRef": {
    "resource":"persistentvolumeclaims",
    "namespace":"default",
    "apiVersion":"v1"
  },
  "requestReceivedTimestamp":"2019-08-22T12:00:00Z",
  "stageTimestamp":"2019-08-22T12:00:00Z"
}
```

#### Определение политик аудита

Политика аудита задает правила, которые определяют, какие события должны быть записаны и какие данные хранятся при включении события. Структура объекта политики аудита определена в группе API audit.k8s.io. Когда событие обрабатывается, оно сравнивается со списком правил по порядку. Первое совпадающее правило устанавливает "уровень аудита" события.

Известные уровни аудита:

- **None** — не записывать события, соответствующие этому правилу
- **Metadata** — записывать метаданные запроса (пользователь, запрос, ресурс, действие и т. д.), но не тело запроса или ответа
- **Request** — записывать метаданные события и тело запроса, но не тело ответа. Это не применимо к запросам, не связанным с ресурсами
- **RequestResponse** — записывать метаданные события, тело запроса и тело ответа. Это не применимо к запросам, не связанным с ресурсами

Вы можете передать файл с политикой в kube-apiserver с помощью флага `--audit-policy-file`. Если флаг опущен, события не записываются. Обратите внимание, что поле `rules` должно быть указано в файле политики аудита. Политика без (0) правил считается недопустимой.

#### Понимание логирования

Основная проблема с логированием в Kubernetes заключается в понимании того, какие логи генерируются и как их использовать. Начнем с общего обзора архитектуры логирования Kubernetes.

##### Логирование контейнеров

Первый слой логов, который можно собирать из кластера Kubernetes, — это логи, генерируемые вашими контейнеризированными приложениями. Самый простой метод логирования контейнеров — писать в потоки стандартного вывода (stdout) и стандартной ошибки (stderr).

Пример манифеста:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: example
spec:
  containers:
    - name: example
      image: busybox
      args: [/bin/sh, -c, 'while true; do echo $(date); sleep 1; done']
```

Чтобы применить манифест, выполните команду:

```bash
kubectl apply -f example.yaml
```

Чтобы посмотреть логи этого контейнера, выполните команду:

```bash
kubectl logs <container-name>
```

Для постоянного хранения логов контейнеров общепринятым подходом является запись логов в файл и использование контейнера sidecar. Как показано ниже в конфигурации пода, контейнер sidecar будет работать в том же поде, что и основной контейнер приложения, монтируя тот же том и отдельно обрабатывая логи.

Пример манифеста пода:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: example
spec:
  containers:
  - name: example
    image: busybox
    args:
    - /bin/sh
    - -c
    - >
      while true;
      do
        echo "$(date)\n" >> /var/log/example.log;
        sleep 1;
      done
    volumeMounts:
    - name: varlog
      mountPath: /var/log
  - name: sidecar
    image: busybox
    args: [/bin/sh, -c, 'tail -f /var/log/example.log']
    volumeMounts:
    - name: varlog
      mountPath: /var/log
  volumes:
  - name: varlog
    emptyDir: {}
```

##### Логирование на уровне узлов

Когда контейнер, работающий в Kubernetes, записывает свои логи в потоки stdout или stderr, контейнерный движок направляет их к драйверу логирования, установленному в конфигурации Kubernetes.

В большинстве случаев эти логи окажутся в директории `/var/log/containers` на вашем хосте. Docker поддерживает несколько драйверов логирования, но, к сожалению, настройка драйвера не поддерживается через API Kubernetes.

После завершения работы или перезапуска контейнера kubelet сохраняет логи на узле. Чтобы предотвратить переполнение хранилища хоста этими файлами, узел Kubernetes реализует механизм ротации логов. Когда контейнер удаляется с узла, все контейнеры с соответствующими лог-файлами также удаляются.

В зависимости от используемой операционной системы и дополнительных служб на вашем хосте, вам может понадобиться просмотреть дополнительные логи.

Например, логи systemd можно получить с помощью следующей команды:

```bash
journalctl -u
```

##### Логирование на уровне кластера

В самом кластере Kubernetes существует длинный список компонентов кластера, которые могут быть записаны в логи, а также дополнительные типы данных, которые могут быть использованы (события, журналы аудита). Вместе эти различные типы данных могут предоставить вам представление о том, как Kubernetes работает как система.

Некоторые из этих компонентов работают в контейнерах, а некоторые — на уровне операционной системы (в большинстве случаев это служба systemd). Службы systemd записывают логи в journald, а компоненты, работающие в контейнерах, записывают логи в директорию `/var/log`, если только контейнерный движок не настроен для потоковой передачи логов другим способом.

#### События

События Kubernetes могут указывать на любые изменения состояния ресурсов Kubernetes и ошибки, такие как превышение квоты ресурсов или зависшие поды, а также любые информационные сообщения.

Следующая команда возвращает все события в указанном пространстве имен:

`kubectl get events -n <namespace>`

Пример вывода:

```
NAMESPACE   LAST SEEN   TYPE    REASON     OBJECT                                         MESSAGE
kube-system  8m22s      Normal  Scheduled  pod/metrics-server-66dbbb67db-lh865            Successfully assigned kube-system/metrics-server-66dbbb67db-lh865 to aks-agentpool-42213468-1
kube-system  8m14s      Normal  Pulling    pod/metrics-server-66dbbb67db-lh865            Pulling image "aksrepos.azurecr.io/mirror/metrics-server-amd64:v0.2.1"
kube-system  7m58s      Normal  Pulled     pod/metrics-server-66dbbb67db-lh865            Successfully pulled image "aksrepos.azurecr.io/mirror/metrics-server-amd64:v0.2.1"
kube-system  7m57s      Normal  Created    pod/metrics-server-66dbbb67db-lh865            Created container metrics-server
kube-system  7m57s      Normal  Started    pod/metrics-server-66dbbb67db-lh865            Started container metrics-server
kube-system  8m23s      Normal  SuccessfulCreate replicaset/metrics-server-66dbbb67db    Created pod: metrics-server-66dbbb67db-lh865
```

Следующая команда покажет последние события для конкретного ресурса Kubernetes:

`kubectl describe pod <pod-name>`

```
Events:
  Type    Reason     Age   From                               Message
  ----    ------     ----  ----                               -------
  Normal  Scheduled  14m   default-scheduler                  Successfully assigned kube-system/coredns-7b54b5b97c-dpll7 to aks-agentpool-42213468-1
  Normal  Pulled     13m   kubelet, aks-agentpool-42213468-1  Container image "aksrepos.azurecr.io/mirror/coredns:1.3.1" already present on machine
  Normal  Created    13m   kubelet, aks-agentpool-42213468-1  Created container coredns
  Normal  Started    13m   kubelet, aks-agentpool-42213468-1  Started container coredns
```

## Раздел 5: Итоговые мысли

### Внедрите безопасность на как можно более ранних этапах жизненного цикла контейнера

Необходимо интегрировать безопасность на ранних этапах жизненного цикла контейнера и обеспечить согласованность и общие цели между командами безопасности и DevOps. Безопасность может (и должна) быть активатором, позволяющим вашим разработчикам и DevOps-командам уверенно создавать и развертывать приложения, готовые к масштабированию, стабильности и безопасности.

### Используйте встроенные средства безопасности Kubernetes для снижения операционных рисков

Используйте нативные средства безопасности, встроенные в Kubernetes, когда это возможно, чтобы применять политики безопасности, чтобы ваши средства безопасности не конфликтовали с оркестратором. Вместо использования стороннего прокси или промежуточного слоя для обеспечения сетевой сегментации, вы можете использовать сетевые политики Kubernetes для обеспечения безопасного сетевого взаимодействия.

### Используйте контекст, предоставляемый Kubernetes, для приоритизации усилий по устранению проблем

Имейте в виду, что ручная оценка инцидентов безопасности и нарушений политики требует много времени в разветвленных средах Kubernetes.

Например, развертывание, содержащее уязвимость с уровнем тяжести 7 или выше, должно быть поднято в приоритете устранения, если это развертывание содержит привилегированные контейнеры и открыто в Интернет, но опущено, если оно находится в тестовой среде и поддерживает не критическое приложение.

---

![Архитектура Kubernetes](../assets/Kubernetes_Architecture.png)

## Источники

Документация управляющей плоскости - <https://kubernetes.io>

1. Лучшие практики безопасности Kubernetes, которые должен соблюдать каждый - <https://www.cncf.io/blog/2019/01/14/9-kubernetes-security-best-practices-everyone-must-follow>
2. Обеспечение безопасности кластера - <https://kubernetes.io/docs/tasks/administer-cluster/securing-a-cluster>
3. Лучшие практики безопасности для развертывания Kubernetes - <https://kubernetes.io/blog/2016/08/security-best-practices-kubernetes-deployment>
4. Лучшие практики безопасности Kubernetes - <https://phoenixnap.com/kb/kubernetes-security-best-practices>
5. Kubernetes Security 101: Риски и 29 лучших практик - <https://www.stackrox.com/post/2020/05/kubernetes-security-101>
6. 15 лучших практик безопасности Kubernetes для защиты вашего кластера - <https://www.mobilise.cloud/15-kubernetes-security-best-practice-to-secure-your-cluster>
7. Полное руководство по безопасности Kubernetes - <https://neuvector.com/container-security/kubernetes-security-guide>
8. Руководство хакера по безопасности Kubernetes - <https://techbeacon.com/enterprise-it/hackers-guide-kubernetes-security>
9. 11 способов (не) быть взломанным - <https://kubernetes.io/blog/2018/07/18/11-ways-not-to-get-hacked>
10. 12 лучших практик конфигурации Kubernetes - <https://www.stackrox.com/post/2019/09/12-kubernetes-configuration-best-practices/#6-securely-configure-the-kubernetes-api-server>
11. Практическое руководство по логированию Kubernetes - <https://logz.io/blog/a-practical-guide-to-kubernetes-logging>
12. Веб-интерфейс Kubernetes (Dashboard) - <https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard>
13. Облачные ресурсы Tesla взломаны для запуска вредоносного ПО для майнинга криптовалюты - <https://arstechnica.com/information-technology/2018/02/tesla-cloud-resources-are-hacked-to-run-cryptocurrency-mining-malware>
14. OPEN POLICY AGENT: КЛАУД-НАТИВНОЕ АВТОРИЗАЦИЯ - <https://blog.styra.com/blog/open-policy-agent-authorization-for-the-cloud>
15. Введение в политику как код: Open Policy Agent (OPA) - <https://www.magalix.com/blog/introducing-policy-as-code-the-open-policy-agent-opa>
16. Что предоставляет сетевой сервис - <https://aspenmesh.io/wp-content/uploads/2019/10/AspenMesh_CompleteGuide.pdf>
17. Три технических преимущества сетевых сервисов и их операционные ограничения, Часть 1 - <https://glasnostic.com/blog/service-mesh-istio-limits-and-benefits-part-1>
18. Open Policy Agent: что такое OPA и как он работает (Примеры) - <https://spacelift.io/blog/what-is-open-policy-agent-and-how-it-works>
19. Отправка метрик Kubernetes в Kibana и Elasticsearch - <https://logit.io/sources/configure/kubernetes/>
20. Контрольный список безопасности Kubernetes - <https://kubernetes.io/docs/concepts/security/security-checklist/>