# Шпаргалка по предотвращению инъекций

## Введение

Эта статья сосредоточена на предоставлении ясных, простых и практических рекомендаций по предотвращению всех видов уязвимостей инъекций в ваших приложениях. Атаки инъекций, особенно [SQL-инъекции](https://owasp.org/www-community/attacks/SQL_Injection), к сожалению, очень распространены.

Доступность приложения является важным фактором в защите и предотвращении уязвимостей инъекций. Только меньшинство всех приложений в компании/предприятии разрабатывается внутри компании, тогда как большинство приложений поступает из внешних источников. Открытые приложения по крайней мере дают возможность исправить проблемы, но закрытые приложения требуют другого подхода к уязвимостям инъекций.

Уязвимости инъекций возникают, когда приложение отправляет ненадежные данные интерпретатору. Уязвимости инъекций очень распространены, особенно в старом коде, часто встречаются в SQL-запросах, LDAP-запросах, XPath-запросах, системных командах, аргументах программы и т.д. Уязвимости инъекций легко обнаружить при проверке кода, но сложнее — при тестировании. Сканеры и фуззеры могут помочь злоумышленникам найти их.

В зависимости от доступности необходимо предпринимать различные действия для их исправления. Всегда лучше исправить проблему в исходном коде или даже перепроектировать некоторые части приложений. Но если исходный код недоступен или исправление старого ПО экономически нецелесообразно, то имеет смысл использовать виртуальное патчирование.

## Типы приложений

В компании обычно можно выделить три класса приложений. Эти три типа необходимы для определения действий, которые нужно предпринять для предотвращения/исправления уязвимостей инъекций.

### A1: Новое приложение

Новое веб-приложение, находящееся на стадии проектирования или в ранней стадии разработки.

### A2: Продуктивное открытое приложение

Уже продуктивное приложение, которое можно легко адаптировать. Приложение типа Model-View-Controller (MVC) является лишь одним примером легко доступной архитектуры приложения.

### A3: Продуктивное закрытое приложение

Продуктивное приложение, которое нельзя или трудно изменить.

## Формы инъекций

Существует несколько форм инъекций, нацеленных на различные технологии, включая SQL-запросы, LDAP-запросы, XPath-запросы и системные команды.

### Языки запросов

Самая известная форма инъекции — SQL-инъекция, при которой злоумышленник может изменять существующие запросы к базе данных. Для получения дополнительной информации см. [Шпаргалку по предотвращению SQL-инъекций](SQL_Injection_Prevention_Cheat_Sheet.md).

Однако также LDAP, SOAP, XPath и REST-запросы могут быть подвержены атакам инъекций, что позволяет получать данные или обойти контроль.

#### SQL-инъекция

Атака SQL-инъекции заключается во вставке или "инъекции" частичного или полного SQL-запроса через ввод данных или передаваемых с клиента (браузера) в веб-приложение.

Успешная атака SQL-инъекции может читать конфиденциальные данные из базы данных, изменять данные базы данных (вставка/обновление/удаление), выполнять административные операции с базой данных (например, выключение СУБД), восстанавливать содержимое определенного файла, существующего на файловой системе СУБД, или записывать файлы в файловую систему, а в некоторых случаях выдавать команды операционной системе. Атаки SQL-инъекций являются типом атак инъекций, при которых SQL-команды внедряются в данные на уровне ввода, чтобы повлиять на выполнение заранее определенных SQL-команд.

Атаки SQL-инъекций можно разделить на следующие три класса:

- **Inband (внутренний):** данные извлекаются с помощью того же канала, который используется для инъекции SQL-кода. Это самый прямой вид атаки, при котором извлеченные данные отображаются непосредственно на веб-странице приложения.
- **Out-of-band (внешний):** данные извлекаются с помощью другого канала (например, создается и отправляется по электронной почте отчет с результатами запроса).
- **Inferential или Blind (инференциальный или слепой):** фактический перенос данных отсутствует, но тестер может восстановить информацию, отправляя определенные запросы и наблюдая за поведением сервера БД.

##### Как тестировать проблему

###### Во время ревизии кода

Пожалуйста, проверьте, что запросы к базе данных не выполняются через динамические запросы.

Если используются динамические запросы, убедитесь, что данные очищены перед использованием в запросе.

Аудиторы всегда должны искать использования функций sp_execute, execute или exec в хранимых процедурах SQL Server. Аналогичные рекомендации по аудиту применимы и к другим функциям для других поставщиков.

###### Автоматизированное использование

Многие из ситуаций и техник ниже могут быть выполнены автоматическим способом с помощью некоторых инструментов. В этой статье тестер может найти информацию о том, как выполнить автоматизированный аудит с помощью [SQLMap](https://wiki.owasp.org/index.php/Automated_Audit_using_SQLMap).

Аналогично, правила статического анализа кода могут обнаруживать неочищенные пользовательские вводы, которые могут изменить SQL-запрос.

###### Инъекция в хранимую процедуру

При использовании динамического SQL в хранимой процедуре приложение должно правильно очищать пользовательский ввод, чтобы устранить риск инъекции кода. Если ввод не очищается, пользователь может ввести вредоносный SQL-код, который будет выполнен в хранимой процедуре.

###### Техника эксплуатации задержки времени

Техника эксплуатации задержки времени очень полезна, когда тестер сталкивается с ситуацией Blind SQL Injection, в которой результат операции неизвестен. Эта техника заключается в отправке инъекционного запроса и, если условие истинно, тестер может отслеживать время ответа сервера. Если есть задержка, тестер может предположить, что результат условного запроса истинный. Эта техника эксплуатации может отличаться от СУБД к СУБД (см. раздел, специфичный для СУБД).

```text
http://www.example.com/product.php?id=10 AND IF(version() like '5%', sleep(10), 'false'))--
```

В этом примере тестер проверяет, является ли версия MySQL 5.x или нет, заставляя сервер задерживать ответ на 10 секунд. Тестер может увеличить время задержки и отслеживать ответы. Также не всегда нужно ждать ответа. Иногда можно установить очень высокое значение (например, 100) и отменить запрос через несколько секунд.

###### Техника внешней эксплуатации

Эта техника очень полезна, когда тестер сталкивается с ситуацией Blind SQL Injection, при которой результат операции неизвестен. Техника состоит в использовании функций СУБД для выполнения внешнего соединения и передачи результатов инъекционного запроса в запрос к серверу тестера. Как и в случае с техниками на основе ошибок, каждая СУБД имеет свои функции. Проверьте раздел, специфичный для СУБД.

##### Средства защиты

###### Опция защиты 1: Подготовленные выражения (с параметризованными запросами)

Подготовленные выражения гарантируют, что злоумышленник не сможет изменить намерение запроса, даже если SQL-команды вставлены злоумышленником. В приведенном ниже безопасном примере, если злоумышленник введет userID как `tom' or '1'='1`, параметризованный запрос не будет уязвим и вместо этого будет искать имя пользователя, которое буквально соответствует всей строке `tom' or '1'='1`.

###### Опция защиты 2: Хранимые процедуры

Разница между подготовленными выражениями и хранимыми процедурами заключается в том, что SQL-код для хранимой процедуры определяется и хранится в самой базе данных, а затем вызывается из приложения.

Обе эти техники имеют одинаковую эффективность в предотвращении SQL-инъекций, поэтому вашей организации следует выбрать, какой подход наиболее подходит для вас. Хранимые процедуры не всегда защищены от SQL-инъекций. Однако некоторые стандартные конструкции программирования хранимых процедур имеют тот же эффект, что и использование параметризованных запросов, если они реализованы безопасно, что является нормой для большинства языков программирования хранимых процедур.

*Примечание:* 'Реализовано безопасно' означает, что хранимая процедура не включает небезопасное динамическое создание SQL.

###### Опция защиты 3: Проверка входных данных по белому списку

Некоторые части SQL-запросов не являются допустимыми местами для использования переменных привязки, такие как имена таблиц или столбцов и индикатор порядка сортировки (ASC или DESC). В таких ситуациях проверка входных данных или переработка запроса является наиболее подходящей защитой. Для имен таблиц или столбцов идеальным вариантом является получение этих значений из кода, а не из параметров пользователя.

Если значения параметров пользователя используются для задания различных имен таблиц и столбцов, то значения параметров должны быть сопоставлены с законными/ожидаемыми именами таблиц или столбцов, чтобы гарантировать, что непроверенные входные данные пользователя не окажутся в запросе. Обратите внимание, что это симптом плохого дизайна, и полная переработка должна быть рассмотрена, если позволяет время.

###### Опция защиты 4: Экранирование всех данных, предоставляемых пользователем

Эта техника должна использоваться только в крайнем случае, когда ни одна из вышеупомянутых не применима. Проверка входных данных, вероятно, является лучшим выбором, так как эта методология является менее надежной по сравнению с другими методами защиты, и мы не можем гарантировать, что она предотвратит все SQL-инъекции в любых ситуациях.

Эта техника заключается в экранировании пользовательского ввода перед тем, как включить его в запрос. Обычно рекомендуется использовать ее только для старого кода, когда реализация проверки входных данных не является экономически целесообразной.

##### Пример кода - Java

###### Пример безопасного подготовленного запроса в Java

В следующем примере кода используется `PreparedStatement`, реализация параметризованного запроса в Java, для выполнения того же запроса к базе данных.

```java
// Это тоже следует проверить
String custname = request.getParameter("customerName");
// Выполните проверку ввода для обнаружения атак
String query = "SELECT account_balance FROM user_data WHERE user_name = ?";
PreparedStatement pstmt = connection.prepareStatement(query);
pstmt.setString(1, custname);
ResultSet results = pstmt.executeQuery();
```

В этом примере показаны примеры на Java, но практически все другие языки, включая Cold Fusion и Classic ASP, поддерживают интерфейсы параметризованных запросов.

###### Пример безопасной хранимой процедуры в Java

В следующем примере кода используется `CallableStatement`, реализация интерфейса хранимой процедуры в Java, для выполнения того же запроса к базе данных. Хранимая процедура `sp_getAccountBalance` должна быть предварительно определена в базе данных и реализовывать ту же функциональность, что и запрос, указанный выше.

```java
// Это тоже следует проверить
String custname = request.getParameter("customerName");
try {
 CallableStatement cs = connection.prepareCall("{call sp_getAccountBalance(?)}");
 cs.setString(1, custname);
 ResultSet results = cs.executeQuery();
 // Обработка набора результатов...
} catch (SQLException se) {
 // Логирование и обработка ошибок...
}
```

#### LDAP Injection

LDAP Injection — это атака, используемая для эксплуатации веб-приложений, которые строят LDAP-запросы на основе ввода пользователя. Когда приложение не правильно обрабатывает ввод пользователя, это позволяет изменять LDAP-запросы с помощью методов, аналогичных [SQL Injection](https://owasp.org/www-community/attacks/SQL_Injection). Атаки LDAP-инъекции могут привести к предоставлению разрешений несанкционированным запросам и модификации содержимого внутри LDAP-дерева. Для получения дополнительной информации об атаках LDAP-инъекций, посетите [LDAP Injection](https://owasp.org/www-community/attacks/LDAP_Injection).

Атаки [LDAP Injection](https://owasp.org/www-community/attacks/LDAP_Injection) распространены по двум причинам:

1. Отсутствие более безопасных интерфейсов параметризованных LDAP-запросов.
2. Широкое использование LDAP для аутентификации пользователей в системах.

##### Как протестировать проблему

###### Во время обзора кода

Проверьте, чтобы запросы к LDAP экранировали специальные символы. См. [здесь](LDAP_Injection_Prevention_Cheat_Sheet.md#defense-option-1-escape-all-variables-using-the-right-ldap-encoding-function).

###### Автоматизированная эксплуатация

Модуль сканирования инструментов, таких как OWASP [ZAP](https://www.zaproxy.org/), имеет модуль для обнаружения проблем LDAP-инъекции.

##### Устранение

###### Экранируйте все переменные с использованием правильной функции кодирования LDAP

Основной способ хранения имен в LDAP основывается на DN ([distinguished name](https://ldapwiki.com/wiki/Distinguished%20Names)). Можно думать об этом как о уникальном идентификаторе. Эти имена иногда используются для доступа к ресурсам, таким как имя пользователя.

DN может выглядеть следующим образом:

```text
cn=Richard Feynman, ou=Physics Department, dc=Caltech, dc=edu
```

или

```text
uid=inewton, ou=Mathematics Department, dc=Cambridge, dc=com
```

Существуют определенные символы, которые считаются специальными в DN. Полный список таков: `\ # + < > , ; " =` и пробелы в начале или в конце.

Каждый DN указывает на один элемент, который можно считать аналогом строки в RDBMS. Для каждого элемента будут 1 или несколько атрибутов, аналогичных столбцам в RDBMS. Если вы хотите искать пользователей в LDAP по определенным атрибутам, вы можете использовать фильтры поиска. В фильтре поиска можно использовать стандартную булеву логику для получения списка пользователей, соответствующих произвольному условию. Фильтры поиска записываются в польской нотации, также известной как префиксная нотация.

Пример:

```text
(&(ou=Physics)(| (manager=cn=Freeman Dyson,ou=Physics,dc=Caltech,dc=edu)
(manager=cn=Albert Einstein,ou=Physics,dc=Princeton,dc=edu)  ))
```

При построении LDAP-запросов в коде приложения ВЫ ДОЛЖНЫ экранировать любые ненадежные данные, которые добавляются в LDAP-запрос. Существует два вида экранирования LDAP: кодирование для LDAP поиска и кодирование для LDAP DN (distinguished name). Правильное экранирование зависит от того, очищаете ли вы ввод для фильтра поиска или используете DN как идентификатор, подобный имени пользователя, для доступа к какому-либо ресурсу.

##### Пример кода — Java

###### Безопасный пример экранирования LDAP в Java

```java
public String escapeDN (String name) {
    // Согласно RFC 2253 и символу / для JNDI
    final char[] META_CHARS = {'+', '"', '<', '>', ';', '/'};
    String escapedStr = new String(name);
    // Обратная косая черта является как символом экранирования Java, так и LDAP,
    // поэтому сначала экранируем ее
    escapedStr = escapedStr.replaceAll("\\\\\\\\", "\\\\\\\\\\");
    // Позиционные символы - см. RFC 2253
    escapedStr = escapedStr.replaceAll("\\^#", "\\\\\\\\#");
    escapedStr = escapedStr.replaceAll("\\^ | $", "\\\\\\\\ ");
    for (int i = 0; i < META_CHARS.length; i++) {
        escapedStr = escapedStr.replaceAll("\\\\" + META_CHARS[i], "\\\\\\\\" + META_CHARS[i]);
    }
    return escapedStr;
}
```

Обратите внимание, что символ обратной косой черты является как литералом строки Java, так и символом экранирования регулярных выражений.

```java
public String escapeSearchFilter (String filter) {
    // Согласно RFC 2254
    String escapedStr = new String(filter);
    escapedStr = escapedStr.replaceAll("\\\\\\\\", "\\\\\\\\\\5c");
    escapedStr = escapedStr.replaceAll("\\\\*", "\\\\\\\\\\2a");
    escapedStr = escapedStr.replaceAll("\\\\(", "\\\\\\\\\\28");
    escapedStr = escapedStr.replaceAll("\\\\)", "\\\\\\\\\\29");
    escapedStr = escapedStr.replaceAll("\\\\" + Character.toString('\\u0000'), "\\\\\\\\00");
    return escapedStr;
}
```

#### XPath Injection

TODO

### Языки сценариев

Все языки сценариев, используемые в веб-приложениях, имеют форму вызова `eval`, которая получает код во время выполнения и выполняет его. Если код создается с использованием непроверенного и неэкранированного пользовательского ввода, может возникнуть внедрение кода, что позволяет злоумышленнику подменить логику приложения и в конечном итоге получить локальный доступ.

Каждый раз, когда используется язык сценариев, фактическая реализация "высшего" языка сценариев выполняется с использованием "нижнего" языка, такого как C. Если язык сценариев имеет недостаток в коде обработки данных, могут быть использованы векторы атаки, такие как '[Null Byte Injection](http://projects.webappsec.org/w/page/13246949/Null%20Byte%20Injection)', чтобы получить доступ к другим областям памяти, что приведет к успешной атаке.

### Команды операционной системы

Внедрение команд операционной системы — это техника, используемая через веб-интерфейс для выполнения команд ОС на веб-сервере. Пользователь передает команды операционной системы через веб-интерфейс для их выполнения.

Любой веб-интерфейс, который не очищен должным образом, подвержен этой уязвимости. С возможностью выполнения команд ОС пользователь может загружать вредоносные программы или даже получить пароли. Внедрение команд ОС можно предотвратить, если безопасность будет приоритетом при проектировании и разработке приложений.

#### Как проверить проблему

##### Во время кода

Проверьте, вызываются ли методы выполнения команд и принимаются ли непроверенные пользовательские данные в качестве данных для этих команд.

Кроме того, добавление точки с запятой в конец URL-параметра запроса, за которым следует команда операционной системы, выполнит эту команду. `%3B` является закодированным URL и декодируется в точку с запятой. Это связано с тем, что `;` интерпретируется как разделитель команд.

Пример: `http://sensitive/something.php?dir=%3Bcat%20/etc/passwd`

Если приложение отвечает выводом файла `/etc/passwd`, значит, атака прошла успешно. Многие сканеры веб-приложений можно использовать для проверки этой атаки, так как они внедряют различные вариации командных инъекций и тестируют ответ.

Аналогично, инструменты статического анализа кода проверяют поток данных непроверенного пользовательского ввода в веб-приложение и проверяют, передаются ли данные в опасный метод, который выполняет пользовательский ввод в качестве команды.

#### Устранение

Если вызов системной команды с пользовательским вводом считается неизбежным, следует использовать два уровня защиты в программном обеспечении для предотвращения атак:

1. **Параметризация** - Если это возможно, используйте структурированные механизмы, которые автоматически обеспечивают разделение между данными и командой. Эти механизмы могут помочь обеспечить соответствующее экранирование и кодирование.

2. **Проверка ввода** - Значения команд и соответствующих аргументов должны быть проверены. Существуют разные уровни проверки для самой команды и её аргументов:
    - Что касается **команд**, их необходимо проверять по списку разрешённых команд.
    - Что касается **аргументов** для этих команд, их следует проверять с использованием следующих опций:
        - Проверка ввода с разрешённым списком - где явно определён список допустимых аргументов.
        - Регулярное выражение с разрешённым списком - где явно определён список допустимых символов и максимальная длина строки. Убедитесь, что метасимволы, такие как `& | ; $ > < \` \ !` и пробелы, не входят в регулярное выражение. Например, следующее регулярное выражение разрешает только строчные буквы и цифры и не содержит метасимволов. Длина также ограничена 3-10 символами:

`^[a-z0-9]{3,10}$`

#### Пример кода - Java

##### Неправильное использование

```java
ProcessBuilder b = new ProcessBuilder("C:\\DoStuff.exe -arg1 -arg2");
```

В этом примере команда вместе с аргументами передаётся в виде одной строки, что упрощает манипуляции с этим выражением и внедрение вредоносных строк.

##### Правильное использование

Вот пример, который запускает процесс с изменённым рабочим каталогом. Команда и каждый аргумент передаются отдельно, что упрощает проверку каждого элемента и снижает риск вставки вредоносных строк.

```java
ProcessBuilder pb = new ProcessBuilder("TrustedCmd", "TrustedArg1", "TrustedArg2");
Map<String, String> env = pb.environment();
pb.directory(new File("TrustedDir"));
Process p = pb.start();
```

### Сетевые протоколы

Веб-приложения часто общаются с сетевыми демонами (например, SMTP, IMAP, FTP), где пользовательский ввод становится частью потока передачи данных. В таких случаях можно внедрить команды для злоупотребления установленной сессией.

## Правила предотвращения инъекций

### Правило \#1 (Проводите правильную проверку ввода)

Проводите правильную проверку ввода. Рекомендуется также использование положительной проверки или списка разрешённых символов с соответствующей канонизацией, но это **не является полной защитой**, поскольку многие приложения требуют специальных символов во входных данных.

### Правило \#2 (Используйте безопасный API)

Предпочтительный вариант — использовать безопасный API, который полностью избегает использования интерпретатора или предоставляет параметризованный интерфейс. Будьте осторожны с API, такими как хранимые процедуры, которые параметризованы, но всё же могут вводить инъекции "под капотом".

### Правило \#3 (Контекстуально экранируйте пользовательские данные)

Если параметризованный API недоступен, необходимо тщательно экранировать специальные символы, используя синтаксис экранирования для конкретного интерпретатора.

## Другие читы по предотвращению инъекций

[Шпаргалка по предотвращению SQL-инъекций](SQL_Injection_Prevention_Cheat_Sheet.md)

[Шпаргалка по защите от инъекций команд ОС](OS_Command_Injection_Defense_Cheat_Sheet.md)

[Шпаргалка по предотвращению LDAP-инъекций](LDAP_Injection_Prevention_Cheat_Sheet.md)

[Шпаргалка по предотвращению инъекций в Java](Injection_Prevention_in_Java_Cheat_Sheet.md)
