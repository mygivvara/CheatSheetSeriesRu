
# Шпаргалка по предотвращению межcайтового скриптинга (XSS)

## Введение

Эта шпаргалка поможет разработчикам предотвратить появление XSS-уязвимостей.

Межсайтовый скриптинг (XSS) - это неправильное название. Изначально этот термин был образован от ранних версий атак, которые в основном были направлены на кражу данных через сайт. С тех пор термин расширился и стал включать в себя внедрение практически любого контента. XSS-атаки очень серьезны и могут привести к выдаче себя за пользователя, наблюдению за его поведением, загрузке внешнего контента, краже конфиденциальных данных и т. д.

**Эта шпаргалка содержит методы предотвращения или ограничения воздействия XSS. Поскольку ни одна техника не решает проблему XSS, для предотвращения XSS необходимо использовать правильную комбинацию защитных техник.**

## Безопасность фреймворков

К счастью, в приложениях, построенных на современных веб-фреймворках, XSS-баги встречаются реже, поскольку эти фреймворки ориентируют разработчиков на хорошие методы обеспечения безопасности и помогают смягчить последствия XSS за счет использования шаблонов, автозавершения и т. д. Однако разработчики должны знать, что при небезопасном использовании фреймворков могут возникнуть такие проблемы, как:

- Люки _эскейпа_, которые фреймворки используют для прямого манипулирования DOM
- `dangerouslySetInnerHTML` в React без санитации HTML 
- React не может обрабатывать URL `javascript:` или `data:` без специализированной валидации
- Функции Angular `bypassSecurityTrustAs*`
- Функция Lit's `unsafeHTML`
- Атрибут `inner-h-t-m-l` и функция `htmlLiteral` в полимере
- Шаблонная инъекция
- Устаревшие плагины или компоненты фреймворка
- и многое другое

Если вы используете современный веб-фреймворк, вам необходимо знать, как он защищает от XSS и где в нем есть пробелы. Бывают случаи, когда вам нужно сделать что-то за пределами защиты, предоставляемой вашим фреймворком, а это значит, что кодирование вывода и санитация HTML могут оказаться критически важными. OWASP будет выпускать специальные шпаргалки для фреймворков React, Vue и Angular.

## Философия защиты от XSS

Чтобы XSS-атака была успешной, злоумышленник должен иметь возможность вставить и выполнить вредоносный контент на веб-странице. Таким образом, все переменные в веб-приложении должны быть защищены. Обеспечение того, что **все переменные** проходят проверку и затем экранируются или санитируются, известно как **совершенная устойчивость к инъекциям**. Любая переменная, которая не проходит через этот процесс, является потенциальным слабым местом. Фреймворки позволяют легко обеспечить правильную проверку переменных и их экранирование или санацию.

Однако ни один фреймворк не является идеальным, и в таких популярных фреймворках, как React и Angular, все еще существуют пробелы в безопасности. Кодирование выходных данных и дезинфекция HTML помогают устранить эти пробелы.

## Выходная кодировка

Если вам нужно безопасно отобразить данные в точности так, как их вводит пользователь, рекомендуется использовать кодировку вывода. Переменные не должны интерпретироваться как код вместо текста. В этом разделе рассматривается каждая форма кодировки вывода, где ее следует использовать и когда не следует использовать динамические переменные вообще.

Во-первых, если вы хотите отображать данные в том виде, в котором их ввел пользователь, начните с защиты от кодировки, установленной в вашем фреймворке по умолчанию. Функции автоматического кодирования и экранирования встроены в большинство фреймворков.

Если вы не используете фреймворк или вам нужно закрыть пробелы в фреймворке, то вам следует использовать библиотеку кодирования вывода. Каждая переменная, используемая в пользовательском интерфейсе, должна быть передана через функцию кодирования вывода. Список библиотек кодирования вывода приведен в приложении.

Существует множество различных методов кодирования вывода, поскольку браузеры по-разному анализируют HTML, JS, URL и CSS. Использование неправильного метода кодирования может привести к появлению слабых мест или нарушить функциональность вашего приложения.

### Выходная кодировка для "HTML-контекстов"

"HTML-контекст" означает вставку переменной между двумя основными HTML-тегами, такими как `<div>` или `<b>`. Например:

```HTML
<div> $varUnsafe </div>
```

Злоумышленник может изменить данные, которые отображаются как `$varUnsafe`. Это может привести к добавлению атаки на веб-страницу. Например:

```HTML
<div> <script>alert`1`</script> </div> // Пример атаки
```

Чтобы безопасно добавить переменную в HTML-контекст веб-шаблона, используйте для нее кодировку сущности HTML.

Вот несколько примеров кодированных значений для определенных символов:

Если вы используете JavaScript для записи в HTML, обратите внимание на атрибут `.textContent`. Он является **Safe Sink** и автоматически кодирует HTML Entity Encode.

```HTML
& &amp;
< &lt;
> &gt;
" &quot;
' &#x27;
```

### Выходная кодировка для "Контекстов атрибутов HTML"

"Контексты атрибутов HTML" возникают, когда переменная помещается в значение атрибута HTML. Вы можете захотеть сделать это, чтобы изменить гиперссылку, скрыть элемент, добавить alt-текст для изображения или изменить встроенные стили CSS. К переменным, помещаемым в большинство атрибутов HTML, следует применять кодировку атрибутов HTML. Список безопасных атрибутов HTML приведен в разделе **Безопасные атрибуты**.

```HTML
<div attr="$varUnsafe">.
<div attr="*x" onblur="alert(1)*"> // Пример атаки
```

**Очень важно использовать кавычки, такие как `"` или `'`, чтобы окружать переменные.** Кавычки затрудняют изменение контекста, в котором работает переменная, что помогает предотвратить XSS. Кроме того, кавычки значительно сокращают набор символов, которые необходимо кодировать, что делает ваше приложение более надежным, а кодировку - более простой в реализации.

Если вы пишете в HTML-атрибут с помощью JavaScript, обратите внимание на методы `.setAttribute` и `[attribute]`, потому что они автоматически кодируют HTML-атрибут. Это **Safe Sinks**, пока имя атрибута жестко закодировано и является безобидным, например `id` или `class`. Вообще, атрибуты, которые принимают JavaScript, такие как `onClick`, **НЕ безопасны** для использования с ненадежными значениями атрибутов.

### Выходная кодировка для "Контекстов JavaScript"

Под "контекстами JavaScript" понимается ситуация, когда переменные помещаются во встроенный JavaScript, а затем встраиваются в HTML-документ. Такая ситуация обычно возникает в программах, которые активно используют пользовательский JavaScript, встраиваемый в веб-страницы.

Однако единственное "безопасное" место для размещения переменных в JavaScript - это "значение данных в кавычках". Все остальные контексты небезопасны, и в них не следует размещать переменные данные.

Примеры "Приведенных значений данных"

```HTML
<script>alert('$varUnsafe')</script>
<script>x='$varUnsafe'</script>
<div onmouseover="'$varUnsafe'"</div>
```

Перекодируйте все символы, используя формат `\xHH`. Библиотеки кодирования часто содержат функцию `EncodeForJavaScript` или подобную ей для поддержки этой функции.

См. в [OWASP Java Encoder: примеры кодирования JavaScript](https://owasp.org/www-project-java-encoder/) примеры правильного использования JavaScript, требующего минимального кодирования.

Для JSON убедитесь, что заголовок `Content-Type` имеет значение `application/json`, а не `text/html`, чтобы предотвратить XSS.

### Выходная кодировка для "Контекстов CSS"

Под "контекстами CSS" понимаются переменные, помещаемые во встроенный CSS, который часто используется разработчиками, когда они хотят, чтобы пользователи настраивали внешний вид и восприятие веб-страниц. Поскольку CSS обладает удивительными возможностями, его используют для многих типов атак. **Переменные следует помещать только в значение свойства CSS. Другие "контексты CSS" небезопасны, и вы не должны помещать в них переменные данные.**

```HTML
<style> selector { property : $varUnsafe; } </style>.
<style> selector { property : "$varUnsafe"; } </style>.
<span style="property : $varUnsafe">О нет</span>.
```

Если вы используете JavaScript для изменения свойства CSS, обратите внимание на использование
`style.property = x`.
Это **Safe Sink**, который автоматически кодирует данные в CSS.

При вставке переменных в свойства CSS убедитесь, что данные должным образом закодированы и обеззаражены для предотвращения инъекционных атак. Избегайте размещения переменных непосредственно в селекторах или других контекстах CSS.

### Выходная кодировка для "Контекстов URL"

Под "контекстами URL" понимаются переменные, помещаемые в URL. Чаще всего разработчик добавляет параметр или фрагмент URL в базу URL, который затем отображается или используется в какой-либо операции. Для таких сценариев используйте кодировку URL.

```HTML
<a href="http://www.owasp.org?test=$varUnsafe">ссылка</a >.
```

Кодируйте все символы с помощью формата кодировки `%HH`. Убедитесь, что все атрибуты полностью заключены в кавычки, как в JS и CSS.

#### Распространенная ошибка

Бывают ситуации, когда вы используете URL в различных контекстах. Наиболее распространенной является добавление его в атрибут `href` или `src` тега `<a>. В таких ситуациях следует использовать кодировку URL, а затем кодировку атрибутов HTML.

``HTML
url = "https://site.com?data=" + urlencode(parameter)
<a href='attributeEncode(url)'>ссылка</a>.
```

Если вы используете JavaScript для создания значения запроса URL, обратите внимание на использование `window.encodeURIComponent(x)`. Это **безопасный сток**, который автоматически кодирует данные в URL.

### Опасные контексты

Кодировка вывода не является идеальной. Она не всегда предотвращает XSS. Такие места известны как **опасные контексты**. К опасным контекстам относятся:

```HTML
<script>Непосредственно в скрипте</script
<!-- Внутри HTML-комментария -->
<style>Непосредственно в CSS</style>
<div ToDefineAnAttribute=test />
<ToDefineATag href="/test" />
```

Другие области, с которыми следует быть осторожными, включают:

- Функции обратного вызова
- Где URL-адреса обрабатываются в коде, таком как этот CSS { background-url : "javascript:alert(xss)"; }
- Все обработчики событий JavaScript (`onclick()`, `onerror()`, `onmouseover()`).
- Небезопасные функции JS, такие как `eval()`, `setInterval()`, `setTimeout()`.

Не помещайте переменные в опасные контексты, так как даже кодировка вывода не сможет полностью предотвратить XSS-атаку.

## Санация HTML

Когда пользователям необходимо создавать HTML, разработчики могут позволить им изменять стиль или структуру контента в WYSIWYG-редакторе. Кодировка вывода в этом случае предотвратит XSS, но нарушит функциональность приложения. Стиль не будет отображаться. В таких случаях следует использовать HTML Sanitization.

Санирование HTML удаляет опасный HTML из переменной и возвращает безопасную строку HTML. OWASP рекомендует [DOMPurify](https://github.com/cure53/DOMPurify) для санации HTML.

```js
let clean = DOMPurify.sanitize(dirty);
```

Есть еще несколько моментов, которые следует учитывать:

- Если вы продезинфицируете содержимое, а затем измените его, вы можете свести на нет все усилия по обеспечению безопасности.
- Если вы дезинфицируете содержимое, а затем отправляете его в библиотеку для использования, проверьте, не изменяет ли она каким-то образом эту строку. В противном случае все ваши усилия по обеспечению безопасности окажутся напрасными.
- Вы должны регулярно обновлять DOMPurify или другие используемые вами библиотеки для санирования HTML. Браузеры меняют функциональность, и обходы обнаруживаются регулярно.

## Безопасные раковины

Специалисты по безопасности часто говорят об источниках и поглотителях. Если вы загрязните реку, она будет течь вниз по течению. То же самое происходит и с компьютерной безопасностью. Источники XSS - это места, где на веб-странице размещаются переменные.

К счастью, многие поглотители, в которые можно поместить переменные, безопасны. Это происходит потому, что такие поглотители воспринимают переменную как текст и никогда не выполняют ее. Попробуйте рефакторить свой код, чтобы удалить ссылки на небезопасные поглотители, такие как innerHTML, и вместо них использовать textContent или value.

```js
elem.textContent = dangerVariable;
elem.insertAdjacentText(dangerVariable);
elem.className = dangerVariable;
elem.setAttribute(safeName, dangerVariable);
formfield.value = dangerVariable;
document.createTextNode(dangerVariable);
document.createElement(dangerVariable);
elem.innerHTML = DOMPurify.sanitize(dangerVar);
```

**Безопасные атрибуты HTML включают:** `align`, `alink`, `alt`, `bgcolor`, `border`, `cellpadding`, `cellspacing`, `class`, `color`, `cols`, `colspan`, `coords`, `dir`, `face`, `height`, `hspace`, `ismap`, `lang`, `marginheight`, `marginwidth`, `multiple`, `nohref`, `noresize`, `noshade`, `nowrap`, `ref`, `rel`, `rev`, `rows`, `rowspan`, `scrolling`, `shape`, `span`, `summary`, `tabindex`, `title`, `usemap`, `valign`, `value`, `vlink`, `vspace`, `width`.

Полный список можно найти в [DOMPurify allowlist](https://github.com/cure53/DOMPurify/blob/main/src/attrs.js).

## Другие элементы управления

Защиты безопасности фреймворка, кодирование вывода и санирование HTML обеспечат наилучшую защиту вашего приложения. OWASP рекомендует использовать их при любых обстоятельствах.

Рассмотрите возможность принятия следующих мер контроля в дополнение к вышеперечисленным.

- Атрибуты cookie - они изменяют способ взаимодействия JavaScript и браузеров с cookie. Атрибуты cookie пытаются ограничить воздействие XSS-атаки, но не предотвращают выполнение вредоносного содержимого и не устраняют основную причину уязвимости.
- Политика безопасности содержимого - список разрешений, который предотвращает загрузку содержимого. При ее реализации легко допустить ошибки, поэтому она не должна быть вашим основным механизмом защиты. Используйте CSP в качестве дополнительного уровня защиты и ознакомьтесь с [cheatsheet here](https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html).
- Брандмауэры веб-приложений - они ищут известные строки атак и блокируют их. WAF ненадежны, и регулярно обнаруживаются новые методы их обхода. WAF также не устраняют первопричину XSS-уязвимости. Кроме того, WAF пропускают класс XSS-уязвимостей, которые работают исключительно на стороне клиента. WAF не рекомендуются для предотвращения XSS, особенно DOM-Based XSS.

### Краткий обзор правил предотвращения XSS

Эти фрагменты HTML демонстрируют, как безопасно отображать недоверенные данные в различных контекстах.

- Тип данных: Строка
- Контекст: Тело HTML
- Код: `<span>Непроверенные данные </span>`.
- Образец защиты: кодирование сущностей HTML (правило \#1)

- Тип данных: Сильный
- Контекст: Безопасные атрибуты HTML
- Код: `<input type="text" name="fname" value="UNTRUSTED DATA">`.
- Образцы защиты: Агрессивное кодирование HTML-сущностей (правило \#2), помещайте недоверенные данные только в список безопасных атрибутов (перечисленных ниже), строго проверяйте небезопасные атрибуты, такие как фон, ID и имя.

Тип данных: Строка
Контекст: GET Параметр
Код: `<a href="/site/search?value=UNTRUSTED DATA">clickme</a>`.
Образец защиты: Кодировка URL (правило \#5).

Тип данных: Строка
Контекст: Недоверенный URL-адрес в атрибуте SRC или HREF
Код: `<a href="UNTRUSTED URL">clickme</a> <iframe src="UNTRUSTED URL" />`.
Образец защиты: Каноникализация ввода, проверка URL, безопасная проверка URL, список разрешенных URL только http и HTTPS (избегайте протокола JavaScript для открытия нового окна), кодировщик атрибутов.

Тип данных: Строка
Контекст: Значение CSS
Код: `HTML <div style="width: UNTRUSTED DATA ;">Выбор</div>`.
Образец защиты: Строгая структурная валидация (правило \#4), шестнадцатеричная кодировка CSS, хороший дизайн CSS-функций.

Тип данных: Строка
Контекст: Переменная JavaScript
Код: `<script>var currentValue='UNTRUSTED DATA ';</script> <script>someFunction('UNTRUSTED DATA ');</script>`.
Пример защиты: Убедитесь, что переменные JavaScript заключены в кавычки, кодировка JavaScript шестнадцатеричная, кодировка JavaScript Unicode, избегайте кодировки обратной косой черты (`\"` или `\'` или `\\\`).

Тип данных: HTML
Контекст: Тело HTML
Код: `<div>Совершенный HTML</div>`
Образец защиты: проверка HTML (JSoup, AntiSamy, HTML Sanitizer...).

Тип данных: Строка
Контекст: DOM XSS
Код: `<script>document.write("UNTRUSTED INPUT: " + document.location.hash );<script/>`
Образец защиты: [DOM-based XSS Prevention Cheat Sheet](DOM_based_XSS_Prevention_Cheat_Sheet.md)|

### Сводка правил кодирования выходных данных

Цель кодирования вывода (применительно к Cross Site Scripting) - преобразовать недоверенный ввод в безопасную форму, в которой он отображается как **данные** для пользователя, не исполняясь в браузере как **код**. На следующих диаграммах приведен список критических методов кодирования вывода, необходимых для предотвращения Cross Site Scripting.

Тип кодировки: Сущность HTML
Механизм кодирования: Преобразование `&` в `&amp;`, преобразование `<` в `&lt;`, преобразование `>` в `&gt;`, преобразование ``` в `&quot;`, преобразование ``` в `&#x27``.

Тип кодировки: Кодировка атрибутов HTML
Механизм кодирования: Кодируйте все символы в формате HTML Entity `&#xHH;`, включая пробелы, где **HH** представляет шестнадцатеричное значение символа в Unicode. Например, `A` становится `&#x41`. Все буквенно-цифровые символы (буквы от A до Z, от a до z и цифры от 0 до 9) остаются некодированными.

Тип кодирования: Кодировка URL
Механизм кодирования: Для кодирования значений параметров используйте стандартное процентное кодирование, как указано в [спецификации W3C](http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.1). Будьте осторожны и кодируйте только значения параметров, а не весь URL или фрагменты пути к URL.

Тип кодировки: Кодировка JavaScript
Механизм кодирования: Кодируйте все символы, используя формат кодировки Unicode `\uXXXX`, где **XXXX** представляет шестнадцатеричную кодовую точку Unicode. Например, `A` становится `\u0041`. Все буквенно-цифровые символы (буквы от A до Z, от a до z и цифры от 0 до 9) остаются некодированными.

Тип кодировки: Шестнадцатеричная кодировка CSS
Механизм кодирования: Кодировка CSS поддерживает форматы `\XX` и `\XXXX`. Чтобы обеспечить правильное кодирование, рассмотрите следующие варианты: (a) добавьте пробел после кодировки CSS (он будет проигнорирован парсером CSS), или (b) используйте полный шестисимвольный формат кодировки CSS, добавив нулевую точку в значение. Например, `A` становится `\41` (короткий формат) или `\000041` (полный формат). Буквенно-цифровые символы (буквы от A до Z, от a до z и цифры от 0 до 9) остаются незакодированными.

## Распространенные антипаттерны: Неэффективные подходы, которых следует избегать

Защититься от XSS очень сложно. По этой причине некоторые ищут короткие пути для предотвращения XSS.

Мы рассмотрим два распространенных [антипаттерна](https://en.wikipedia.org/wiki/Anti-pattern), которые часто встречаются в древних сообщениях, но по-прежнему часто упоминаются в качестве решений в современных сообщениях о защите от XSS на форумах программистов, таких как Stack Overflow и других тусовках разработчиков.

### Единственная зависимость от заголовков Content-Security-Policy (CSP)

Во-первых, давайте проясним, что мы являемся убежденными сторонниками CSP, когда он используется правильно. В контексте защиты от XSS CSP работает лучше всего:

- Используется как техника "защита в глубину".
- Настраивается под каждое отдельное приложение, а не развертывается как универсальное корпоративное решение.

Мы против того, чтобы политика CSP была единой для всего предприятия. Проблемы с таким подходом следующие:

#### Проблема 1 - предположение, что версии браузеров одинаково поддерживают CSP

Обычно существует неявное предположение, что все браузеры клиентов поддерживают все конструкции CSP, которые использует ваша общая политика CSP. Более того, это предположение часто делается без явного тестирования заголовка запроса `User-Agent` на предмет того, действительно ли это поддерживаемый тип браузера, и отказа в использовании сайта, если это не так. Почему? Потому что большинство компаний не хотят отказывать клиентам, если они используют устаревший браузер, который не поддерживает некоторые конструкции CSP уровня 2 или 3, на которые они полагаются для предотвращения XSS.  (По статистике, почти все браузеры поддерживают директивы CSP уровня 1, поэтому, если вы не беспокоитесь о том, что дедушка достанет свой старый ноутбук с Windows 98 и будет использовать какую-нибудь древнюю версию Internet Explorer для доступа к вашему сайту, поддержку CSP уровня 1, скорее всего, можно не предполагать).

#### Проблема 2 - проблемы с поддержкой устаревших приложений

Обязательные универсальные для всего предприятия заголовки ответов CSP неизбежно приведут к поломке некоторых веб-приложений, особенно устаревших. Это приводит к тому, что бизнес начинает сопротивляться рекомендациям AppSec и неизбежно приводит к тому, что AppSec выдает исключения и/или исключения по безопасности до тех пор, пока код приложения не будет исправлен. Но эти исключения из правил безопасности дают трещины в броне XSS, и даже если эти трещины временные, они все равно могут повлиять на ваш бизнес, по крайней мере, на репутацию.

### Опора на HTTP-перехватчики

Другой распространенный антипаттерн, который мы наблюдали, - это попытка справиться с валидацией и/или кодировкой вывода в каком-нибудь перехватчике, например, в Spring Interceptor, который обычно реализует `org.springframework.web.servlet.HandlerInterceptor`, или в фильтре сервлетов JavaEE, который реализует `javax.servlet.Filter`. Хотя это может быть успешным для очень специфических приложений (например, если вы проверяете, что все запросы ввода, которые когда-либо будут отображаться, содержат только буквенно-цифровые данные), это нарушает основной принцип защиты от XSS, который заключается в том, чтобы выполнять кодировку вывода как можно ближе к тому месту, где данные будут отображаться. Как правило, HTTP-запрос проверяется на наличие параметров запроса и POST, но другие заголовки HTTP-запроса, которые могут быть отображены, например данные cookie, не рассматриваются. Обычно мы видим, что кто-то вызывает либо `ESAPI.validator().getValidSafeHTML()`, либо `ESAPI.encoder.canonicalize()` и в зависимости от результатов перенаправляет на страницу ошибки или вызывает что-то вроде `ESAPI.encoder().encodeForHTML()`. Помимо того, что такой подход часто пропускает испорченные входные данные, такие как заголовки запроса или "лишнюю информацию о пути" в URI, он полностью игнорирует тот факт, что выходная кодировка совершенно неконтекстна. Например, откуда фильтр сервлетов знает, что входной параметр запроса будет выведен в контексте HTML (т. е. между тегами HTML), а не в контексте JavaScript, например, внутри тега `<script>` или с помощью атрибута обработчика событий JavaScript? Нет. А поскольку кодировки JavaScript и HTML не являются взаимозаменяемыми, вы остаетесь открытыми для XSS-атак.

Если ваш фильтр или перехватчик не имеет полного представления о вашем приложении и, в частности, не знает, как ваше приложение использует каждый параметр для данного запроса, он не сможет добиться успеха во всех возможных крайних случаях. И мы утверждаем, что при таком подходе он никогда не сможет этого сделать, поскольку обеспечение дополнительного необходимого контекста - слишком сложная задача, и случайное внедрение какой-либо другой уязвимости (возможно, гораздо более серьезной, чем XSS) практически неизбежно, если вы попытаетесь это сделать.

При таком наивном подходе обычно возникает хотя бы одна из этих четырех проблем.

#### Проблема 1 - Кодировка для конкретного контекста не является удовлетворительной для всех путей URI

Одна из проблем заключается в неправильной кодировке, которая все еще может позволить использовать XSS в некоторых путях URI вашего приложения. Примером может быть параметр формы 'lastname' из POST, который обычно отображается между HTML-тегами, так что кодировка HTML достаточна, но может быть крайний случай или два, когда lastname фактически отображается как часть блока JavaScript, где кодировка HTML недостаточна, и, таким образом, он уязвим для XSS-атак.

#### Проблема 2 - подход с использованием перехватчиков может привести к нарушению рендеринга из-за неправильного или двойного кодирования.

Вторая проблема, связанная с этим подходом, может заключаться в том, что применение может привести к неправильной или двойной кодировке. Например, предположим, что в предыдущем примере разработчик сделал правильную кодировку вывода для JavaScript-рендеринга lastname. Но если она уже была закодирована и в HTML, то при выводе на экран легитимная фамилия, например "O'Hara", может выглядеть как "O\&#39;Hara".

Хотя этот второй случай не является проблемой безопасности, если он происходит достаточно часто, это может привести к тому, что бизнес будет против использования фильтра, и, таким образом, бизнес может принять решение об отключении фильтра или способе указать исключения для определенных страниц или параметров, подлежащих фильтрации, что, в свою очередь, ослабит любую защиту от XSS, которую он обеспечивал.

#### Проблема 3 - Перехватчики неэффективны против XSS на основе DOM.

Третья проблема заключается в том, что этот способ не эффективен против XSS на основе DOM. Для этого нужно, чтобы перехватчик или фильтр сканировал все содержимое JavaScript, идущее в составе HTTP-ответа, пытался найти испорченный вывод и проверить, не является ли он восприимчивым к DOM-based XSS. Это просто нецелесообразно.

#### Проблема 4 - Перехватчики неэффективны, если данные из ответов поступают за пределы вашего приложения.

Последняя проблема с перехватчиками заключается в том, что они обычно не обращают внимания на данные в ответах вашего приложения, которые поступают из других внутренних источников, таких как внутренний веб-сервис на базе REST или даже внутренняя база данных. Проблема заключается в том, что если ваше приложение не проверяет эти данные _в момент их получения_ (а это, как правило, единственный момент, когда у вашего приложения достаточно контекста для строгой проверки данных с помощью подхода, основанного на разрешающих списках), эти данные всегда должны считаться испорченными. Но если вы пытаетесь выполнить кодирование вывода или строгую проверку данных на стороне HTTP-ответа перехватчика (например, фильтра сервлета Java), то в этот момент перехватчик вашего приложения не будет иметь представления о наличии испорченных данных, полученных от используемых вами веб-служб REST или других баз данных. Подход, который обычно используется в перехватчиках на стороне ответа, пытающихся обеспечить защиту от XSS, заключается в том, что только совпадающие "входные параметры" считаются испорченными и для них выполняется кодирование вывода или санация HTML, а все остальное считается безопасным. Но иногда это не так? Хотя часто предполагается, что все внутренние веб-службы и все внутренние базы данных могут быть "доверенными" и использоваться как таковые, это очень плохое предположение, если только вы не включили его в глубокое моделирование угроз для вашего приложения.

Например, предположим, что вы работаете над приложением, которое должно показывать клиенту его подробный ежемесячный счет. Предположим, что ваше приложение запрашивает чужую (то есть не принадлежащую вашему конкретному приложению) внутреннюю базу данных или веб-сервис REST, который используется вашим приложением для получения полного имени пользователя, его адреса и т. д. Но эти данные поступают из другого приложения, которое, как вы полагаете, является "надежным", но на самом деле имеет незарегистрированную постоянную XSS-уязвимость в различных полях, связанных с адресами клиентов. Более того, предположим, что сотрудники службы поддержки вашей компании могут изучить подробный счет клиента, чтобы помочь им, когда у клиентов возникают вопросы по поводу их счетов. И вот недобросовестный клиент решает заложить XSS-бомбу в поле адреса, а затем звонит в службу поддержки, чтобы получить помощь со счетом. Если подобный сценарий когда-либо будет реализован, перехватчик, пытающийся предотвратить XSS, полностью пропустит это, и результатом будет нечто гораздо худшее, чем простое появление окна оповещения с сообщением "1", "XSS" или "pwn'd".

### Резюме

И последнее замечание: если бы развертывание перехватчиков / фильтров в качестве защиты от XSS-атак было полезным подходом, разве вы не думаете, что он был бы включен во все коммерческие брандмауэры веб-приложений (WAF) и стал бы подходом, который OWASP рекомендует в этой шпаргалке?

## Похожие статьи

Шпаргалка по атакам **XSS-атаки:**.

В следующей статье описывается, как злоумышленники могут использовать различные виды XSS-уязвимостей (и эта статья была создана, чтобы помочь вам избежать их):

- OWASP: [XSS Filter Evasion Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html).

**Описание XSS-уязвимостей:**.

- Статья OWASP об уязвимостях [XSS](https://owasp.org/www-community/attacks/xss/).

**Обсуждение типов XSS-уязвимостей:**.

- [Types of Cross-Site Scripting](https://owasp.org/www-community/Types_of_Cross-Site_Scripting).

**Как проверить код на наличие уязвимостей межсайтового скриптинга:**.

- [OWASP Code Review Guide](https://owasp.org/www-project-code-review-guide/) Статья о [Reviewing Code for Cross-site scripting](https://wiki.owasp.org/index.php/Reviewing_Code_for_Cross-site_scripting) Уязвимости.

**Как проверить наличие уязвимостей межсайтового скриптинга:**.

- [OWASP Testing Guide](https://owasp.org/www-project-web-security-testing-guide/) статья о тестировании уязвимостей Cross-Site Scripting.
- [XSS Экспериментальные правила минимальной кодировки](https://wiki.owasp.org/index.php/XSS_Experimental_Minimal_Encoding_Rules)# <#Title#>.
